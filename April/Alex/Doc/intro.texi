@node Introduction
@chapter Introduction

@noindent
@code{Alex} is a lexical parser generator system written in @code{April}
for @code{April} programs. By providing a rule file -- which has a
similar format to other favorites such as flex and lex -- you can
generate an efficient tokenizer for use in compilers, parsers for
special languages such as XML, or even for parsing input data.

@code{Alex} converts a set of lexical rules -- expressed using regular
expressions -- into a program that applies those rules on an input
stream and returns `token structures'. This is rather different to
@code{April}'s built-in string matching functions for several reasons.

First of all @code{April} string matching always applies to the whole
string whereas the tokeniser returned by @code{Alex} consumes the `head'
of the data only. Secondly, @code{April} string matching is both more
powerful and at the same time less so. In particular, @code{April}
string matching allows the use of run-time values for matching against
the input string; furthermore the string match can be augmented by a
@code{semantic test} -- either of which are possible in the programs
generated by @code{Alex}. On the other hand, @code{Alex} allows a much
richer range of patterns -- including disjunctive patterns and various
forms of pattern closure. The final distinction is that @code{April}
string matching operates over @code{string} values, whereas the
tokenizers generated by @code{Alex} operate over lists of single
character @code{symbol}s.

These differences combine to allow @code{Alex} generate tokenizers which
are significantly more efficient@footnote{In CPU time -- both the
@code{Alex} input stream and @code{Alex} programs are significantly
larger than their equivalents generated by the @code{April} compiler for
@code{string} matching.} than the @code{string} matching code generated
by the @code{April} compiler.@footnote{Of course that is subject to
change.}
