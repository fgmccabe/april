This is april.info, produced by makeinfo version 4.8 from april.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* april: (april).		Agent programming language
END-INFO-DIR-ENTRY


File: april.info,  Node: iota,  Next: List map,  Prev: ..,  Up: List operations

13.1.10 General iota function
-----------------------------

Function template:
     iota(number?LOW,number?HIGH,number?STEP) => number[]

The `iota' function is a more general version of iota than `..'; it
also  returns the list of integers ranging from LOW to HIGH. However,
it also takes a STEP argument into account.

   If the STEP value is greater than zero, then an ascending list of
numbers is generated. As with `..', if HIGH is smaller than LOW, then
the empty list is returned.

   If the STEP value is less than zero, then a descending list of
numbers is generated. In the descending mode, if HIGH is greater than
LOW, then the empty list is returned.

   It is an error for the STEP value to be zero - this would lead to an
infinite list.

   _Hint:_

     This function is used in combination with the `for' generator loop
     to provide a numeric style of `for' loop where the step value is
     explicitly controlled:

          for X in LOW..HIGH step STEP do
            STATEMENT

     is equivalent to:

          for X in iota(LOW,HIGH,STEP) do
            STATEMENT

     As with regular `for' loops, the function call to `iota' is
     optimized, and the list of numbers is not actually constructed.

   Possible errors:
   * `"1st argument should be an integer"'

   * `"2nd argument should be an integer"'

   * `"3rd argument should be an integer"'

   * `"3rd argument should be a non-zero integer"'


File: april.info,  Node: List map,  Next: List reduction,  Prev: iota,  Up: List operations

13.1.11 Map function over elements of a list
--------------------------------------------

Function template:
     %A[]?T // {(%A)=>%B}?F => %B[]

This is a _higher order_ function to apply a single argument function -
F - to each element of a list - T - and returns the result as a list.
The first element is the result of applying F to the first element of
T.  The second element is the result of applying F to the second
element of T and so on.  For example:
     [1,2,3,4,5] // double
   gives the result:
     [2,4,6,8,10]
   where `double(N)' is defined as multiplying N by 2.

   This higher-order function can be defined in terms of a `collect'
iteration:
     collect {
       for E in T do
         elemis F(E)
      }


File: april.info,  Node: List reduction,  Next: sort,  Prev: List map,  Up: List operations

13.1.12 Reduce list
-------------------

Function template:
     %A[]?T \\ {(%A,%A) => %A}?F => %A

This higher order operator _reduces_ a list of values to a single value
by successively applying a function to each of the elements.

   The result of each step is used as the first argument of the
function call for the next step.  For example:
     [1,2,3,4,5] \\ ADD

is equivalent to the expression:

     ADD(ADD(ADD(ADD(1,2),3),4),5)

where ADD(A,B) is some appropriate binary function.

   _Hint:_

     The higher-order operators `//' and `\\' can be very convenient
     for constructing iterative functions in a high-level way. For
     example, the `fact' definition below gives an implementation of
     the factorial function without the explicit use of recursion or
     iteration:

          fact(?N) => 1..N\\(*);

     We surround the `*' symbol in `()''s in order to override its
     standard interpretation as an infix operator.


File: april.info,  Node: sort,  Prev: List reduction,  Up: List operations

13.1.13 Sort list
-----------------

Function template:
     sort(%A[]?T) => %A[]

This function returns the list containing the elements of T sorted in
ascending order. The ordering used is the standard `April' ordering
(*note Comparisons::).


File: april.info,  Node: Pattern based operations on lists,  Next: Lists and set abstractions,  Prev: List operations,  Up: Lists and sets

13.2 Pattern based operations on lists
======================================

`April' has two functions where a _Pattern_ is used to select elements
from lists. These functions allow lists to be _searched_ for matching
elements - i.e., they allow a form of database interpretation on lists.

* Menu:

* select elements::             Select a matching subset from a list
* reject elements::             Select non-matching elements from a list


File: april.info,  Node: select elements,  Next: reject elements,  Up: Pattern based operations on lists

13.2.1 Select elements from a list
----------------------------------

Function template:
     %A[]?T ^/ P => %A[]

This function returns the list containing all elements of T which match
the pattern P.

   The `^/' function can be expressed using a `collect' expression:

     collect {
       for X in T do
         if P .= X then
           elemis X
       }

   _Hint:_

     The set selection operator `^/' can be used to build a database
     search operation. Suppose that `X' is a database of tuples - of
     names and addresses - `X' might declared as:

          X : [("fred","somewhere") ... ("James T. Smith","Elsewhere")];

     To find the entry in this database which corresponds to the entry
     for `"James T. Smith"', the expression:

          X^/("James T. Smith",_)

     represents all the entries which have `"James T. Smith"' in the
     first element - typically this will be a singleton set but it
     might be empty.


File: april.info,  Node: reject elements,  Prev: select elements,  Up: Pattern based operations on lists

13.2.2 Remove elements from list
--------------------------------

Function template:
     %A[]?T ^\ P => %A[]

This function returns the list containing all elements of T which do
_not_ match the pattern P.

   The `^\' function can be expressed in terms of the expression:

     collect {
       for X in T do
         if P != X then
           elemis X
       }


File: april.info,  Node: Lists and set abstractions,  Prev: Pattern based operations on lists,  Up: Lists and sets

13.3 Lists and set abstractions
===============================

`April' has a higher-level way of specifying lists and sets based on a
set-abstraction notation. These allow lists and sets to be specified in
terms of logical conditions on the elements of the lists and sets, as
opposed to low-level iterations on lists and sets.

   The general form of such an expression is:

     SETOF { TEMPLATE : GENERATING_EXPRESSION}

where the SETOF is a specifier denoting the nature of the list being
built, TEMPLATE is an expression which denotes the `shape' of the
elements of the list and GENERATING EXPRESSION is a logical expression
that governs the conditions for elements in the set.

   As with other list operators, the set abstraction operators denoted
in this section are tranformed by the `April' compiler into iterations
and other more basic operations.

* Menu:

* setof abstraction::
* bagof abstraction::
* counting abstraction::
* generator abstraction::
* element generating condition::
* && abstraction condition::
* || abstraction condition::
* ! abstraction condition::
* istrue abstraction condition::
* forall abstraction condition::


File: april.info,  Node: setof abstraction,  Next: bagof abstraction,  Up: Lists and set abstractions

13.3.1 `setof' abstraction operator
-----------------------------------

The `setof' abstraction operator indicates that a set is specified.
This is a variation of the standard `April' `setof' construct where a
logical condition is used to specify the elements of the set rather
than a statement.

   Note that in `April' a set is defined to be a list which is in
sorted order and has duplicate elements removed.

   The form of a `setof' abstraction is:

     setof { T : CONDITION }

The value of this expression is a list of T values, generated by means
of CONDITION.

   For example, given a list of the form

     ages = [('a,10),('b,20),('c,10),('d,20)];

we can construct a set of age values in the range 10-15 by means of:

     S = setof {A : (_,A) in ages && A>=10 && A=<15 }

The value of `S' would be:

     [10]


File: april.info,  Node: bagof abstraction,  Next: counting abstraction,  Prev: setof abstraction,  Up: Lists and set abstractions

13.3.2 `bagof' abstraction operator
-----------------------------------

The `bagof' operator indicates that a `bag' (i.e., a list) is being
specified. This is a variation of the standard `April' `collect'
construct where a logical condition is used to specify the elements of
the list rather than a statement.

   The form of a `bagof' abstraction is:

     bagof { T : CONDITION }

The value of this expression is a list of T values, generated by means
of CONDITION. This is similar to the `setof' abstraction, except that
the result is not sorted, and there may be duplications.

   For example, given the `ages' list defined in *Note setof
abstraction:: the expression:

     S = bagof {A : (_,A) in ages && A>=10 && A<=15 }

would have the value:

     [10,10]


File: april.info,  Node: counting abstraction,  Next: generator abstraction,  Prev: bagof abstraction,  Up: Lists and set abstractions

13.3.3 Counting abstraction operator
------------------------------------

The counting abstraction is similar to the `bagof' abstraction, except
that a limit is placed on the size of the resulting list.

   The form of the counting abstraction is:

     C of { T : COND }

where T refers to the template expression for elements in the list,
COND is the generating condition, and C is a numeric expression which
controls the size of the list.

   For example, to find at most 2 males, whose ages are greater than
10, we might use the expression:

     2 of { M : M in male && (M,A) in ages && A>10 }


File: april.info,  Node: generator abstraction,  Next: element generating condition,  Prev: counting abstraction,  Up: Lists and set abstractions

13.3.4 Lazy generation of elements
----------------------------------

We can generate elements of a list in a `lazy' fashion - making use of
`April''s `spawn' statement (*note spawn::) - to generate elements of
the list in an incremental way. The `generator' `of' expression is used
for this is:

     generator of { TEMPLATE : GENERATING CONDITION }

The value returned by `generator' is not a list but a `handle'.
Individual elements of the answer list are requested by sending the new
process requests:

`'next'
     This requests the next answer from the generator. The reply to
     this will be one of:
    `('next_is, A)'
          The next available answer to the query is A.

    `'no_more'
          There were no further solutions to the query. Note that the
          generator process will no longer be active if the querier has
          received a `no_more' message.

`'quit'
     If the query process no longer needs additional answers from the
     generator, then it can send a `'quit' message to the generator to
     ask it to terminate itself.

For example, to incrementally generate older males, we might use:

     H = generator of { M : M in male && (M,A) in ages && A > 20 }

Once `spawn'ed, the generator can be controlled using a combination of
`'next' requests and `'next_is' receives:

     while MORE TO do{
       'next >> H;
       receive {
         ('next_is,A) ->> ...    -- deal with the older male
       | 'no_more ->> ...        -- no more answers
       }
     }


File: april.info,  Node: element generating condition,  Next: && abstraction condition,  Prev: generator abstraction,  Up: Lists and set abstractions

13.3.5 Element generating condition
-----------------------------------

The core `method' for generating elements of abstractions is the `in'
test. Within a `setof'/`bagof'/N `of' abstraction, a condition of the
form:

     PTN in EXP

has the effect of `generating' instances of PTN that match elements of
the list or set EXP.

   For example, in the abstraction expression:

     bagof {A : (_,A) in ages && A>=10 && A=<15 }

the expression

     (_,A) in ages

is a generating condition that generates potential elements of the
list. It is possible to combine more than one generating condition in a
single abstraction expression, as in:

     2 of { M : M in male && (M,A) in ages && A>10 }

where there are two generating conditions involved.


File: april.info,  Node: && abstraction condition,  Next: || abstraction condition,  Prev: element generating condition,  Up: Lists and set abstractions

13.3.6 `&&' abstraction condition
---------------------------------

Within a generating expression it is possible to combine two or more
conditions using the `&&' conjunction. The meaning of a generating
expression such as:

     C1 && C2

is simply the conjunction of C1 and C2. Note that either C1 or C2 or
both may be generating expressions or simply testing expressions.

   However in a `setof'/`bagof'/N `of' abstraction the top-level
generating expression should contain at least one element generating
expression. An expression of the form:

     setof { N : N < 10 }

may result in a compile-time error being reported (that `N' is not
declared!).(1)

   ---------- Footnotes ----------

   (1) If `N' is a variable that is in scope in the context of this
expression, then this `setof' expression is legal and will either
return `[N]' or `[]' depending on whether `N' is actually less than 10
or not.


File: april.info,  Node: || abstraction condition,  Next: ! abstraction condition,  Prev: && abstraction condition,  Up: Lists and set abstractions

13.3.7 `||' abstraction condition
---------------------------------

Within a generating expression the `||' conjunction may be used to
specify alternatives. The meaning of a generating expression such as:

     C1 || C2

is simply the disjunction of C1 and C2. Note that either C1 or C2 or
both may be generating expressions.

   For example, to list young females and old males we might use:

     setof { X : X in female && (X,A) in ages && X<10
               || X in male && (X,A) in ages && X>70 }


File: april.info,  Node: ! abstraction condition,  Next: istrue abstraction condition,  Prev: || abstraction condition,  Up: Lists and set abstractions

13.3.8 `!' abstraction condition
--------------------------------

The `!' negation condition may be used for negative tests within the
generating expression. Note that a negated condition can never be used
to _generate_ elements of a `setof'/`bagof'/N `of' abstraction; it can
only filter out potential elements.

   For example, to show those males who have no children, we can use:

     setof { X : X in male && ! (X,_) in parent }

Note that since `!' is used for two purposes in `April' - as a negation
and as a pattern operator, some care is sometimes necessary with
parentheses.


File: april.info,  Node: istrue abstraction condition,  Next: forall abstraction condition,  Prev: ! abstraction condition,  Up: Lists and set abstractions

13.3.9 `istrue' abstraction condition
-------------------------------------

The `istrue' abstraction condition is used to verify that a particular
condition is satisfied. `istrue' is used within the CONDITION of a
`setof'/`bagof'/N `of' abstraction when it is important that the test
condition is only completed once.

   The form of the `istrue' condition is:

     istrue CONDITION

where CONDITION is any logical condition, including element generating
conditions.

   For example, in:

     bagof { M : M in male && istrue (M,A) in parent }

we use the `istrue' condition:

     istrue (M,A) in parent

to ensure that the `parent' test is only done once (`M' may be the
parent of more than one child); which in turn will eliminate `false
duplicates' in the resulting list.


File: april.info,  Node: forall abstraction condition,  Prev: istrue abstraction condition,  Up: Lists and set abstractions

13.3.10 `forall' abstraction condition
--------------------------------------

The `forall' abstraction condition is used to verify that a particular
condition is satisfied for every element of a list or set.

   `forall' is used within the CONDITION of a `setof'/`bagof'/N `of'
abstraction when it is important that all the elements of a list meet
some condition.

   The form of the `forall'  test is:

     TEST forall GEN

where GEN is a generating expression - such as an `in' condition or
more generally the body of a `setof'/`bagof'/N `of' abstraction - and
TEST is a predicate applied to each element generated by GEN.

   For example, to list males who have only male children, we can use
the expression:

     setof { M : M in male && C in male forall (M,C) in parent }


File: april.info,  Node: Processes,  Next: April communications,  Prev: Lists and sets,  Up: Top

14 `April' processes
********************

Processes in `April' are a key abstraction. It is a process-oriented
language that can be used to construct agent systems as well as other
distributed applications.

   A process is identified by its `handle'; a `handle' is a standard
type in `April' which looks like:

     handle ::= hdl(symbol,symbol);

where the first element is the _thread_ identifier and the second is the
_name_ of a group of threads - typically implementing an agent. The
`handle' of a process contains sufficient information for the `April'
engine to be able to deliver messages to the process, as well as other
internal attributes.(1)

* Menu:

* Standard processes::
* Processes and process control::  Forking new sub-processes
* Identification functions::    Miscellaneous identification functions

   ---------- Footnotes ----------

   (1) The form of the handle labelled tuple changed in version~5 of
`April'.


File: april.info,  Node: Standard processes,  Next: Processes and process control,  Up: Processes

14.1 Standard processes
=======================

When the `April' engine is initiated - by invoking the `april' command
- a number of standard processes are also started automatically:

The standard system monitor
     This process is responsible for monitoring system error conditions
     and for managing process termination.

The standard file manager
     This process provides initial access to the file system. By
     default, the standard file manager gives the same access rights to
     the `April' program as the operating system itself. However,
     subsiduary file managers may give restricted access to the file
     system.

`stdin', `stdout' and `stderr'
     The processes corresponding to the standard input, output and error
     channels of the Unix process.

The standard mail input reader
     This process reads messages from the SCS server (if connected).
     Whenever a message arrives from there, the standard mail reader
     `forwards' the message to the appropriate internal process - if it
     exists.

The standard mail despatcher
     When processes send messages the `April' engine delivers the
     message if the recipient process is in the same invocation as the
     sender. Otherwise, the engine delivers the message to the standard
     mail dispatcher which will (normally) upload the message to the
     communications server.

The standard resource manager
     This process allocates memory and CPU cycles to processes. The
     standard resource manager simply gives additional memory and/or
     cycles to each process that requests them. A non-standard resource
     manager may be more thrifty: only giving resources to processes
     representing owners who have paid for them.


File: april.info,  Node: Processes and process control,  Next: Identification functions,  Prev: Standard processes,  Up: Processes

14.2 Processes and process control
==================================

* Menu:

* spawn::                       Fork a new process
* state::                       Return state of process
* done::                        Test for process termination
* kill::                        Terminate a process
* waitfor::                     Wait for a process to terminate
* halt::
* exit::                        Exit from `April' system
* delay::                       Suspend a process for a length of time
* sleep::                       Suspend a process until a point in time


File: april.info,  Node: spawn,  Next: state,  Up: Processes and process control

14.2.1 Spawn a new process
--------------------------

Function templates:
     spawn STATEMENT => handle
     spawn STATEMENT as handle?H=> handle
     spawn STATEMENT using handle?F=> handle

A new process is created to execute the STATEMENT concurrently with
other processes. The `handle' of the new process is returned as the
value of this expression.

   For most of these cases, the `handle' of the new process will be of
the form
     hdl(T,NAME)
   where NAME is the name of the process group that the new process
belongs to (the same group as the process which executed the `spawn') -
unless the `as' option is used, NN is a number which identifies that
the new process is the NNth process in the group, and `host()' is the
name of the local host that this invocation of `April' is running in.

   _Hint:_

     Spawned processes cannot side affect variables in any other
     process - so while it is possible to transmit values of variables
     into a newly spawned process, it is not possible to side-affect
     variables belonging to the spawning process.

* Menu:

* Spawning with a public name::
* Spawning with a different file manager::


File: april.info,  Node: Spawning with a public name,  Next: Spawning with a different file manager,  Up: spawn

14.2.1.1 Spawning with a public name
....................................

The form

     spawn STATEMENT as AGENT

spawns the process with a particular named handle - the value of the
AGENT expression. `spawn'ing a process in this way also causes it to be
registered with the local communications server. This allows other
processes in other `April' invocations to send this `public' process
messages.

   It also has the effect of starting a new process group - it this
process spawns further processes then they will - by default - be given
names based on the public name of the new process.

   The name of the new process is AGENT which should be a `handle'
expression.  AGENT becomes the name of the new process - unless there
already is a process with the same name, in which an error exception is
raise,


File: april.info,  Node: Spawning with a different file manager,  Prev: Spawning with a public name,  Up: spawn

14.2.1.2 Spawning with a different file manager
...............................................

As explained in *Note Input and output:: and *Note File manager::, each
process has associated with it a file manager process that manages
access to the file system. This allows a process to be constrained
within a part of the file system. In order to fully use this facility it
is necessary to specially spawn the process - it is not possible for
non-privileged processes to change the default file manager after they
are running.

   The `spawn'...`using' variation of the `spawn' operator permits us
to create a new process in a different part of the file system:

     H = spawn STATEMENT using sub_manager(DIRECTORY,[_allow_read])
   
The new process will be spawned with DIRECTORY as its current
directory, and it will not be able to access files outside the file
hierarchy rooted in DIRECTORY. In addition, the new process will only
be able to read files in the DIRECTORY, and will not be able to create
pipes or establish TCP-style connections. Of course, the spawning
process must have access to DIRECTORY itself; and must also have at
least read access to DIRECTORY.


File: april.info,  Node: state,  Next: done,  Prev: spawn,  Up: Processes and process control

14.2.2 Report process status
----------------------------

Function template:
     state(handle?P) => _process_state

This function returns the status of the identified process using one of
the following symbols:

`dead'
     if the process identified has completed execution - or if it never
     existed.

`quiescent'
     between the process being created and its first instruction.

`runnable'
     if the process is potentially (or actually) running.

`wait_io'
     if the process is waiting for an I/O operation to complete or
     become available.

`wait_msg'
     if the process is waiting for a message.

`wait_timer'
     if the process is waiting for a timer event.

   These symbols are collected in a system type - `process_state' -
which has the definition:

     _process_state ::= dead | quiescent | runnable | wait_io |
                  wait_msg | wait_timer ;

   Possible errors:
   * `"non-local process handle"'


File: april.info,  Node: done,  Next: kill,  Prev: state,  Up: Processes and process control

14.2.3 Test for process termination
-----------------------------------

Function template:
     done(handle?P) => logical

This function returns `false' if identified process P is still alive.

   _Hint:_

     This function is not able to test a remote process on another host
     computer; however, use the `ping' message to the communication
     server to determine if a remote process is alive or not.

   Possible errors:
   * `"non-local process handle"'


File: april.info,  Node: kill,  Next: waitfor,  Prev: done,  Up: Processes and process control

14.2.4 Kill local process
-------------------------

Procedure template:
     kill(handle?P){}

Kill the process associated with the `handle' P. This primitive also
allows a remote process to be killed. Only a process'es creator (*note
creator::) or manager process may kill a process.


File: april.info,  Node: waitfor,  Next: halt,  Prev: kill,  Up: Processes and process control

14.2.5 Wait for process termination
-----------------------------------

Procedure template:
     waitfor(handle?P){}

This procedure suspends and waits for the process P to terminate.

   This procedure - which is implemented with a standard macro - allows
a process to wait for a remote process to terminate.


File: april.info,  Node: halt,  Next: exit,  Prev: waitfor,  Up: Processes and process control

14.2.6 Halt execution of `April'
--------------------------------

Procedure template:
     halt{}

Exits the `April' system.

   This is a priviliged procedure - and may not be used by a
non-priviliged process.


File: april.info,  Node: exit,  Next: delay,  Prev: halt,  Up: Processes and process control

14.2.7 Exit `April' system
--------------------------

Procedure template:
     exit(number?CODE){}

CODE is an integer.  Exits the `April' system with the given code.
Normally, in Unix, 0 as a termination code is used to signal that the
program terminated successfully, and a non-zero code to signal some
kind of trouble.

   This is a privileged procedure - and may not be used by a
non-privileged process.


File: april.info,  Node: delay,  Next: sleep,  Prev: exit,  Up: Processes and process control

14.2.8 Suspend process for a fixed time
---------------------------------------

Procedure template:
     delay(number?TIME){}

The process suspends execution for TIME seconds.  In that time other
processes may execute.


File: april.info,  Node: sleep,  Prev: delay,  Up: Processes and process control

14.2.9 Sleep until some time
----------------------------

Procedure template:
     sleep(number?TIME){}

The process suspends execution until at least TIME; where TIME is an
absolute time - which is typically some offset from the value returned
by the `now()' built-in function (*note now::).  Until that time other
processes may execute.


File: april.info,  Node: Identification functions,  Prev: Processes and process control,  Up: Processes

14.3 Identification Functions
=============================

* Menu:

* host::                        Identify host machine name
* location::                    Identify current location information
* self::                        Identify current process
* creator::                     Identify creator process
* commserver::                  Identify commserver process


File: april.info,  Node: host,  Next: location,  Up: Identification functions

14.3.1 Name of host computer
----------------------------

Function template:
     host() => string

This returns the name of the machine on which the `April' program is
running. The form of this name is the full `canonical' domain host name
of the computer - where that is available.


File: april.info,  Node: location,  Next: self,  Prev: host,  Up: Identification functions

14.3.2 Location of host computer
--------------------------------

Function template:
     location() => string[]

The `location' function returns a list which represents the location
address of agents running on this machine. By default, the value of
`location' is a single element list containing the same value as
returned by `host'. However, this list can be manipulated either at the
`april' command line - using the `-l LOC' option - or via the local
communications server.

   More precisely, the value of `location' is the union of the local
host machine address, any addresses given at the `April' command line
as `-l LOC' options, the address of the communication server's machine
and any addresses given at the `icm' command line - also as `-l LOC'
options.

   This facility is intended to allow processes to express `handle'
values with complex routing requirements (such as for mobile agents, or
agents executing on mobile computers).


File: april.info,  Node: self,  Next: creator,  Prev: location,  Up: Identification functions

14.3.3 `handle' of current process
----------------------------------

Function template:
     self() => handle

This returns the `handle' of the current process.


File: april.info,  Node: creator,  Next: commserver,  Prev: self,  Up: Identification functions

14.3.4 Creator of current process
---------------------------------

Function template:
     creator() => handle

This returns the `handle' of the process which created the current
process. A process'es `creator' is considered the owner of the process.
Only the system monitor or a process'es `creator' may kill a process.
The value is the same as `self()' for the root process.


File: april.info,  Node: commserver,  Prev: creator,  Up: Identification functions

14.3.5 Identity of the communications server
--------------------------------------------

Function template:
     commserver() => handle

This returns the `handle' of the communications server process that
this invocation of `April' is connected to. This handle is computed by
the `April' system during initilization. If there is no commserver,
then a `"no communications server"' error exception is raised.


File: april.info,  Node: April communications,  Next: Environment,  Prev: Processes,  Up: Top

15 How `April' programs communicate
***********************************

In order for processes to communicate it is necessary to establish a
number of conditions: the identity of the target process, its location
and the means of delivering the message. `April' provides a simple
mechanism to permit communication between `April' processes - and also
between `April' and `Go!' processes. However, the _Simple
Communications System_ is deliberately designed to be small scale -
focusing on inter-process communication between distributed nodes that
logically form a single application.

   Communication between applications is characterized by different
scale levels and different assumptions: communication between nodes
within a single distributed application, communication between
applications  and communication across ownership boundaries are all
very different in character and requirements. The Simple Communication
System (SCS) is oriented to the first of these: communication within a
single distributed application.

   The SCS supports a thread-to-thread communications model, where once
registered, all that a process needs to do to send a message is to send
it as though it were a local process it was sending it to. The SCS
server maintains a database of all the registered processes and can
route messages from one node to another in a seamless way. The main
constraint that the SCS imposes is that all handles within its domain
must be unique; and, since handles themselves contain no addressing
information, it can only deliver messages between nodes that have
properly registered with the server.

   The SCS is support within `April' by a library - the `scomms.af'
library - that participating applications `import'. Typically, an
`April' program that is intended to be used with the SCS will import
this library and establish a connection with the server as part of the
initialization process:
     program
       import <scomms.af> in {
       ...
       main(){
         scsConnect(start,"localhost", 4545);
       };
       ...
       start(){
         ...
       }
     }
   The `scsConnect' procedure is the entry point to the `scomms'
library: it has three arguments: the zero-argument procedure to
execute, the host name that the SCS server is executing on and the port
number that it is listening on.

   The `scsConnect' procedure establishes a connection to the SCS
server, and executes its procedure argument. During the execution of
that procedure (`start' in the sample above) any messages that are not
local will be forwarded to the SCS server automatically, and any
messages intended for this process from other nodes in the SCS network
will be automatically routed to this program.

   Once `start' terminates, then the connection to the SCS server will
also be terminated.

   In the rest of this section we explain how the SCS server is
initiated and the details of connecting to the server are covered.

* Menu:

* The communicative process::
* the communications server::
* the scomms library::


File: april.info,  Node: The communicative process,  Next: the communications server,  Up: April communications

15.1 The communicative process
==============================

The process of sending a message between processes within a single
`April' invocation is very straightforward. If the message is destined
for another process inside the same `April' invocation, the execution
engine simply puts a pointer to the message in the new process's
message queue. The situation is more complex when the message is sent
to a process in a different host machine (or even on the same host
machine but in a different invocation of `April'. In the latter case
messages are routed using the SCS server.

   The process of sending such a message involves a number of steps:

  1. When an `April' program sends a message, the underlying `April'
     machine attempts to deliver that message to a `local' process. If
     the recipient of the message is a local process, then the message
     is `handed over' to the recipient, and the message send terminates.

  2. Each `April' process that is executing in the `April' machine has
     associated with it a `mailer process'. Normally, the default
     mailer process discards messages that are not local; however, if a
     connection has been made to the SCS server - as part of a
     `scsConnect' for example - then this mailer is replaced by one
     that can communicate with the SCS server.

  3. When the mailer process is handed a message to deliver, it sends
     it to the communication server - using the `fencode' procedure
     (*note fencode::).

  4. The SCS server is typically shared by a number of different
     `April' invocations and potentially other processes using the same
     protocol. The SCS server reads messages from all its clients and
     distributes the messages appropriately to those that are
     registered with it.

  5. The `April' mailer process is actually composed of two processes -
     one for sending messages to the communications server, and one for
     reading messages from the server. When the SCS server sends the
     `April' engine a message, the reader half of the mailer process
     reads the message - using `fdecode' (*note fdecode::) - and then
     `hands over' the message to the final recipient of the message
     using the same mechanism that is used for purely internal message
     passing.

   Although this process may seem complicated, it has a number of
important features:

   * Messages within a single `April' invocation are handled very
     efficiently.

   * Message traffic between invocations is controlled by both an
     `output gate' and an `input gate' - written in `April'. This allows
     certain security checks to be implemented on messages - such as
     verifying that any embedded code is safe to execute.

   * The fact that different `April' processes may have different mailer
     processes associated with them means that it is possible to create
     a `tailored environment' for the execution of certain processes.
     It is possible, for example, to restrict certain processes
     (including any processes forked from the restricted processes) to
     communicate only with certain other hosts (or none).


File: april.info,  Node: the communications server,  Next: the scomms library,  Prev: The communicative process,  Up: April communications

15.2 The Simple Communications System server
============================================

The communications server is used to allow messages to be sent between
different `April' processes - either on the same computer but in
different `April' invocations, or on different computers.

   The SCS server is an `April' program(1) that is started like any
other `April' program:
     april scs.aam 4545
   The number supplied on the command line is the port number that this
invocation of the SCS server will be listening on. It can be any
number, so long as all participating nodes use the same number.

   As part of the `April' installation, the `scs' program automatically
invokes the server:
     scs 4545

   ---------- Footnotes ----------

   (1) In fact, it is a relatively small program - some 200 lines of
`April'


File: april.info,  Node: the scomms library,  Prev: the communications server,  Up: April communications

15.3 The `scomms.af' communications library
===========================================

The `<scomms.af>' library gives access to the SCS to `April' programs.
It is typically only required to import the library - and to estabish a
connection - once: at the top-level of the application. Other modules
which the application imports will automatically use the SCS if the
main application has registered properly.

* Menu:

* scsConnect::
* scsConnectAs::


File: april.info,  Node: scsConnect,  Next: scsConnectAs,  Up: the scomms library

15.3.1 The `scsConnect' procedure
---------------------------------

The `scsConnect' procedure allows a process to connect to the SCS
server _using its already existing handle_.

   Procedure template:
     scsConnect((){}?PROC,string?HOST,number?PORT)

The `scsConnect' procedure estabishes a connection to the SCS server
that is currently listening to PORT on the computer known as HOST. Once
the connection is estabished, it executes the zero-argument procedure
PROC.

   During the execution of PROC messages can be sent to other processes
that are also registered with the SCS server, and any messages sent to
this process from those other nodes will be forwarded. Such forwarded
messages are picked up using the normal message `receive' and `repeat'
statements.

   The SCS server will not permit more than one process to be
registered with it with the same handle. Thus, if there already is a
process registered with the same handle then the `scsConnect' procedure
will raise an error:
     error(handleName(self())^0++" already registered",'failed)
   If the `scomms' library cannot find the SCS server, then the error:
     error("can't establish proper address",'failed)
   will be raised.


File: april.info,  Node: scsConnectAs,  Prev: scsConnect,  Up: the scomms library

15.3.2 The `scsConnectAs' procedure
-----------------------------------

The `scsConnect' conencts to the SCS server using the processes
existing handle. It can be convenient to combine a registration with
the server with a specific handle, the `scsConnectAs' procedure allows
this:

     scsConnectAs((){}?PROC,handle?H,string?HOST,number?PORT)

The `scsConnectAs' procedure is similar to the `scsConnect' procedure
except that it uses H as the handle that is registered with the SCS
server.


File: april.info,  Node: Environment,  Next: Resource limited execution,  Prev: April communications,  Up: Top

16 `April' environment primitives
*********************************

These primitives access `April''s environment - they include primitives
to access the current `wall clock' time, to invoke Unix programs and to
interact with the Unix environment that the `April' program is embedded
within.

* Menu:

* Date and time::               Access to the `wall clock'.
* Hostnames and host addresses::
* Program control::             Access to the program's call args etc.


File: april.info,  Node: Date and time,  Next: Hostnames and host addresses,  Up: Environment

16.1 Date and Time
==================

Time in `April' is kept in _seconds_ since the `April' epoch; which is
defined as 00:00:00 UTC(1), 1st of January 1970 - i.e., otherwise known
as UNIX epoch. The time by the standard `April' function `now' (*note
now::) is returned as a possibly fractional number - allowing
sub-second precision in time calculations. However, the real accuracy
depends on the underlying operating system - under Sun Solaris and
Linux, this is at least millisecond accuracy.

* Menu:

* date type::
* today::                       Today's date
* now::                         The time now
* timetodate::                  Convert time value to local date format
* timetogmt::                   Convert time value to UTC date
* datetotime::                  Convert date value to time value
* ticks::                       Number of milliseconds since `April' started
* secs::                        Convert seconds into numbers
* mins::                        Convert minutes into numbers
* hours::                       Convert hours into numbers
* days::                        Convert days into numbers

   ---------- Footnotes ----------

   (1) UTC used to be known as Greenwich Mean Time (GMT).


File: april.info,  Node: date type,  Next: today,  Up: Date and time

16.1.1 Standard `date' type
---------------------------

`April' uses a standard type - called `date' - for some of its date and
time functions. A `date' encapsulates the key features of a date - the
year, month, day and time.

   The declaration of `date' is:
     date ::= date(number?year,
                    number?month,
                    number?day,
                    number?dow,
                    number?hour,
                    number?min,
                    number?sec);

Note that not all of the fields may be used by all date/time functions.

   The fields of this record are specified as:
`year'
     The number of years since the Christian Era.

`month'
     The number of the month, with January counted as 1, and December
     counted as 12.

`day'
     The day of the month, from 1 through 31.

`dow'
     The day of the week, with Sunday counting at 1, and Saturday
     counted as 7.

`hour'
     The hour of the time, with 0 being 12 Midnight.

`min'
     The minutes of the hour, from 0 to 59

`sec'
     The number of seconds in the minute, in the range [0,60). This is
     a possible _fractional_ number, when the time is not an even
     number of seconds.


File: april.info,  Node: today,  Next: now,  Prev: date type,  Up: Date and time

16.1.2 Report today's date
--------------------------

Function template:
     today() => number

This function returns the `April' time at midnight today.  This
function allows for timezone differences.


File: april.info,  Node: now,  Next: timetodate,  Prev: today,  Up: Date and time

16.1.3 Report current time
--------------------------

Function template:
     now() => number

This function returns the `April' time at the time of call. The
returned value is generally a fractional number - the fractional part
denoting portions of a second. The accuracy of the returned value
depends on the underlying system clock, but is typically accurate to the
nearest millisecond.


File: april.info,  Node: timetodate,  Next: timetogmt,  Prev: now,  Up: Date and time

16.1.4 Convert raw time into a date value
-----------------------------------------

Function template:
     timetodate(number?WHEN) => date

This function converts a raw time value, as returned by `now' (*note
now::), into a `date' value; giving the date in a more convenient form.

   The `date' value returned in relative to the local time zone.


File: april.info,  Node: timetogmt,  Next: datetotime,  Prev: timetodate,  Up: Date and time

16.1.5 Convert raw time into a UTC date.
----------------------------------------

Function template:
     timetogmt(number?WHEN) => date

This function converts a raw time value, as returned by `now' (*note
now::), into a `date' value giving the date in a more convenient form.
The returned record gives the year - as a number starting from 1900 -,
the month - as a number from 1 to 12, the day in the month - as a
number from 1 to 31, the time in hours, minutes and seconds.

   The date returned is relative to universal time, or UTC time. Thus, a
value calculated using `timetogmt' will have the same value at the same
moment in time, all over the world.


File: april.info,  Node: datetotime,  Next: ticks,  Prev: timetogmt,  Up: Date and time

16.1.6 Convert a date record into a raw time
--------------------------------------------

Function template:
     datetotime(date?WHEN)=>number

This function converts a `date' record into a raw time - i.e., a
`number' value, as returned by `now' (*note now::). The input record is
interpreted in the normal way: the year field is a number starting from
1900, the month field is a number from 1 to 12, the day field is a
number from 1 to 31, and the time fields specify the hours, minutes and
seconds of the moment in time. Note that the `dow' field is ignored in
this computation.


File: april.info,  Node: ticks,  Next: secs,  Prev: datetotime,  Up: Date and time

16.1.7 Report system clock
--------------------------

Function template:
     ticks() => number

This function returns the number of milliseconds passed since the
program was started. This clock wraps around after approximately one
week.


File: april.info,  Node: secs,  Next: mins,  Prev: ticks,  Up: Date and time

16.1.8 Number of seconds
------------------------

Function template:
     number?N secs => number

This is a relative time function that converts a number of seconds N
into a number.  e.g.
     delay(35 secs);

will cause the process to sleep for 35 seconds.


File: april.info,  Node: mins,  Next: hours,  Prev: secs,  Up: Date and time

16.1.9 Convert minutes to time values
-------------------------------------

Function template:
     number?N mins => number

This function returns the relative time value corresponding to N
minutes. The underlying numerical value is expressed in seconds; so this
function effectively computes the expression: 60 * N


File: april.info,  Node: hours,  Next: days,  Prev: mins,  Up: Date and time

16.1.10 Convert hours to time values
------------------------------------

Function template:
     number?N hours => number

This function returns the numeric value - in seconds - corresponding to
N hours. The underlying numerical value is expressed in seconds; so
this function effectively computes the expression: 3600 * N


File: april.info,  Node: days,  Prev: hours,  Up: Date and time

16.1.11 Convert days to time values
-----------------------------------

Function template:
     number?N days => number

This function returns the number of seconds corresponding to N days.
This function effectively computes the expression: 86400 * N

   The various time expressions may be mixed as in
     interval := 2 days + 5 hours + 30 mins;


File: april.info,  Node: Hostnames and host addresses,  Next: Program control,  Prev: Date and time,  Up: Environment

16.2 Hostnames and host addresses
=================================

These functions give access to the Internet's DNS nameserver systems -
for determining the IP address of a host machine and the host name
associated with a particular IP address.

   Note that in certain situations, using the DNS nameserver network may
not be totally secure: in particular mapping a host name to its IP
address may not be secure.

* Menu:

* iptohost::                    Compute host name from IP address
* hosttoip::                    Compute IP address from host name


File: april.info,  Node: iptohost,  Next: hosttoip,  Up: Hostnames and host addresses

16.2.1 Compute host name from IP address
----------------------------------------

Function template:
     iptohost(string?IP)=>string

The `iptohost' function returns the `canonical' host name associated
with a particular IP address. The IP address is given as a string, in
standard Internet quartet form.

   Note that there may be additional host names associated with a given
IP address, and that the returned value may not always be stable - in
the situation where multiple hosts share a common IP address for
example.


File: april.info,  Node: hosttoip,  Prev: iptohost,  Up: Hostnames and host addresses

16.2.2 Compute IP addresses associated with a host name
-------------------------------------------------------

Function template:
     hosttoip(string?HOST)=>string[]

The `hosttoip' function returns a list of IP addresses that are
associated with a given hostname. A list is returned because a given
computer may have several connections to the network, and each has a
separate IP address.


File: april.info,  Node: Program control,  Prev: Hostnames and host addresses,  Up: Environment

16.3 Program Control
====================

* Menu:

* command_line::                Return invoking command line
* setenv::                      Set O/S environment variable
* getenv::                      Get O/S environment variable
* envir::                       Return all environment variables
* shell::                       Execute other program
* exec::                        Fork other program


File: april.info,  Node: command_line,  Next: setenv,  Up: Program control

16.3.1 Command line arguments
-----------------------------

Function template:
     command_line() => string[]

This function returns the command line arguments as passed to the
`April' application WITHOUT ANY OF THE OPTION FLAGS.

   The result is a list of strings; generally, elements of this list
must be via type coercion expressions (*note type coercion::).

   _Note:_

     This function does NOT convert any of the arguments into lists or
     tuples. For example, the `April' invocation:
          % april foo "(gamma,2)"

     would result in a returned value of `command_line()' of:
          ["foo", "(gamma,2)" ]

     In order to interpret the second element of this list as an `April'
     tuple, use a string pattern such as:

          (symbol,number)[]%%X .= "(gamma,2)"

   _Hint:_

     The `April' compiler and run-time system arrange for the first N
     arguments on the command line to be coerced into the appropriate
     type for the call to the program's `main' procedure. Where the
     arguments to a program are fixed, it should not be necessary to use
     either the `command_line' function to access the arguments suplied
     by the user.


File: april.info,  Node: setenv,  Next: getenv,  Prev: command_line,  Up: Program control

16.3.2 Set Unix environment variable
------------------------------------

Procedure template:
     setenv(string?VAR,string?VALUE){}

Sets the Unix environment variable VAR to VALUE. Note that the
environment variable is _not_ exported to the calling shell.


File: april.info,  Node: getenv,  Next: envir,  Prev: setenv,  Up: Program control

16.3.3 Get environment variable
-------------------------------

Function template:
     getenv(string?VAR) => string

This function returns the value of the environment variable VAR.

   If the environment variable is not defined, then an error exception
is raised:
   * `"environment variable not defined"'


File: april.info,  Node: envir,  Next: shell,  Prev: getenv,  Up: Program control

16.3.4 Report environment variables
-----------------------------------

Function template:
     envir() => (string,string)[]

Report current environment variables into a list whose elements are
tuples of the form (variable,value).


File: april.info,  Node: shell,  Next: exec,  Prev: envir,  Up: Program control

16.3.5 Invoke Unix shell command
--------------------------------

Function template:
     shell(string?CMD,string[]?ARGS,string[]?ENV) => number

Execute CMD with argument and environment lists ARGV and ENVP. ARGV
must be a list of strings representing the arguments to the command.
ENVP should be a list of strings whose elements are of the form
"variable=value", defining the environment for the command execution.

   The `shell' function waits for the shell termination before
returning a value.  The returned value is the return code returned by
the executed command.


File: april.info,  Node: exec,  Prev: shell,  Up: Program control

16.3.6 Execute a Unix sub-process
---------------------------------

Function template:
     exec(string?PATH,string[]?ARGV,string[]?ENVP){}

Fork a Unix command specified by PATH, with argument and environment
lists ARGV and ENVP. ARGV must be a list of strings representing the
arguments to the command.  ENVP should be a list of strings whose
elements are of the form "variable=value", defining the environment for
the file execution.

   There are several differences between this procedure and the `shell'
function:
   * The command is executed in parallel with the `April' system.

   * It is possible to bind the environment variables of the
     sub-process.

   * It is somewhat clumsier to use.


File: april.info,  Node: Resource limited execution,  Next: Debugging April programs,  Prev: Environment,  Up: Top

17 Resource limited execution
*****************************

`April' permits a process - or a group of processes - to be executed in
a resource limited environment. This means that the amount of CPU
processor time, access to the file system and access to messages to and
from other `April' processes can all be controlled.

   Together with an implementation of message encryption, a resource
limited execution environment permits a _secure_ environment for
`April' programs to be executed. Particularly in the context of mobile
programs, the ability to restrict the system resources available to a
process is very important.

   The two key concepts required for implementing resource limited
execution are the so-called privileged processes (*note Privileged
processes::) and the _manager processes_.

   When a process is to be executed in a `non-trusted' mode, then it is
`spawn'ed as a non-privileged process; any processes that _it_ spawns
are similarly non-privileged.

   For each executing process, there are several manager processes
which are responsible for implementing policy towards their controlled
processes. For example, there is a manager process to control access to
the file system and a manager process to control access to the
communications channel. Typically, each manager process is written in
`April' and controls a number of subsidiary processes: by default, when
a process is `spawn'ed, it inherits its manager processes from its
parent process.

* Menu:

* CPU time::                    How access to the CPU is controlled
* File manager::                How access to the file system is controlled
* Communications manager::      How access to the communications is controlled
* Code verification::           Verifying proper semantics for code


File: april.info,  Node: CPU time,  Next: File manager,  Up: Resource limited execution

17.1 CPU time
=============

The amount of CPU time that a process may consume is controlled using
two features of `April': a `click counter' which `contains' a number of
CPU `clicks'(1) and a `within' statement that controls the execution of
a statement relative to a given click counter.

   Click counters can only created and manipulated by privileged
processes; however, any process may use any click counter that it has
access to.

   The `April' engine implements a mechanism whereby the CPU time spent
executing statements and other executable elements is accurately
allocated to a given click counter. At any given time, each process is
using a given click counter (CC) - different processes may be using
different CCs, and a given process may use different CCs at different
times.

   However, if the current CC `times out'; i.e., if the available number
of clicks on a CC goes to less than zero, then the current execution is
aborted with a ``clickedout'' error. Therefore, the correct way of
invoking a computation which may run out of clicks is by surrounding it
with an `onerror' structure:

     try
       STMT within C
     onerror
       clickedout -> RECOVER FROM CLICKED OUT
     | E -> exception E           -- report all other errors

The `April' system has a few built-in primitives for creating CCs, and
modifying them. Explicitly destroying a CC is not necessary since the
garbage collector will remove unreferenced CCs; however, any `time' on
the CC will also be lost.

   _Hint:_

     One use for CCs and the `within' operator is constrained
     execution. There is an important class of algorithms which are
     inherently open-ended - for example, game tree searching
     algorithms in chess have no obvious termination. Using a CC allows
     an application to use such an open ended algorithm and to use the
     best result arrived at so far within a time constraint.

* Menu:

* Create a new Click Counter::
* Access current clicks::
* Access click counter value::
* Modify a click counter::
* Constrained execution of a statement::

   ---------- Footnotes ----------

   (1) A single click is approximately equal to 0.1 milliseconds of CPU
time. However, due to the vagarities of typical CPU clocks, any
resolution less than 100milliseconds is often not especially accurate.


File: april.info,  Node: Create a new Click Counter,  Next: Access current clicks,  Up: CPU time

17.1.1 Create a new Click Counter
---------------------------------

Function template:
     __new_clicks(number?AMOUNT) => __opaque__

The `__new_clicks' function constructs a new CC with a specified number
of clicks credited to it. This function is privileged; i.e., may not be
executed by a non-privileged process.

   `__opaque__' is `hidden' `April' type, in the sense that there are
no literal values of type `__opaque__', and values of the `__opaque__'
type may not be sent in messages outside the `April' invocation that
created them.

   The AMOUNT of clicks in the initial value of the CC must be a
positive integer.


File: april.info,  Node: Access current clicks,  Next: Access click counter value,  Prev: Create a new Click Counter,  Up: CPU time

17.1.2 Access current clicks
----------------------------

Function template:
     __get_clicks(handle?P) => __opaque__

This function returns the CC currently associated with the local
process identified by P. This is also a privileged function.


File: april.info,  Node: Access click counter value,  Next: Modify a click counter,  Prev: Access current clicks,  Up: CPU time

17.1.3 Access click counter value
---------------------------------

Function template:
     __clicks(__opaque__?P) => number

This function returns the number of clicks remaining in a CC.  This is
not a privileged function.


File: april.info,  Node: Modify a click counter,  Next: Constrained execution of a statement,  Prev: Access click counter value,  Up: CPU time

17.1.4 Modify a click counter
-----------------------------

Procedure template:
     __credit_clicks(__opaque__?FROM,__opaque__?TO,number?AMT){}

This procedure subtracts AMT clicks from the FROM CC and adds them to
the CC TO. This privileged procedure can be used to `empty' a CC that
is no longer needed - and presumably to give the owner of the FROM CC
some compensatory reward.


File: april.info,  Node: Constrained execution of a statement,  Prev: Modify a click counter,  Up: CPU time

17.1.5 Constrained execution of a statement
-------------------------------------------

The `within_' statement executes a statement using an explicitly
referenced CC. The form of the `within_' statement is:

     STMT within_ CC

If the statement STMT terminates normally, then no further actions are
taken by the `April' engine. However, if the STMT cannot complete in
the time remaining in CC then a `clickedout' exception is raised.

   A higher level version of this statement accepts a simple numerical
value rather than a click counter:

     STMT within TIME

This statement `borrows' TIME clicks from the process's `current' click
counter and uses that to execute statement. If the process terminates
within the allotted time the balance of the clicks are returned to the
original click counter.

   Note that, unlike `__new_clicks', the `within' does not require
privileged access to the system - allowing non-privileged processes to
use `within' to constrain sub-activities.

   _Hint:_

     Using `within', it is possible to also constrain the execution of
     an expression. One re-expresses the expression using a
     `valof'/`valis' combination: 

          valof{
            valis EXP within TIME
          }


File: april.info,  Node: File manager,  Next: Communications manager,  Prev: CPU time,  Up: Resource limited execution

17.2 File manager
=================

The file manager is a privileged system process that controls access to
the file system. Its function is to provide high-level access to the
operating system's file system and at the same time limit access to a
portion of the file system.

   When an application program needs to open a file, it sends a message
to the process's file manager - each process has a unique file manager,
though there may be several file managers active at any one time. The
file manager verifies that access to the file is permitted, and forks a
sub-process with responsibility for managing the file - the handle of
which is returned to the application process.

   Only the sub-process created by the file manager for handling a file
is permitted to directly access that file. `April' verifies that when a
process attempts to use a low-level file access primitive the process
`owns' the file. The ownership of a file by a process is a property set
by the file manager.

   When a file manager is created, for example by using the
`sub_manager' function (*note sub_manager::), it is given a `home'
directory and a `current directory'. The home directory represents the
top of the file system hierarchy that the new file manager is allowed to
access. Any files outside its home directory are not visible to the file
manager or to any processes using this file manager.

   In addition to a home directory, a file manager has a set of access
privileges, such as read, write, pipe and so on. These privileges are
used in combination with the operating system's file privileges to
further restrict access to files. Irrespective of the operating system's
file privileges, a file manager will not allow a client process to
access a file in a way that violates its access privileges.

   The combination of home directory and access privileges allows a
process to executed in a `portion' of the file system. For example, it
is possible to restrict a process to files in the `/tmp' directory, and
further more to only permit read access to those files.

   This `replication' of the operating system's file privileges is
necessary because an `April' program may be running guest programs at
the same time as running `owner' programs. These need different access
rights reflecting the degree to which the programs are trusted.


File: april.info,  Node: Communications manager,  Next: Code verification,  Prev: File manager,  Up: Resource limited execution

17.3 Communications manager
===========================

The communications manager is a system process that handles the
communications to the `outside world' within a tank.

* Menu:

* How the communications manager works::


File: april.info,  Node: How the communications manager works,  Up: Communications manager

17.3.1 How the communications manager works
-------------------------------------------

The `builtin' function in `April' for sending a message is only able to
send messages to other processes within the same tank that the sender
of the process resides in. This of course accounts for the vast
majority of message sends.

   When a process attempts to send a message to another process, the
builtin message send function checks to see if the message is for a
local process. If it is, then it attaches the message to the process's
message queue, assigning it a sequence number as it does so, and waking
up the receiver process if it is not currently active.

   If a message is sent to a non-local process, then the message is
diverted to the sender process's communications manager. This process
is local, and resides in the same tank as the sender. If the message to
the non-local process was sent using a statement such as:

     MSG >> TO
   then the message that arrives at the communications manager is:
     (TO-HANDLE,REPLY-HANDLE,SENDER-HANDLE,MSG)

This is enough for the communications manager to be able to determine
the true destination of the message.

   The communications manager maintains a TCP connection to the local
communications server - *note the communications server::. When it
receives a message intended for the outside world (which it can
determine via analyzing the TO-HANDLE) it sends the message to the
communications server using `April''s encoded term format - this
guarantees that programs as well as regular `April' values can be sent
safely across the Internet.

   Before it passes the message on, it is able to verify that the
process that sent the message is allowed to send it to the identified
host.(1)

   Similarly, the communications manager is able to read messages - in
encoded term format - from the communications server and `pass on' the
message to the relevant local process if it exists. Again, the manager
is able to verify that the intended recipient is permitted to receive
messages from the process that sent the message.

   ---------- Footnotes ----------

   (1) At the time of writing, the standard communications manager does
not enforce any policy restrictions on sending messages


File: april.info,  Node: Code verification,  Prev: Communications manager,  Up: Resource limited execution

17.4 Code verification
======================

Particularly in the context of mobile programming, it is necessary to
verify that the executable code that an `April' engine attempts to
execute is `safe'. I.e., that a particular code fragment cannot access
system resources that it is not permitted to have, and that it does not
attempt to `corrupt' the `April' engine by overwriting internal memory
buffers.

   Note that a safe program is not necessarily the same as a useful
program. `April' can determine if a program is potentially dangerous to
it; but it cannot determine if the program computes anything useful.

   The  `April'  engine supports  code  verification  at the  internal
`April'  machine  level. Builtin  to  the  `April' engine  are
facilities   for  verifying   the   `byte  code'   of  an   `April'
program.(1)  Program verification  is performed at  the level of byte
code because that is  how programs are transmitted: as sequences of
byte codes. In  addition, since a program could  potentially arrive from
anywhere in the  world, it is not sufficient  to verify the `April'
compiler (a malicious  user may have modified the  standard compiler, or
even constructed a new one).

* Menu:

* Privileged processes::
* verify code::

   ---------- Footnotes ----------

   (1) April's virtual machine uses  a 32bit word code rather than a
byte code.


File: april.info,  Node: Privileged processes,  Next: verify code,  Up: Code verification

17.4.1 Privileged processes
---------------------------

`April' distinguishes two kinds of processes, normal and privileged.
These processes are, for the most part, identical except that certain
low-level operations are not permitted to normal processes.

   A privileged process is one that has full access to the `April'
machine (and hence to the underlying operating system); whereas a
non-privileged process may not have direct access to the operating
system. A certain number of `April' machine instructions and built-in
functions and procedures may only be executed by privileged processes -
attempts to execute a privileged instruction by a non-privileged
process results in a run-time error exception.

   When `April' initializes, _all_ processes are automatically
privileged (it is assumed that the user of a computer will only execute
programs that he or she is confident of). When a process is forked, it
can be forked in such a way as to restrict its privileged status to
normal process.

   Normal processes can fork other processes - including public
processes - but it cannot fork another privileged process.


File: april.info,  Node: verify code,  Prev: Privileged processes,  Up: Code verification

17.4.2 Verify code
------------------

Procedure template:
     _verify(any?VAL,logical?PRIV){}

The `_verify' procedure accepts _any_ `April' value and examines it for
embedded programs. If any embedded programs violate one of the
constraints then an error is raised; otherwise `_verify' completes
silently.

   The PRIV flag is `true' if privileged instructions are allowed
within VAL, `false' if privileged instructions are prohibited.

   _Hint:_

     It is not normally necessary to invoke `_verify' directly: it is
     automatically invoked by the standard mailer process to verify
     incoming messages.

   The code verifier returns many potential errors, most of these are
useful for debugging purposes only:
   * `"invalid access to environment"'

   * `"illegal access to parameter"'

   * `"illegal access to local variable"'

   * `"accessing non-initialized variable"'

   * `"assigning to illegal location"'

   * `"depth lower than specified limit "'

   * `"invalid literal reference"'

   * `"literal should be a symbol"'

   * `"literal should be a string"'

   * `"literal should be a floating point"'

   * `"skipped instruction too long"'

   * `"illegal destination of branch"'

   * `"invalid code signature"'

   * `"invalid number of parameters"'

   * `"function code expected"'

   * `"procedure code expected"'

   * `"pattern code expected"'

   * `"privileged escape function"'

   * `"undefined escape function"'

   * `"multiple allocv instruction"'

   * `"invalid allocv instruction"'

   * `"incorrect return from function"'

   * `"incorrect return from procedure"'

   * `"incorrect return from pattern"'

   * `"invalid return value offset from function"'

   * `"invalid number of parameters in mproc"'

   * `"invalid number of parameters in mfun"'

   * `"invalid number of parameters in mpttrn"'

   * `"invalid loc2tpl arity"'

   * `"invalid access to tuple"'

   * `"tuple update is a privileged instruction"'

   * `"unimplemented instruction"'


File: april.info,  Node: Debugging April programs,  Next: April syntax,  Prev: Resource limited execution,  Up: Top

18 Debugging `April' programs
*****************************

`April' supports the `remote debugging' of processes; i.e., it is
possible to debug an `April' application using tools which do not
execute on the same machine as the `April' application itself.
Furthermore, a single debugging session can monitor several `April'
applications simultaneously.

   When an `April' application is being debugged, it can be executed in
`debug mode' - using the `-g' switch on the `april' command line (*note
How to invoke April::). Providing that the program has been
appropriately compiled (i.e., also with the `-g' flag - *note Compiling
April programs::); then, as the program runs, messages are sent from
the `April' application being monitored to the debugger process.

   An `April' debugger is a separate program that operates as a kind of
`debugging server'; receiving messages from the debugged program
whenever a notable event (such as assigning a variable or entering a
program) occurs. `April' encodes its messages as `XML' structures that
are defined in this chapter. Note that an `April' application that is
being monitered executes much more slowly that normal. This may impact
the behaviour of the `April' application where real-time events are
concerned.

   The `April' engine also has a very simple debugger built-in; which
can be useful for certain situations where setting up an external
debugger process is inconvenient.

* Menu:

* Connecting to an external debugger::
* The standard April debugger::  Simple text-based debugger.
* Debugging messages::          Standard messages generated for debugging purposes.


File: april.info,  Node: Connecting to an external debugger,  Next: The standard April debugger,  Up: Debugging April programs

18.1 Connecting to an external debugger
=======================================

To debug an `April' application using an external debugger it is
necessary to specify the target server on the `April' command line:
     % april -g _host:port_ APRILPROGRAM ...
   If the _port_ is not specified then 9999 is assumed. For example, to
connect to a debugger running on the same computer that is listening on
port 9999, use:
     % april -g localhost APRILPROGRAM ...

   If the `-g' command-line option is given, then the `April' engine
attempts to connect to the indicated server on startup. If that is
successful, then whenever a monitored program wishes to report a
debugging event it sends a message - in the XML format described below
- to the server.


File: april.info,  Node: The standard April debugger,  Next: Debugging messages,  Prev: Connecting to an external debugger,  Up: Debugging April programs

18.2 The standard `April' debugger
==================================

`April' includes, as a standard program, a simple line-based debugger
program. This program is invoked using the Unix command:

     % apdebugger NAME

   NAME will become the public name, registered with the local name
server, for this invocation of the debugger process. Different users can
have there own invocations of the debugger running providing each has a
different public NAME.  The debugger will run in a separate `April'
invocation and it is usual to run this either in a different window or
on a different machine from the program you want to debug. To initiate
a monitored execution, the program to be debugged must have been
compiled with the `-g' option, and the `April' invocation to run it
must also have the `-g' NAME option:

     % apdebugger 9999
     % april -g localhost world3

   In the debugger's window, _not in the `April' application's window_,
output similar to the following will be displayed:

     April debugging server - 0:fgmdebug@laotzu.doc.ic.ac.uk
     Switch to 0:laotzu#24226@laotzudoc.ic.ac.uk
     fork 0:laotzu#24226@laotzudoc.ic.ac.uk
     fork 0:laotzu#24226@laotzudoc.ic.ac.uk
     @ /home/fgm/.../world3.ap:5

The last line of this in an indicator that the program has paused at
line 5 in the source file `world3.ap'. The debugger is waiting for a
response, which is normally simply a carriage return - to continue
stepping execution:


     @ /home/fgm/.../hello.ap:2

     Entering procedure/function hello
     hello = "Hello world"
     @ /home/fgm/.../hello.ap:2

     Return from procedure/function hello
     @ /home/fgm/.../world3.ap:6

     Return from procedure/function main

Typing a `q' in response to a `line' prompt will cause the process
being monitored to terminate.

   Even though the application has terminated, the debugger itself will
not stop. In fact it does not know that the application has finished at
this point - although we could have a good guess since it is the `main'
procedure which has just exited.

   The debugger will continue executing indefinitely as it will handle
debugging messages from all `April' applications in the same logical
network that are invoked using the `-g fgmdebug' option.

   In order to debug `remotely', all that is necessary is to use the
full name of the debugger when invoking `April'. For example, in order
to debug the `world3' program, when it is executing in the `April'
domain `ee.qmw.ac.uk', using the `fgmdebug' debugger which is executing
in the domain `doc.ic.ac.uk', then use:

     % april -g fgmdebug@doc.ic.ac.uk world3

when invoking `April'.


File: april.info,  Node: Debugging messages,  Prev: The standard April debugger,  Up: Debugging April programs

18.3 Debugging messages
=======================

Each of the major `events' that can occur in an `April' program are
logged by sending a particular message to the debugger process. For
example, each time the program moves to a different line of the source
file, or assigns a variable, a message is sent to the debugger.

   In most cases, no response is expected from the debugger, however, in
the case of the `line' message, the monitored application will pause
waiting for a response from the debugger. This allows a programmer to
`single step' through the execution of a program or to set break points
as needed.

* Menu:

* Standard debugging message type::
* line_debug message::          On arrival at a line of source
* entry_debug message::         On entry to a procedure or function
* exit_debug message::          On exit from     a procedure or function
* return_debug message::        Return value from a function
* assign_debug message::        Assign a variable
* scope_debug message::         Change variable scope
* fork_debug message::          Fork a sub-process
* die_debug message::           Process terminates
* send_debug message::          Send a message
* front_debug message::         Post a message in the message queue
* accept_debug message::        Accept a message
* suspend_debug::               Process suspended message
* error message::               Error message
* break_debug message::


File: april.info,  Node: Standard debugging message type,  Next: line_debug message,  Up: Debugging messages

18.3.1 Standard debugging message type
--------------------------------------

The `debug_msg' is a standard type that encapsulates the debugging
messages that may occur in the system. Its definition is:

     debugMsgType ::= line_debug(handle,string,number) |
             entry_debug(handle,string) |
             scope_debug(handle,number) |
             exit_debug(handle,string) |
             return_debug(handle,string,string) |
             fork_debug(handle,handle) |
             suspend_debug(handle) |
             die_debug(handle) |
             send_debug(handle,handle,string) |
             front_debug(handle,handle,string) |
             accept_debug(handle,handle,string) |
             assign_debug(handle,string,string) |
             error_debug(handle,error) |
             break_debug(handle,string);

In order to access this type it is necessary to `#include' the file
`debug.ah' in the source of the program:

     #include <debug.ah>;


File: april.info,  Node: line_debug message,  Next: entry_debug message,  Prev: Standard debugging message type,  Up: Debugging messages

18.3.2 The `line_debug' message
-------------------------------

Message template:
     line_debug(handle?PR,string?FILE,number?LINE)

This message is sent each time the program moves to a new source line in
the text of the program. PR is the `handle' of the process which is now
at the new line of the source FILE, and LINE is a number indicating
which line the program is at.

   When a `line_debug' message is sent by an `April' program, the
process involved suspends waiting for a reply from the debugger. Other
processes - including those in the same `April' invokation - continue
executing as normal.

   The response from the debugger should be one of:

`'ok'
     the monitored process will continue executing.

`'q'
     the monitored process is terminated.

`'cont'
     suppresses further debugging messages


File: april.info,  Node: entry_debug message,  Next: exit_debug message,  Prev: line_debug message,  Up: Debugging messages

18.3.3 The `entry_debug' message
--------------------------------

Message template:
     entry_debug(handle?PR,string?PROG)

This message is sent whenever a procedure or function is entered. PR is
the handle of the process entering the procedure, and PROG is the name
of the procedure or function.

   `April' makes no distinction between procedures and functions in
this message - since when a procedure and function are entered a `line'
message is also sent, the programmer should be able to distinguish this
by looking at the source file.


File: april.info,  Node: exit_debug message,  Next: return_debug message,  Prev: entry_debug message,  Up: Debugging messages

18.3.4 The `exit_debug' message
-------------------------------

Message template:
     exit_debug(handle?PR,string?PROG)

is sent whenever a procedure or function is about to return. PR is the
handle of the process entering the procedure, and PROG is the name of
the procedure or function.


File: april.info,  Node: return_debug message,  Next: assign_debug message,  Prev: exit_debug message,  Up: Debugging messages

18.3.5 The `return_debug' message
---------------------------------

Message template:
     return_debug(handle?PR,string?PROG,string?VALUE)

The `return_debug' message is sent when a function is returning, and it
gives the value that is being returned by the function.  Note that a
function written with an unnamed equation generates a `return' message
with `prog=lambda'.

   The value returned by the function is displayed in the VALUE string
as though it were computed by an expression of the form: `EXP^0'.
However, if there is a function defined in the current scope called
`__debug_display__' of type:
     any=>string
   then this function will be called to `display' the returned value
instead.(1).

   ---------- Footnotes ----------

   (1) This is an experimental feature, introduced in version 4.4.0-pre3


File: april.info,  Node: assign_debug message,  Next: scope_debug message,  Prev: return_debug message,  Up: Debugging messages

18.3.6 The `assign_debug' message
---------------------------------

Message template:
     assign_debug(handle?PR,string?VAR,string?VALUE)

This message is sent whenever a variable is assigned a value. This
includes the case of entering a procedure or function - for each of the
parameters of the procedure an `assign_debug' message is sent. This
way, it is possible to find out the values of parameters to procedures
as well as the results of assignment.

   The value assigned to the variable is displayed in the VALUE string
as though it were computed by an expression of the form: `EXP^0'.
However, if there is a function defined in the current scope called
`__debug_display__' of type:
     any=>string
   then this function will be called to `display' the assigned value
instead. This is a convenient method for customizing the debugger.


File: april.info,  Node: scope_debug message,  Next: fork_debug message,  Prev: assign_debug message,  Up: Debugging messages

18.3.7 The `scope_debug' message
--------------------------------

Message template:
     scope_debug(handle?PR,number?LEVEL)

A typical `April' program has many variables in it, often in different
scopes.  The `scope_debug' message allows a debugger to determine the
current scope that the program is in.

   The scope LEVEL is typically a small positive integer. The LEVEL
value is always relative to a given function or procedure. Higher
numbers refer to `deeper' scope levels, and the initial scope level on
entry to a procedure or function is always zero.

   The debugger can interpret a `scope_debug' message as either that
the program has entered a new scope level, or that it is returning to a
previous scope level - depending on whether the previous scope level
was higher or lower.

   A debugger can use this information to determine which of the
process'es variables - as determined by `assign_debug' messages *note
assign_debug message:: - are currently in active scope.


File: april.info,  Node: fork_debug message,  Next: die_debug message,  Prev: scope_debug message,  Up: Debugging messages

18.3.8 The `fork_debug' message
-------------------------------

Message template:
     fork_debug(handle?PARENT,handle?CHILD)

This message is sent when a process forks.  The CHILD `handle' is the
handle of the new process, and PARENT is the handle of the process
which created this process.


File: april.info,  Node: die_debug message,  Next: send_debug message,  Prev: fork_debug message,  Up: Debugging messages

18.3.9 The `die_debug' message
------------------------------

Message template:
     die_debug(handle?PR)

is sent when a process terminates.


File: april.info,  Node: send_debug message,  Next: front_debug message,  Prev: die_debug message,  Up: Debugging messages

18.3.10 The `send_debug' message
--------------------------------

Message template:
     send_debug(handle?SNDR,handle?TO,string?MSG)

This message is sent when one process sends a message to another.  This
message records the act of sending a message; it does not imply that the
message was received properly.

   The message sent is displayed in the VALUE string as though it were
computed by an expression of the form: `MSG^0'. However, if there is a
function defined in the current scope called `__debug_display__' of
type:
     any=>string
   then this function will be called to `display' the message.  instead.


File: april.info,  Node: front_debug message,  Next: accept_debug message,  Prev: send_debug message,  Up: Debugging messages

18.3.11 The `front_debug' message
---------------------------------

Message template:
     front_debug(handle?SNDR,handle?TO,string?MSG)

This message is sent when a process sends a message to itself using the
`self posting mechanism. Such a message is always put at the front of
the process'es message queue.

   The message is displayed in the VALUE string as though it were
computed by an expression of the form: `MSG^0'. However, if there is a
function defined in the current scope called `__debug_display__' of
type:
     any=>string
   then this function will be called to `display' the message instead.


File: april.info,  Node: accept_debug message,  Next: suspend_debug,  Prev: front_debug message,  Up: Debugging messages

18.3.12 The `accept_debug' message
----------------------------------

Message template:
     accept_debug(handle?SNDR,handle?TO,string?MSG)

This message is sent when a receiving process `accepts' a message from
its message queue. It is only when both the `send_debug' message and
the `accept_debug' message are recorded that the message can be said to
have been communicated between the processes.

   Note that this message does not record the value of the `replyto'
keyword separately from the identity of the sender of the message.

   The accepted message is displayed in the MSG string as though it
were computed by an expression of the form: `MSG^0'. However, if there
is a function defined in the current scope called `__debug_display__'
of type:
     any=>string
   then this function will be called to `display' the message instead.


File: april.info,  Node: suspend_debug,  Next: error message,  Prev: accept_debug message,  Up: Debugging messages

18.3.13 The `suspend_debug' message
-----------------------------------

Message template:
     suspend_debug(handle?PR)

The `suspend_debug' message is sent to the debugger whenever the
debugged process has to suspend because it is waiting for a message to
arrive.


File: april.info,  Node: error message,  Next: break_debug message,  Prev: suspend_debug,  Up: Debugging messages

18.3.14 The `error_debug' message
---------------------------------

Message template:
     error_debug(handle?PR,error?ERR)

is sent when a run-time error is reported in a process, and the process
does _not_ have an error recovery code section in force at the time.
Generally, ERR will be of the form

     error(string?MESSAGE,symbol?CODE)

I.e., it is an `error' value (*note error type::).  The MESSAGE is a
string which describes the error, and DATA is some value which is
involved in the error condition.

   If an `error' message has been sent, the erroneous process has also
been terminated by the `April' run-time system.


File: april.info,  Node: break_debug message,  Prev: error message,  Up: Debugging messages

18.3.15 The `break_debug' message
---------------------------------

Message template:
     break_debug(handle?PR,string?MSG)

is sent whenever the built-in statement `_break(MSG)' is executed.


File: april.info,  Node: April syntax,  Next: Extending the April system,  Prev: Debugging April programs,  Up: Top

19 `April' syntax
*****************

`April''s syntax is based on an _operator precedence grammar_. Although
they might not be aware of it, most programmers are quite familiar with
operator precedence grammars - it is typically the grammar used for
arithmetic expressions. In `April' - as in Prolog - we extend the use
of operator-style grammars to cover the whole language.

   An operator grammar allows us to write expressions like:

     X * Y + X / Y

and to know that this means the equivalent of:

     (X * Y) + (X / Y)

or more specifically:

     +(*(X, Y), /(X, Y))

I.e., an operator grammar allows us to write operators between arguments
instead of before them, and an operator precedence grammar allows us to
avoid using parentheses in many common situations.

   It is not necessary to restrict the scope of an operator grammar to
arithmetic expressions - a fact used by the early originators of the
POP-2 and Prolog programming languages. We can also use an operator
grammar for the whole of a programming language. For example, in
`April', the assignment statement is written:

     VARIABLE := EXPRESSION

this can be interpreted - by treating `:=' as an operator - as:

     :=(VARIABLE,EXPRESSION)

A somewhat more complicated example allows us to interpret a conditional
statement in terms of operators:

     if A<B then
       X := A+B
     else
       X := X-B

which, in fully parenthesised form is:

     else(
       then(
         if(<(A,B)),
         :=(X, +(A,B))),
       :=(X, -(A,B)))

Here, we have assumed that `else', `then' and `:=' are _infix_
operators - in addition to the `normal' infix operators: `+' and `-' -
and `if' is a prefix unary operator.

   The major benefit of this sleight of hand is extensibility - it is
much easier to add new operators to a grammar than it is to add new
syntactic forms. It should also be noted that there are disadvantages.
The most important is probably that it is difficult for the compiler to
generate meaningful errors when an incorrect program is parsed. If you
are new to `April', you may take this as an apology in advance!

* Menu:

* Defining an operator grammar::
* April grammar rules::
* Defining a new operator::


File: april.info,  Node: Defining an operator grammar,  Next: April grammar rules,  Up: April syntax

19.1 Defining an operator grammar
=================================

An operator grammar can often be written down in a few simple rules. A
grammar that allows us to parse simple arithmetic expressions might be:

     EXP ==> ADD-EXP

     ADD-EXP ==> MUL-EXP + MUL-EXP
       | MUL-EXP - MUL-EXP
       | - MUL-EXP
       | MUL-EXP

     MUL-EXP ==> PRIM-EXP * PRIM-EXP
       | PRIM-EXP / PRIM-EXP
       | PRIM-EXP

     PRIM-EXP ==> IDENTIFIER
       | ( EXP )

While a grammar such as this allows us to handle the specific arithmetic
operators, it does not allow extensible grammars. To do that we must use
the concept of _precedences_ or _priorities_. In an operator precedence
grammar each operator has a numerical _priority_ which expresses its
`dominance' over other operators. The higher a priority the more
dominant it is and the higher in the resulting parse tree the operator
will appear.  

   Using priorities, an operator precedence grammar rule for general
infix operators can be written:

     "exp(priority)" ==> "exp(left)" "op(L,priority,R)" "exp(right)"
             providing that "left"<="L" and "right"<="R"

I.e., an expression involving an infix operator - "op" - has a priority
of "priority" providing that the left hand part has a priority of
"left" and the right hand part has a priority of "right" and that the
`expected' left-hand priority of "op" is at least equal to "left" and
the `expected' right-hand priority of "op" is at least equal to `right'.

   This complex re-statement of the infix rule allows us to replace the
specific grammar rules for "add-exp" and "mul-exp" with one rule and a
table of operators and their priorities:

     +  => 1, 2, 1
     -  => 1, 2, 1
     *  => 0, 1, 0
     /  => 0, 1, 0

together with the assumption that non-operators are given a priority of
0.

   To extend the grammar with a new operator combination we add an
entry to this table. Furthermore, by varying the pattern of numbers in
each entry we can express left-associative operators, right-associative
operators and non-associative operators:

     -  => 2, 2, 1                   /* - is left associative */
     <> => 9,10,10                   /* <> is right associative */

Associative operators allow us to disambiguate expressions such as:

     A - B - C

to be equivalent to:

     (A - B) - C

for left associative `-'.

   By convention, `April''s priorities range from 0 for `primitive
values' to 2000 for the highest operators. We divide this range into
two: from 0 to 1000 for `expression level' operators, and 1001 to 2000
for `statement level' operators. This allows ample `room' for system
defined operators as well as operators introduced for language
extension.


File: april.info,  Node: April grammar rules,  Next: Defining a new operator,  Prev: Defining an operator grammar,  Up: April syntax

19.2 `April' grammar rules
==========================

The complete grammar rules for `April' are listed in *Note April
grammar::. Here we highlight the important features.

* Menu:

* Primitive syntax expressions::
* Infix expressions::
* Prefix expressions::
* Postfix expressions::


File: april.info,  Node: Primitive syntax expressions,  Next: Infix expressions,  Up: April grammar rules

19.2.1 Primitive syntax expressions
-----------------------------------

A `term0 expression represents the base of the grammar. All term0
expressions have 0 priority. There are several forms of term0 syntactic
expression:

     "term0"  ==>  "ident"
       |  "number"
       |  "string"                      -- A single string or a string sequence
       |  ( )                        -- Empty tuple
       |  [ ]                        -- Empty list
       |  { }                        -- Empty statement

       |  [ "list_els" ]                  -- Non-empty list
       |  { "term(2000)" }              -- Override operator precedences
       |  ( "term(2000)" )              -- Override operator precedences
       |  ' "ident"                     -- Escape operator and other interpretations
       |  "term0" "term0"                -- Function application

     "list_els" ==> "term(999)"
       | "term(999)" , "list_els"
       | "term(999)" ,.. "term(999)"

* Menu:

* comments::
* identifier syntax::
* number syntax::
* string syntax::
* list syntax::
* tuple syntax::
* functional expression syntax::
* parenthetical expression syntax::
* quoted symbol::


File: april.info,  Node: comments,  Next: identifier syntax,  Up: Primitive syntax expressions

19.2.1.1 Comments in programs
.............................

There are two styles of comments in `April': line comments and
continuous comments.

   A line comment is introduced by a `--' combination, followed by a
white-space character, and terminated by a new-line or the end-of-file.

   A continuous comment is introduced by the `/*' and terminated either
by the end of file or the `*/' characters. Note that a line comment
overrides any `/*' comment introduction, and conversely, if a
continuous comment is in force then any line comments are ignored.

   For example:

     /* -- */ this is not inside a comment
     -- /* This is inside a comment
     but this is not */


File: april.info,  Node: identifier syntax,  Next: number syntax,  Prev: comments,  Up: Primitive syntax expressions

19.2.1.2 Identifier syntax
..........................

An identifier or symbol has priority 0 if it is not defined to be an
operator. There are two forms of symbol - symbols written using
alphanumeric characters and symbols written using graphical characters.

   An alphanumeric symbol consists of a letter - an ASCII character in
the set `a-zA-Z' or `_' - followed by zero or more letters and digits.

   A graphic symbol consists of one or more characters from the set:

     ! @ # $ % ^ & * - = + : ~ < > . / ? \ | `

whichever form of symbol is written, semantically alphanumeric symbols
and graphical symbols are identical.

   Normally, if a symbol has no operator definition associated with it,
then its priority when it appears in expressions is zero. With a few
exceptions, if a symbol has an operator declaration associated with it,
it is not permitted to appear alone unless enclosed in `()''s.

   A special case of identifier is the type variable identifier. This
is written as a leading `%' followed by a regular identifier:

     % "ident"

Type variable identifiers are mostly used in type definition statements
but may appear wherever a type expression is allowed.


File: april.info,  Node: number syntax,  Next: string syntax,  Prev: identifier syntax,  Up: Primitive syntax expressions

19.2.1.3 Number syntax
......................

Numbers are either integral or floating point. Integers can be written
in the usual decimal notation - one or more digits - or in hexadecimal
or octal notation.

   An octal integer is written with a leading 0 character:

     01 023 0100

whereas a hexadecimal number is written as a sequence of hex digits
prefixed by `0x':

     0x0 0x13 0x10abcdef

Floating point numbers are written with a `.' and optional exponent
value:

     1.04 1.34e-10

Note that, in `April', numbers are not semantically distinguished
between floating point values and integers; i.e., 1.0 == 1. Whenever a
number is specified then either an integer or floating point value may
be given, except that certain built-in functions require integral
values - for example it make no sense to ask for the 1.5th element of a
list.


File: april.info,  Node: string syntax,  Next: list syntax,  Prev: number syntax,  Up: Primitive syntax expressions

19.2.1.4 String syntax
......................

A string is written as a sequence of characters enclosed in ``"''
characters:

     ""string-chars""

Valid string characters are either literal printable characters or
special characters. Special characters are introduced using a C-style
escaping convention - using a leading `\' character. The following
table defines the special string characters:

``\a''
     Alarm bell.

``\b''
     Backspace character.

``\d''
     Delete character.

``\e''
     Escape character.

``\f''
     Form feed character.

``\n''
     New line character (_as a character within the string_).

``\r''
     Carriage return character.

``\t''
     Tab character.

``\v''
     Vertical tab character.

``\'new-line'
     A backslash followed by a new-line is ignored - it is not part of
     the quoted string.  Note that this is the only way that an
     individual quoted string is permitted to cross a line boundary,
     however see below for an alternate method.

``\'0,1,2,3,4,5,6,7'
     A backslash followed by 1, 2 or 3 octal characters introduces a
     literal ASCII character whose code is obtained from the octal code.

     A common use for this it to introduce the NULL character into a
     string, for example:

          "\0"

     The ability of `April' strings to contain any ASCII character
     allows `April' programs to manipulate binary data as well as
     regular text.

``\?''
     A `\' character in front of any other character, including the
     backslash character itself and the quote characters, introduces the
     character itself. I.e., `\\' is used to introduce the backslash
     character and `\"' is used to introduce the `"' into a string.

   `April' supports a C-style string concatenation notation: two or more
strings which are consecutive tokens in a program are treated as a
single string - which is formed by the concatenation of the component
strings. For example, the sequence:

     "foo" "bar" "gum"

is interpreted as the string

     "foobargum"

The key point here is that `"foo"', `"bar"' and `"gum"' above may have
new-lines, comments or other white space - but no other characters or
tokens - between them.


File: april.info,  Node: list syntax,  Next: tuple syntax,  Prev: string syntax,  Up: Primitive syntax expressions

19.2.1.5 List syntax
....................

The syntax for lists can be defined using the rules:

     "list" ==> []
       | ["list-elements"]

     "list-elements" ==> "exp(1000)"
       | "exp(1000)" , "list-elements"
       | "exp(1000)" ,.. "exp(1000)"

Note that the expected priority of elements of the list is 1000 - which
reflects the fact that elements of lists are expected to be expressions
rather than statements - *note Operator priorities::.


File: april.info,  Node: tuple syntax,  Next: functional expression syntax,  Prev: list syntax,  Up: Primitive syntax expressions

19.2.1.6 Tuple syntax
.....................

The syntax for tuples can be defined using the rules:

     "tuple" ==> ()
       | ( "tuple-elements" )

     "tuple-elements" ==> "exp(1000)" , "exp(1000)"
       | "exp(1000)" , "tuple-elements"

Like list elements, tuple elements have an expected priority of 1000 -
which reflects the situation that most tuples relate to values rather
than statements - *note Operator priorities::.

   Note that `April' does not admit a tuple of length 1: an expression
of the form `(E)' is simply the same as `E'. The tuple comma operator
can best be considered as a `cross-product' operator.


File: april.info,  Node: functional expression syntax,  Next: parenthetical expression syntax,  Prev: tuple syntax,  Up: Primitive syntax expressions

19.2.1.7 Syntax of functional expressions
.........................................

A functional expression is written using the rule:

     "functional-exp" ==> "primitive" "tuple"

Note that this means that the function name of a functional expression
may be quite complex:

     foo(10,"bar")(three,more)(arguments)


File: april.info,  Node: parenthetical expression syntax,  Next: quoted symbol,  Prev: functional expression syntax,  Up: Primitive syntax expressions

19.2.1.8 Parenthetical expressions
..................................

There are occasions where the built-in priorities of operators does not
directly allow the desired form of expression. For example in:

     X + Y * Z

the `+' operator is `less tight' than the `*' operator and so this
expression means `multiply `Y' by `Z' and add to `X''. If the desired
intention was different, then we use operator overriding parentheses:

     (X + Y) * Z

which means `add `X' to `Y' and multiply the result by `Z''.

   Notice that `April' has two styles of parenthetical forms; in
addition to the classical `()' characters, `April' also uses `{}''s to
override operator priorities.  We generally use braces when the
operators involved are at a statement-level rather than at an
expression level; however this is simply a convention and is not
enforced by the parser.

   The rule for a parenthetical expression is:

     "parenthetical expression" ==> { "term(2000)" }
       | ( "term(2000)" )

I.e., any operator combination - up to a priority of 2000 - is
permitted as a primitive expression when enclosed by `()''s.


File: april.info,  Node: quoted symbol,  Prev: parenthetical expression syntax,  Up: Primitive syntax expressions

19.2.1.9 Quoted symbol
......................

Quoted symbols are used to denote literals of type `symbol'. Quoting a
symbol also has the effect of overriding any variable interpretation
for the identifier.  The syntax rule for a quoted symbol is:

     "quoted symbol" ==> ' "ident"

where "ident" is either a graphic symbol or an alphanumeric symbol.
Quoted symbols can be used to override the normal operator
interpretation of a symbol, and they also override any `semantic'
attachment there may be. For example, the expression

     ' *

means the `*'  symbol, not the `*' operator and not the `*' binary
arithmetic function.


File: april.info,  Node: Infix expressions,  Next: Prefix expressions,  Prev: Primitive syntax expressions,  Up: April grammar rules

19.2.2 Infix expressions
------------------------

An _infix_ operator is one which is written between two arguments.
`April' has a number of standard infix operators, which are listed in
*Note Standard operators::.

   The grammar rule for infix operators is:

     "infix-exp(P)" ==> "exp(l)" "infix(op,L,P,R)" "exp(r)" { "l" <= "L" & "r" <= "R" }

where there is a table of operators of the form:

     ...
     infix(:=,1899,1900,1900)
     infix(*,700,700,699)
     ...

and so on. The left/right/non-associativity is encoded in the values for
"L", "P" and "R" stored with the operator - see *Note Defining a new
operator::. For a left-associative operator, "L"="P" and "R"="P-1"; for
a non-associative operator, both "L"="P-1" and "R"="P-1".

   Whenever an expression is written in infix form it has an equivalent
functional form - the functional form is the `true' underlying form of
the expression. The functional form of an infix expression:

     "left" "op" "right"

is:

     "op"("left","right")

However, once a symbol is declared as an operator, the `April' parser
does not permit it to be used other than as an operator - unless it is
quoted:

     '"op"("left","right")


File: april.info,  Node: Prefix expressions,  Next: Postfix expressions,  Prev: Infix expressions,  Up: April grammar rules

19.2.3 Prefix expressions
-------------------------

An _prefix_ operator is one which is before its argument. A prefix
expression differs from a functional expression in that it is not
necessary to enclose the argument in parentheses. `April' has a number
of standard prefix operators, which are listed in *Note Standard
operators::.

   The grammar rule for prefix operators is:

     "prefix-exp(P)" ==> "prefix(op,P,R)" "exp(r)" { "r" <= "R" }

where there is a table of operators of the form:

     ...
     prefix(while,1250,1249)
     prefix(-,300,300)
     ...

and so on. A prefix operator is either associative or not. An
associative prefix operator - such as `-' - permits expressions such as:

     - - - X

whereas a non-associative prefix operator - such as `while' - does not.


File: april.info,  Node: Postfix expressions,  Prev: Prefix expressions,  Up: April grammar rules

19.2.4 Postfix expressions
--------------------------

An _postfix_ operator is one which is after its argument. A postfix
expression differs from a functional expression in that it is not
necessary to enclose the argument in parentheses. `April' has a number
of standard postfix operators, which are listed in *Note Standard
operators::.

   The grammar rule for postfix operators is:

     "postfix-exp(P)" ==> "exp(l)" "postfix(op,L,P)" { "l" <= "L" }

where there is a table of operators of the form:

     ...
     postfix(*,699,700)
     postfix(secs,599,600)
     ...

and so on. A postfix operator is either associative or not. An
associative postfix operator would permit expressions such as:

     X "op" "op" "op"

whereas an non-associative prefix operator does not. There are not very
many standard postfix operators in `April' and no associative postfix
operators.


File: april.info,  Node: Defining a new operator,  Prev: April grammar rules,  Up: April syntax

19.3 Defining a new operator
============================

A new operator is defined by including a `#op' statement in the source
of the program. The format of an operator declaration is:

     #op('"operator", "style", "priority");

where "operator" is the operator being declared, "style" describes
`type' of the operator and `priority' is the operator's priority.

   For example, the standard `*' operator has an operator declaration
that looks like:

     #op('*,left,700);		-- Multiplication

   We prefix the operator symbol with a quote to ensure that any prior
operator declarations do not cause the `#op' statement itself to be
mis-read.

   An operator declaration such as this is equivalent to the operator
`triple' form:

     infix('*,700,700,699)

I.e., when an operator is declared as a left associative infix operator,
we are in effect stating that the expected priority of expressions on
the left of the operator is the same as the priority of the operator
itself. On the other hand, the expected priority of expressions on the
right is 1 less than the priority of the operator itself. This means
that we can allow the left argument of the operator to be another
expression involving the same operator, but we do not allow it on the
right.

   Operator declarations are only permitted at the `top-level' in a
program source file.

   The style of the operator is denoted using one of the following
symbols:

`prefix'
     A prefix non-associative operator

`aprefix'
     A prefix associative operator

`infix'
     An infix non-associative operator

`left'
     An infix left associative operator

`right'
     An infix right associative operator

`postfix'
     A postfix non-associative operator

`apostfix'
     A postfix associative operator

   It is permissable to mix operator declarations - the same symbol can
be declared to be infix, prefix and/or postfix in any combination;
although only one declaration is permitted for each `form'. The
priorities of the different forms need not be related - for example it
is possible to have a symbol declared as an infix operator of priority
1000 and at the same time a prefix operator of priority 1200 and a
postfix operator of priority 750.

* Menu:

* Operator priorities::
* How operator declarations are interpreted::
* Disambiguating infix and postfix::


File: april.info,  Node: Operator priorities,  Next: How operator declarations are interpreted,  Up: Defining a new operator

19.3.1 Operator priorities
--------------------------

`April' has some conventions for the appropriate values to use for the
priorities of operators - depending on the eventual intended use for
the operator:

0-1000
     Operators declared in the range 0-1000 are `expression level'
     priorities. Expressions involving such operators are likely to be
     values of variables, and involved in other value expressions. For
     example, the priority for the `+' operator is 720, and the
     priority for `*' is 700.

1001-2000
     Operators declared in the range 1001-2000 are `statement level'
     priorities. Expressions involving such operators are likely to
     represent statements rather than value expressions. For example,
     the priority of the `;' operator is 1900 and the priority of the
     `:=' operator is 1100.

   A complete list of the standard operators is listed in *Note
Standard operators::.


File: april.info,  Node: How operator declarations are interpreted,  Next: Disambiguating infix and postfix,  Prev: Operator priorities,  Up: Defining a new operator

19.3.2 How operator declarations are interpreted
------------------------------------------------

An operator declaration must be mapped into the internal form where the
expected priorities on the left and right are explicitly represented.
How this is done depends on the form of the operator as given in the
`#op' declaration.

   If the operator declaration is of the form:

     #op('OP,left,1000);

this means that OP is being declared as a left associative operator,
and the computed priorities become 1000, 1000 and 999 for the left
priority, operator priority and right priority respectively. If the
operator is a right associative operator, with declaration form:

     #op('OP,right,1000);

then the computed priorities become 999, 1000 and 1000 respectively, and
the operator is right associative.

   Where the left (or right) priority of an operator is smaller than the
operator's own priority it means that the operator itself would _not_
be permitted on the left (or right); i.e., that the sequence:

     X OP Y OP Z

must be interpreted as:

     X OP {Y OP Z}

for a right associative operator, or

     {X OP Y} OP Z

in the case of a left associative operator.


File: april.info,  Node: Disambiguating infix and postfix,  Prev: How operator declarations are interpreted,  Up: Defining a new operator

19.3.3 Disambiguating infix and postfix
---------------------------------------

There are situations where there can be several operators occurring
together.  Sometimes this can lead to an ambiguous situation
particularly when combining infix and postfix operators.

   For example, in the sequence:

     X op1 op2 Y

there are two potential `readings' for this:

     op1(X,op2(Y))
     op2(op1(X),Y)

or, in the more extreme case, we might have:

     X op1 op2 op3 Y

which has as potential readings:

     op1(X,op2(op3(Y)))
     op2(op1(X),op3(Y))
     op3(op2(op1(X)),Y)

In the case where the operators only have a single interpretation - as
infix, prefix or postfix - there generally is no problem in deciding
which interpretation to pick. However `April' allows operators to have
multiple forms - prefix, infix and postfix - simultaneously.

   In order to disambiguate such combinations of operators, `April'
uses two strategies: first if the operators have different priorities
then it may be possible to disambiguate the sequence. For example, if
OP2 as an infix or postfix operator dominates OP1 as a postfix or infix
operator then the first combination above is not possible.

   In the final case, where an operator has both an infix and a postfix
interpretation, and priorities cannot be used to disambiguate, the
`April' parser chooses the infix interpretation over the postfix.
Notice that this may lead to the parser reporting a parse error when a
different interpretation might not.  In general operator disambiguation
requires an arbitrary level lookahead - `April''s parser only supports
a 2-level lookahead -  which can sometimes lead to spurious errors.
However, such ambiguous combinations of operators are comparatively
rare in practice (especially given that postfix operators themselves
are rare).

19.4 Syntax errors
==================

There are two main classes of syntax errors that may be generated by the
`April' compiler: parsing errors and syntax errors. The first kind of
error relates to `April''s operator precedence grammar, and the latter
kind (of which there are many more) relates to the program structure as
parsed by the grammar.

   Operator precedence grammars are extremely flexible and compact; as
can we have seen in *Note April grammar::. Furthermore, by allowing
programmers to add their own operators it is very easy to extend the
surface syntax of `April'.

   Unfortunately, this simplicity comes at a price: it is extremely
difficult for a compiler to generate meaningful syntax errors when
something is wrong in the input. The `April' compiler will report
simple errors such as brackets being inappropriately placed, or a
missing close quote character; but it cannot give a meaningful _reason_
for the syntax error. More normally, it will report something like:

     Parse error - ';' expected - at line 27/...Samples/fact.ap near:
     }execte main;
       ^ - here

when a more meaningful message might have been:
     Parse error - misspelt keyword - at line 27/...Samples/fact.ap near:
     }execte main;
       ^ - here

   However, this is not possible due to the nature of operator
precedence grammars. Operator precedence grammars are usually used for
describing arithmetic expressions where this limitation is not very
important.

   The second main class of error are the _Syntax errors_. These relate
to the expected legal programs that the compiler may process. These
errors are generally more meaningful and attempt to give some idea of
what is expected as well as what went wrong:

     Syntax error: variable S not compatible with handle
      18/18 in ...semaphore.ap

In this case, the (deliberate) error was caused by a type error. The
program fragment in which this occurred was:

     p(number?S){
       'p >> S;            -- _problem in this line_
       receive
         'sync ->> {}
     };

This is a syntax error because we are not allowed to send messages to
`number's.


File: april.info,  Node: Extending the April system,  Next: April grammar,  Prev: April syntax,  Up: Top

20 Extending the `April' system
*******************************

The `April' engine has some support for extension via plug-in modules.
This facility is most useful for interfacing existing libraries to
`April'; however, in principal, any function in a C-callable
programming language can be linked in to `April' using the plug-in
system.

   It should be noted that, except for simple string and number
processing functions, it can be somewhat complex implementing a plug-in
module for `April' - especially if it involves list or tuple
processing. If your intention lies in that direction, you are strongly
advised to look at some of the standard `April' built-in functions'
implementations' source files for guidance.

   While using plug-in modules can allow for convenient extension to
`April' and for convenient access to standard libraries, there are
certain disadvantages to using them. In particular:

   * Due to the severe security risks of executing foreign code, only
     `priviliged' `April' processes may access plug-modules directly.

   * In a distributed application, it is necessary to either arrange
     that all the `April' engines in use have access to the same plug-in
     libraries or the application has to be written in a location
     sensitive fashion.

   * Since the plug-in code shares the same address space as the main
     `April' system, a bug in the plug-in module may cause the `April'
     system itself to compute incorrect results or to crash.

   * The `April' system uses a garbage collection-based memory
     management system. This system requires a string discipline on the
     part of the built-in functions - and by extension the functions
     implemented in the plug-in module. Failing to adhere strictly to
     this discipline can cause problems that are very difficult to
     track down (in particular, since it isnt possible in general to
     predict when the garbage collector is invoked, strongly
     intermittent problems may arise.

   * An alternative approach that is potentially much more stable and
     flexible is to construct a specialized server that uses some form
     of communications protocol, such as one using the Simple
     Communications System. Then, from the point of view of the `April'
     application, the server appears like a regular process that can
     send and receive messages like other `April' programs.

     The disadvantage of this latter approach is some increased
     overhead and the increased complexities of constructing a server
     around a suite of library functions. However, reciprocally, an
     advantage of the server approach is increased flexibility in
     implementation and increased scalability in distributed
     environments.

If we havent managed to dissuade you from building plug-ins for
`April', what follows are intructions for using plug-in modules and
guidelines for building them.

* Menu:

* Using a plug-in module::
* Defining a plug-in module::
* Type signature representation::
* Support functions and macros::


File: april.info,  Node: Using a plug-in module,  Next: Defining a plug-in module,  Up: Extending the April system

20.1 Using a plug-in module
===========================

Using a plug-in module in an `April' source program is quite
straightforward. In order to access a module that has been implemented
as a plug-in, we `import' it in a similar way to regular `April'
modules; except that the module specification is prefixed by the
`native' keyword: 

     program
       import native SPEC from LIB-FILE in
     {
         ...
     } execute INITIAL

If the designer of the plug-in module has a provided an interface file
(to be recommended) then importing plug-in modules is no different to
other modules: 
     program
       import interface INTERFACE-FILE in
     {
         ...
     } execute INITIAL

Once imported in this way the individual functions and procedures that
are defined by the module can be used as any other function or
procedure. Note however, that using plug-in functions is considered a
`privileged' instruction. This means that access to plug-in modules is
not permitted to processes that have been launched in non-privileged
mode - this is likely to apply to programs that have been dynamically
received in messages such as mobilets.


File: april.info,  Node: Defining a plug-in module,  Next: Type signature representation,  Prev: Using a plug-in module,  Up: Extending the April system

20.2 Defining a plug-in module
==============================

In order to build a plug-in module for `April' a number of simple steps
need to be taken:

  1. The set of functions and procedures that constitute the desired
     functionality are implemented.

  2. A special structure - called the signature structure - is
     constructed in the module source.

  3. The library is compiled and _dynamically_ linked - i.e., the
     plug-in is compiled as though it were a regular dynamically linked
     library.

  4. An `April' interface file is designed and constructed.

  5. Of course, we can assume that there are no bugs in the plug-in
     library. However, if there are, they are also liable to crash the
     `April' system itself.

We shall explain the process of constructing a plug-in module by means
of a simple example. Our `list' module duplicates two of the standard
built-in functions: `front' (*note front::) and `listlen' (*note
listlen::).(1) The `listlen' function computes the length of a list and
the `front' function `snips' off the front N elements of a list.

   All `April' functions and procedures share a common C type
definition. The function template for the `listlen' function is:

     retCode d_listlen(processpo p,objPo *args);

The return type - `retCode' - is an enumerated type that is used to
signal the success - or otherwise - of the function or procedure call.
The definition of `retCode' is:

     typedef enum {
       ok,
       Fail,
       Switch,
       IoSuspend,
       MsgSuspend,
       TmrSuspend,
       ResSuspend,
       Error,
       Eof,
       Space
      } retCode;

The most important of these for most programs are `ok' - which means
that the function was successfully executed and a return value has been
computed (or simply successfully executed in the case of a procedure) -
and `Error' - which means that some run-time error condition has
arisen. `Switch' is the same as `ok' - except that the run-time engine
is requested to immediately switch to another process if possible.

   The `processpo' argument is an opaque pointer to the current
process' structure. For most plug-in functions it will never be
necessary to directly refer to this.

   The `objPo*' argument is a pointer to the vector of arguments of the
function or procedure. The `April' compiler arranges the arguments to
the function in a slightly paradoxical way: the first argument to the
the function is found at `args[N-1]' where N is the arity of the
function or procedure; and the last argument is at `args[0]'.

   `April' program values all have a uniform representation; in part to
enable effective garbage collection. There are a number of standard
macros that can be used to determine the run-time type of a structure
addressed via an `objPo' pointer; and to access its value. In addition,
there are standard functions to create new values.

   _Important_

     `April' is primarily a `single assignment' language. It is
     _highly_ undesirable for plug-in functions to `side-effect'
     structures passed in as arguments to the functions. The run-time
     engine does support so-called opaque values however. These may be
     used by the plug-in function to return special pointers or other
     values not directly acessible to `April' programs.

* Menu:

* Protecting pointers::
* Returning values from a plug-in function::
* Reporting errors from a plug-in function::
* The signature structure::

   ---------- Footnotes ----------

   (1) but that doesnt matter since our `list' plug-in module is for
explicatory purposes only.


File: april.info,  Node: Protecting pointers,  Next: Returning values from a plug-in function,  Up: Defining a plug-in module

20.2.1 Protecting pointers
--------------------------

The arguments of the function are `protected' - i.e., the garbage
collector is aware of them. However, other `objPo' values are _not_
protected unless explictly marked. So, a fragment of code such as:

     retCode d_foobar(processpo p,objPo *args)
     {
       objPo tmp = args[2];

       ...

is inherently unsafe. In particular, if `foobar' does any kind of
memory allocation (including constructing numeric values) then, unless
`tmp' is protected, its value is liable to become invalid. In order to
protect the C variable `tmp' above, we can `mark' it with the
`gcAddRoot' function:

     retCode d_foobar(processpo p,objPo *args)
     {
       objPo tmp = args[2];
       void *root = gcAddRoot(&tmp);
       ...

Each `objPo' variable that is required within the function should be
protected by a call to `gcAddRoot'.

   Note that it is only necessary to remember the result of the first
call to `gcAddRoot'. This value is used at the end of the function,
immediately prior to returning to the `April' engine. To release the
protection on all the variables marked with `gcAddRoot' call
`gcRemoveRoot'.(1)

       ...
       gcRemoveRoot(root);
       return ok;         /* return success code */
     }

   ---------- Footnotes ----------

   (1) It is important to properly balance the initial call to
`gcAddRoot' with a call to `gcRemoveRoot'; the run-time system will
complain otherwise.


File: april.info,  Node: Returning values from a plug-in function,  Next: Reporting errors from a plug-in function,  Prev: Protecting pointers,  Up: Defining a plug-in module

20.2.2 Returning values from a plug-in function
-----------------------------------------------

Our first complete example is the `listlen' function. The code for this
is:

     retCode d_listlen(processpo p,objPo *args)
     {
       objPo lst = args[0];
       long len = 0;

       while(NonEmptyList(lst)){
         lst = ListTail(lst);
         len++;
       }
       args[0] = allocateInteger(len);
       return ok;
     }

This program is fairly straightforward. We use the standard macros
`NonEmptyList' for checking for a non-empty list and `ListTail' to
return the tail of the list. The corresponding macros `EmptyList' and
`ListHead' check for an empty list and return the head of a list.  Note
that this function does not need to use the `gcAddRoot' call to protect
the `lst' variable. The reason for this is that no memory allocation
takes place until the last step in the function - the returning of the
result.

   A plug-in function that implements an `April' procedure does not
return a value: it returns a success code only. A plug-in function that
implements an `April' function must return a value to the `April'
engine. This is done by overwriting the first argument slot with the
value. Hence the `listlen' function returns the length of the list by
overwriting `args[0]' with a numeric value.

   All `April' computed values must be constructed using one or more of
the standard `April' constructor functions. The `April' memory
management system uses garbage collection for all values - including
number values.

   The `front' function shows a more elaborate example of list
processing. Its complete code is:

     retCode d_front(processpo p,objPo *args)
     {
       objPo t1 = args[1];
       long len = IntVal(args[0]);
       long pos=0;
       objPo last = args[1] = emptyList;
       objPo elmnt = emptyList;
       void *root = gcAddRoot(&last);

       gcAddRoot(&t1);
       gcAddRoot(&elmnt);

       while(pos++<len && !EmptyList(t1)){
         elmnt = ListHead(t1);
         elmnt = allocatePair(&elmnt,&emptyList);

         if(last==emptyList)
           last = args[1] = elmnt;
         else{
           updateListTail(last,elmnt);
           last = elmnt;
         }
         t1 = ListTail(t1);
       }

       gcRemoveRoot(root);
       return ok;
     }

Note the careful protection of the `t1' and `elmnt' temporary variables
with calls to `gcAddRoot'. In addition, note the method for
constructing and updating list structures.  

   The function `allocatePair' returns a new list pair. The arguments to
`allocatePair' are `objPo*' pointers rather than direct `objPo' values.
Again, this is to facilitate access by the garbage collector.

   In order to update the contents of a list pair, you should use the
standard functions `updateListHead' and `updateListTail'. Using these
functions is required - you should not attempt to update fields of
`April' structures directly.

   The external variable `emptyList' is an `objPo' value that the
`April' engine uses to denote an empty list. The `EmptyList' macro is
simply a test for equality with this variable.


File: april.info,  Node: Reporting errors from a plug-in function,  Next: The signature structure,  Prev: Returning values from a plug-in function,  Up: Defining a plug-in module

20.2.3 Reporting errors from a plug-in function
-----------------------------------------------

Most real-life programs have numerous possibilities for errors - apart
from type checking there are invalid values of arguments, or simply
some requested action failed.

   For most run-time errors, the `April' language allows `April'
programs to recover from errors using the `onerror' mechanism.  The
`April' engine has a standard method for reporting errors that can be
recovered from: the `liberror' function.

   The prototype of the `liberror' function is:

     retCode liberror(char *LIBNAME,int ARITY,char *REASON,objPo CODE);

Normally, `liberror' is used to exit directly out of a plug-in function:

       if(TEST-FAILS)
         return liberror("name",3,"your input is not valid",einval);

LIBNAME should be the name that the programmer uses to invoke the
function, ARITY is the number of arguments, REASON is a `char *'
detailing the reason for the error, and `code' is a symbol that denotes
the formal classification of the error.


File: april.info,  Node: The signature structure,  Prev: Reporting errors from a plug-in function,  Up: Defining a plug-in module

20.2.4 The signature structure
------------------------------

The signature structure is used by `April' to determine the types of
functions and procedures that are loaded as plug-in modules. The
signature structure includes a type signature of the entire module as
well as pointers to the individual plug-in functions. The run-time
engine will verify this structure against the expected type when the
plug-in module is dynamically loaded.

   The `C' type definition of the signature structure is:

     typedef retCode (*funpo)(processpo p,objPo *args);

     typedef struct {
       void *h;                      /* Used by April for internal purposes */
       char *sig;                    /* The actual signature */
       long sigLen;                  /* The length of the signature */
       long modLen;                  /* How many functions are exported? */
       struct {
         funpo fun;                  /* The escape function itself */
         int ar;                     /* Its arity */
       } funs[0];                    /* The array of escape functions being */
     } SignatureRec;

The `sig' component is a `char[]' array that encodes the type signature
of the whole module. Note that this is not necessarily a normal `C'
string. This is because it may contain ASCII NUL values; hence the
separate `sigLen' field which contains the actual length of the type
signature.

   The `modLen' field indicates the total number functions and
procedures that are defined within the plug-in module.

   For each function or procedure that is being defined in the module an
entry in the `funs' array is created. This gives a pointer to the C
function that implements the plug-in function or procedure and the arity
of the function. Note that strictly speaking, the `modLen' and `ar'
fields are redundant - they can be derived from the type signature
itself. However, their presence improves the run-time performance of
plug-in functions.

   The signature structure of a plug-in module should have the standard
C name: `signature'. Generally, this can be defined as a load-time
initialized structure. The signature structure of our `list' module
looks like:

     /* This type signature string defines the type:
        (%x-(%x[]=>number), %x-((%x[],number)=>%x[]))
     */
     #define LIST_SIG "T\2:\0FL$\0N:\0FT\2L$\0NL$\0"

     SignatureRec signature = {
       LIST_SIG,                     /* The type signature of the list module */
       NumberOf(LIST_SIG),
       2,                            /* Two functions in module */
       {
         { d_listlen,1},             /* the listlen function */
         { d_front,2}                /* the front function */
       }
     };

The `NumberOf' macro is a standard `April' macro that computes the
arity of any array.


File: april.info,  Node: Type signature representation,  Next: Support functions and macros,  Prev: Defining a plug-in module,  Up: Extending the April system

20.3 Type signature representation
==================================

The `April' engine uses a string representation for representing types
at run-time. This is used in a number of situations, including
representing the type signature of plug-in modules.  In this section we
detail the form of that representation.

`N'
     The `N' type signature is used to represent the `number' type.
     Note that `April' does not distinguish integer values from
     floating point values - the `N' type represents either.

`s'
     The `s' type signature is used to represent the `symbol' type.

`S'
     The `S' type signature is used to represent the `string' type.

`h'
     The `h' type signature is used to represent the `handle' type.

`l'
     The `l' type signature is used to represent the `logical' type.

`$'
     The `$' type signature is used to represent a type variable. The
     specific type variable is identified by the ASCII value of the
     following byte.

`A'
     The `A' type signature is used to represent the encapsulated `any'
     type.

`O'
     The `O' type signature is used to represent opaque values. Opaque
     values are not allowed in normal `April' programs; however, plug-in
     functions may return opaque values and use them as arguments.

`L'
     The `L' type signature is used to represent a list type. The type
     of the list elements follows the `L' character.

`T'
     The `T' type signature is used to represent a tuple type. The arity
     of the tuple is encoded as the ASCII byte that follows the `T'
     character; the types of the elements of the tuple follow the
     `T<ARITY>' sequence.

`:'
     The `:' type signature represents a universally quantified type.
     The bound type variable follows the `:' character and the type
     itself follows the `:<VAR>' pair. Universally quantified type
     variables are used in polymorphic types.

`F'
     The `F' type signature denotes a function type. The argument
     type(s) of the function follow the `F' character, and the type of
     the result of the function follows the argument types.

`P'
     The `P' type signature denotes a procedure type. The argument
     type(s) of the procedure follow the `F' character.

`u'
     The `u' type signature introduces a user-defined type - in
     particular a non-polymorphic user defined type. The name of the
     type follows the `u' character - delimited by delimiter characters.

     For example, the type signature:

          u'foo#123456'

     denotes the user defined type `foo'. The actual text enclosed in
     the delimited characters often also includes a _hash value_. The
     hash value is used to provide a measure of security: the hash
     value is computed from the actual type definition used to
     introduce the `foo' type.

`U'
     The `U' type denotes a polymorphic user defined type. Similar to
     the non-polymorphic user defined type, its denotation consists of
     the name of the type associated with a hash value. In addition,
     the argument type of the polymorphic type.

`?'
     The `?' type signature denotes a fielded type. Following the `?'
     character is the field name, and following that is the type
     associated with the field name.

     The `?' type signature is used to represent record types.


File: april.info,  Node: Support functions and macros,  Prev: Type signature representation,  Up: Extending the April system

20.4 Support functions and macros
=================================

In this section, we outline a number of the `April' engine's internal
macros and functions that can be used in the support of plug-in
functions.

   Most of these are used for `April''s own functions.

* Menu:

* IsInteger::
* IntVal::
* allocateInteger::
* IsFloat::
* FloatVal::
* allocateFloat::
* IsSymb::
* SymVal::
* newSymbol::
* IsString::
* StrVal::
* StringText::
* StringSize::
* allocateString::
* allocateSubString::
* allocateCString::
* IsList::
* ListHead::
* ListTail::
* allocatePair::
* updateListHead::
* updateListTail::
* IsTuple::
* tupleArity::
* tupleArg::
* allocateTpl::
* updateTuple::
* IsOpaque::
* OpaqueType::
* OpaqueValue::
* allocateOpaque::


File: april.info,  Node: IsInteger,  Next: IntVal,  Up: Support functions and macros

20.4.1 IsInteger
----------------

Form:
     inline logical IsInteger(objPo p);

The `IsInteger' macro is `True' if its argument is an integer value;
`False' otherwise.


File: april.info,  Node: IntVal,  Next: allocateInteger,  Prev: IsInteger,  Up: Support functions and macros

20.4.2 IntVal
-------------

Form:
     typedef long long integer;
     inline integer IntVal(objPo p);

The `IntVal' macro returns the `integer' value of an `objPo' structure.
Note that `April' `integer's are `long' `long' values - i.e., at least
64 bits long.

   The programmer should make sure that the `IsInteger' is true of `p'
- otherwise the returned value of `IntVal' is undefined.

   Note that the `April' engine distinguishes between integer values
and floating point values; however, the `April' language itself does
not - there is only a single `number' type in `April'. That means that
the plug-in function designer should handle both `IsInteger' and
`IsFloat' cases in functions that handle numeric values.


File: april.info,  Node: allocateInteger,  Next: IsFloat,  Prev: IntVal,  Up: Support functions and macros

20.4.3 allocateInteger
----------------------

Form:
     inline objPo allocateInteger(integer i);

The `allocateInteger' function returns an `April' value that represents
an `integer' value. Note that the returned value may need to be
`protected' if additional allocations are performed in a plug-in
function.


File: april.info,  Node: IsFloat,  Next: FloatVal,  Prev: allocateInteger,  Up: Support functions and macros

20.4.4 IsFloat
--------------

Form:
     inline logical IsFloat(objPo p);

The `IsFloat' macro is `True' if its argument is a float value; `False'
otherwise.


File: april.info,  Node: FloatVal,  Next: allocateFloat,  Prev: IsFloat,  Up: Support functions and macros

20.4.5 FloatVal
---------------

Form:
     inline double FloatVal(objPo p);

The `FloatVal' macro returns the `double' value of an `objPo'
structure. Note that `April' floating point values are `double' values.

   The programmer should make sure that the `IsFloat' is true of `p' -
otherwise the returned value of `FloatVal' is undefined.

   Note that the `April' engine distinguishes between integer values
and floating point values; however, the `April' language itself does
not - there is only a single `number' type in `April'. That means that
the plug-in function designer should handle both `IsInteger' and
`IsFloat' cases in functions that handle numeric values.


File: april.info,  Node: allocateFloat,  Next: IsSymb,  Prev: FloatVal,  Up: Support functions and macros

20.4.6 allocateFloat
--------------------

Form:
     inline objPo allocateFloat(double i);

The `allocateFloat' function returns an `April' value that represents a
`double' value. Note that the returned value may need to be `protected'
if additional allocations are performed in a plug-in function.

   `allocateFloat' should only be used if the actual value is
non-integral or if the value cannot be represented using an `integer'.


File: april.info,  Node: IsSymb,  Next: SymVal,  Prev: allocateFloat,  Up: Support functions and macros

20.4.7 IsSymb
-------------

Form:
     inline logical IsSymb(objPo p);

The `IsSymb' macro is `True' if its argument is a symbol value; `False'
otherwise.


File: april.info,  Node: SymVal,  Next: newSymbol,  Prev: IsSymb,  Up: Support functions and macros

20.4.8 SymVal
-------------

Form:
     inline char *SymVal(objPo p);

The `SymVal' macro returns the `symbol' value of an `objPo' structure.
Note that although `April' `symbol's are represented as `char *'
pointers, they are in fact entries in a standard dictionary table.
I.e., it is not acceptable to return use an arbitrary `char *' pointer
when comparing or using an `April' `symbol' value.

   The programmer should make sure that the `IsSymb' is true of `p' -
otherwise the returned value of `SymVal' is undefined.


File: april.info,  Node: newSymbol,  Next: IsString,  Prev: SymVal,  Up: Support functions and macros

20.4.9 newSymbol
----------------

Form:
     inline objPo newSymbol(const char *s);

The `newSymbol' function returns an `April' value that represents a
`symbol' value. Note that the returned value may need to be `protected'
if additional allocations are performed in a plug-in function.


File: april.info,  Node: IsString,  Next: StrVal,  Prev: newSymbol,  Up: Support functions and macros

20.4.10 IsString
----------------

Form:
     inline logical IsString(objPo p);

The `IsString' macro is `True' if its argument is a string value;
`False' otherwise.


File: april.info,  Node: StrVal,  Next: StringText,  Prev: IsString,  Up: Support functions and macros

20.4.11 StrVal
--------------

Form:
     inline stringPo StrVal(objPo p);

The `StrVal' macro returns the `string' value of an `objPo' structure.
Note that `April' `string's are represented specific compound
structures. `string' values should only be accessed via the special
access functions `StringText' and `StringChar'.

   The programmer should make sure that the `IsString' is true of `p' -
otherwise the returned value of `StrVal' is undefined.


File: april.info,  Node: StringText,  Next: StringSize,  Prev: StrVal,  Up: Support functions and macros

20.4.12 StringText
------------------

Form:
     inline char *StringText(stringPo p);

The `StringText' macro returns the `char *' value of an `stringPo'
structure; i.e., it returns the actual text of an `April' string.

   Note that the text of a `string' value passed in an argument should
not be modified by a plug-in function.

   In addition, note that `April' `string' values may contain arbitrary
characters - including the `ASCII' `NUL' value. I.e., `April' `string'
values are not the same as C `char *' values - which are always
terminated by a `NUL' character.


File: april.info,  Node: StringSize,  Next: allocateString,  Prev: StringText,  Up: Support functions and macros

20.4.13 StringSize
------------------

Form:
     inline long StringSize(stringPo p);

The `StringSize' macro returns the length of an `stringPo' structure.


File: april.info,  Node: allocateString,  Next: allocateSubString,  Prev: StringSize,  Up: Support functions and macros

20.4.14 allocateString
----------------------

Form:
     inline objPo allocateString(char *s,long size,long margin);

The `allocateString' function constructs an `April' `string' value from
a `char *' array. The length of the string is given in `size'. The
`margin' of the string is normally set to 0; however, if the programmer
of the plug-in function believes that the returned `string' value is
likely to `participate' in a `string concatenation' then setting the
margin to a positive value may improve system performance.


File: april.info,  Node: allocateSubString,  Next: allocateCString,  Prev: allocateString,  Up: Support functions and macros

20.4.15 allocateSubString
-------------------------

Form:
     inline objPo allocateSubString(char *s,long offset,long size);

The `allocateSubString' function constructs a sub-string of an already
existing `April' `string' value. The length of the string is given in
`size', and the start position of the sub-string is given as `offset'
(starting at 0).

   Where appropriate, creating sub-strings is more memory efficient and
time-efficient than creating new strings.


File: april.info,  Node: allocateCString,  Next: IsList,  Prev: allocateSubString,  Up: Support functions and macros

20.4.16 allocateCString
-----------------------

Form:
     inline objPo allocateCString(char *s);

The `allocateCString' function constructs an `April' `string' value
from a C string. This is equivalent to a call of the form:

       allocateString(s,strlen(s),0);


File: april.info,  Node: IsList,  Next: ListHead,  Prev: allocateCString,  Up: Support functions and macros

20.4.17 IsList
--------------

Form:
     inline logical IsList(objPo p);

The `IsList' macro is `True' if its argument is a list pair value;
`False' otherwise.


File: april.info,  Node: ListHead,  Next: ListTail,  Prev: IsList,  Up: Support functions and macros

20.4.18 ListHead
----------------

Form:
     inline objPo ListHead(objPo l);

The `ListHead' function returns the head of a non-empty list.


File: april.info,  Node: ListTail,  Next: allocatePair,  Prev: ListHead,  Up: Support functions and macros

20.4.19 ListTail
----------------

Form:
     inline objPo ListTail(objPo l);

The `ListTail' function returns the tail of a non-empty list.


File: april.info,  Node: allocatePair,  Next: updateListHead,  Prev: ListTail,  Up: Support functions and macros

20.4.20 allocatePair
--------------------

Form:
     inline objPo allocatePair(objPo *head,objPo *tail);

The `allocatePair' function constructs an `April' list `pair' value
from two other `April' values. Note that the head and tail of the new
list pair are passed in as `objPo *' pointers rather than `objPo'
values.


File: april.info,  Node: updateListHead,  Next: updateListTail,  Prev: allocatePair,  Up: Support functions and macros

20.4.21 updateListHead
----------------------

Form:
     inline void updateListHead(objPo l,objPo el);

The `updateListHead' function is used to `update' the head of a list.
Note that you should should not modify any `April' value passed in as
an argument to the plug-in function. However, it is acceptable to
modify a list that has been created within the same plug-in function
call.


File: april.info,  Node: updateListTail,  Next: IsTuple,  Prev: updateListHead,  Up: Support functions and macros

20.4.22 updateListTail
----------------------

Form:
     inline void updateListTail(objPo l,objPo el);

The `updateListTail' function is used to `update' the tail of a list.
Note that you should should not modify any `April' value passed in as
an argument to the plug-in function. However, it is acceptable to
modify a list that has been created within the same plug-in function
call.


File: april.info,  Node: IsTuple,  Next: tupleArity,  Prev: updateListTail,  Up: Support functions and macros

20.4.23 IsTuple
---------------

Form:
     inline logical IsTuple(objPo p);

The `IsTuple' macro is `True' if its argument is a tuple value; `False'
otherwise.


File: april.info,  Node: tupleArity,  Next: tupleArg,  Prev: IsTuple,  Up: Support functions and macros

20.4.24 tupleArity
------------------

Form:
     inline long tupleArity(objPo l);

The `tupleArity' function returns the length or arity of a tuple.


File: april.info,  Node: tupleArg,  Next: allocateTpl,  Prev: tupleArity,  Up: Support functions and macros

20.4.25 tupleArg
----------------

Form:
     inline objPo tupleArg(objPo t,long i);

The `tupleArg' function returns an element of a tuple. The first
element of the tuple is argument 0.


File: april.info,  Node: allocateTpl,  Next: updateTuple,  Prev: tupleArg,  Up: Support functions and macros

20.4.26 allocateTpl
-------------------

Form:
     inline objPo allocateTpl(long len);

The `allocateTpl' function constructs an `April' tuple.

   Note that the `April' language cannot deal with tuples of arity 1.
Therefore, plug-in functions should never return such values.

   The individual elements of the new tuple should be set using the
`updateTuple' function.


File: april.info,  Node: updateTuple,  Next: IsOpaque,  Prev: allocateTpl,  Up: Support functions and macros

20.4.27 updateTuple
-------------------

Form:
     inline void updateTuple(objPo l,long offset,objPo el);

The `updateTuple' function is used to `update' an element of a tuple.
Note that you should should not modify any `April' value passed in as
an argument to the plug-in function. However, it is acceptable (indeed,
it is required) to modify a tuple that has been created within the same
plug-in function call.


File: april.info,  Node: IsOpaque,  Next: OpaqueType,  Prev: updateTuple,  Up: Support functions and macros

20.4.28 IsOpaque
----------------

Form:
     inline logical IsOpaque(objPo p);

The `IsOpaque' macro is `True' if its argument is an opaque value;
`False' otherwise. Opaque values are never directly used by `April'
programs. However, they provide a convenient method for plug-in
functions to return values to the `April' program that can be accessed
by other plug-in functions in the same plug-in module.


File: april.info,  Node: OpaqueType,  Next: OpaqueValue,  Prev: IsOpaque,  Up: Support functions and macros

20.4.29 OpaqueType
------------------

Form:
     inline void *OpaqueType(objPo p);

`Opaque' values have a type and a value. The type can be used by a
plug-in function to verify that an opaque value passed into to it truly
`belongs' to it.


File: april.info,  Node: OpaqueValue,  Next: allocateOpaque,  Prev: OpaqueType,  Up: Support functions and macros

20.4.30 OpaqueValue
-------------------

Form:
     inline void *OpaqueValue(objPo p);

This function `unwraps' an opaque value as passed into a plug-in
function and returns the actual value associated with the opaque value.
The type of this value is returned as a `void *' pointer since the
`April' engine has no interpretation of `Opaque' values.


File: april.info,  Node: allocateOpaque,  Prev: OpaqueValue,  Up: Support functions and macros

20.4.31 allocateOpaque
----------------------

Form:
     inline objPo allocateOpaque(const void *type,void *val);

This function can be sed by plug-in functions to `wrap up' pointers in a
way that can be returned and processed by `April' programs. The primary
purpose of this is to allow `April' programs to remember values of
importance to the plug-in function itself - and to pass them in to
subsequent calls to plug-in functions in the same plug-in module.

   The `type' argument should be a specific fixed value that the
plug-in module can use to distinguish opaque values as belonging to it.

   Note that the memory management system may `lose' opaque values if
the `April' program no longer references them. The plug-in module is
not informed up such a loss of reference.


File: april.info,  Node: April grammar,  Next: Standard operators,  Prev: Extending the April system,  Up: Top

Appendix A Formal `April' grammar
*********************************

There are several different levels of `April''s syntax:
   * The presentation or publication syntax of the language. This is
     the main subject of this manual; it includes many `convenience'
     features designed to make writing programs simpler. However, it is
     quite complex, and is difficult to construct an understandable
     semantics for. On the other hand, presentation syntax is
     automatically processed into the simpler `core' language.

   * The core language represents that version of the language which
     can be directly understood by the compiler. It lacks many of the
     expected features of the language - such as a `case' statement for
     example, or event message `receive'.

   * The surface syntax - which defines the legal syntactic expressions
     of the language and is based on an operator precedence grammar.

   * The token syntax - which defines the legal tokens of `April'.

   In this appendix we present these in reverse order: first the formal
syntax for legal `April' tokens, the formal operator precedence
grammar, and then the core language.

* Menu:

* Token syntax::                Legal `April' symbols
* Operator precedence grammar::  Legal syntactic forms in `April'
* Core April syntax::
* Presentation syntax::         Full form of `April' syntax


File: april.info,  Node: Token syntax,  Next: Operator precedence grammar,  Up: April grammar

A.1 Token syntax
================

We use _regular expression_ notation to express our definition of legal
tokens. This takes the form of a set of equations of the form:

     _integer_ = [1-9][0-9]*

This defines what it means to be an INTEGER: a leading digit character
in the range `1' to `9', followed by any number of digit characters in
the range `0' to `9'.

   The result, INTEGER, can be `plugged' into the operator precedence
grammar as a terminal.

* Menu:

* Identifier syntax::           syntax of `April' IDENTs
* Number syntax::               syntax of `April' numbers
* Strings::                     Syntax of `April' strings
* Comments::                    Syntax of `April' comments


File: april.info,  Node: Identifier syntax,  Next: Number syntax,  Up: Token syntax

A.1.1 Syntax of `April' IDENTs
------------------------------

There are two main classes of identifier, the alphanumeric identifier
which is used typically for symbols and variables and graphic
identifiers which are typically used for operators.

     IDENT = ALPHA | GRAPHIC
     ALPHA = [a-zA-Z_][a-zA-Z_0-9]*
     GRAPHIC = [!@#$%^&*-=+:~<>./?\|]+
     SINGLE = ''QUOTECHAR

Note that the period character - `.' - serves in a dual role: as a
graphic character and as the `decimal point' in floating point numbers.
The potential ambiguity is resolved in the standard way: if a full stop
character is surrounded by digit characters then is it part of a
floating point number, otherwise it is interpreted as a graphic
character.

   Note also that the semi-colon character - `;' - is reserved (i.e.,
it cannot appear inside an identifier) even though it is an operator. In
fact, the status of the `;' token depends on whether it appears
_within_ an expression - inside any `{}''s, `()''s or `[]''s - in which
case it is treated as a regular operator - or _between_ expressions -
in which case it is treated as an expression terminator.

   The last type of symbol - the _single character_ symbol has a
special syntax that allows a symbol to be any single character. This
special form of symbol allows any single character to be `made' into a
symbol. For example, the tokens:

     ''a  ''0 ''\0

are all symbols. The first one is in fact equivalent to simply:

     'a

The second token refers to the ASCII character for the digit `0' (not
to be confused with the number zero) and the last one refers to the NUL
character.


File: april.info,  Node: Number syntax,  Next: Strings,  Prev: Identifier syntax,  Up: Token syntax

A.1.2 Syntax of `April' numbers
-------------------------------

There are two main types of number: INTEGERs and FLOATING point
numbers, both are of type `number'.

     NUMBER = INTEGER | CHARCODE | FLOATING

In the case of INTEGER we can use decimal, octal or hexadecimal number
representations:

     INTEGER = DECIMAL | OCTAL | HEX
     DECIMAL = [1-9][0-9]*
     OCTAL = 0[0-7]*
     HEX = 0x[0-9a-fA-F]+

   Note that octal numbers have a leading zero digit, whereas decimal
numbers do not.  This convention is similar to the "C" language
convention for octal and decimal numbers.

   A CHARCODE is a useful way of denoting the numeric ASCII code of a
character. The form of a CHARCODE is:

     CHARCODE = 0cQUOTECHAR

   For example, the tokens:

     0cA 0c\n

denote the numeric values:
     65 10
   corresponding to the ASCII values of upper case letter `A' and
line-feed respectively.

   The regular expression for floating point numbers is:

     FLOATING = [0-9]+.[0-9]+([eE]-?[0-9]+)?

Notice that negative numbers do not form single tokens - they are
`processed' as expressions. The `April' compiler does, however,
automatically fold such expressions into a negative number.


File: april.info,  Node: Strings,  Next: Comments,  Prev: Number syntax,  Up: Token syntax

A.1.3 Syntax of `April' `strings'
---------------------------------

`April' strings may consist of arbitrary characters.  The regular
expression for `string' is:

     STRING = "QUOTECHAR*"

The QUOTECHAR production defines the legal characters that may appear
in strings, it is also the basis of the single character symbol
notation and the character encoding notation.

   QUOTECHAR is also defined using regular expressions:

     QUOTECHAR = [^"'\n\\]|\\QCHAR
     QCHAR = [abdefnrtv\\] | octal | hex

i.e., a quote character is any character except new-line (or any other
control character), double or single quote or backslash, or a backslash
followed by a special character or by the numeric code of the character
in octal or hexadecimal. The notation `\\' in the regular expression
above means the character `\' - backslash is a meta-character of
regular expression notation.

   Some of the characters which may follow a backslash have a specific
meaning:
`\a'
     Alarm bell.

`\b'
     Backspace character.

`\d'
     Delete character.

`\e'
     Escape character.

`\f'
     Form feed character.

`\n'
     New line character (_as a character within the string_).

`\r'
     Carriage return character.

`\t'
     Tab character.

`\v'
     Vertical tab character.

`\?'
     Any other character, including the backslash character itself and
     the quote characters.

For convenience, string values can be split into adjacent segments: two
or more strings separated only by `white space' are considered to
represent a single string.


File: april.info,  Node: Comments,  Prev: Strings,  Up: Token syntax

A.1.4 Syntax of `April' comments
--------------------------------

There are two styles of comment supported by `April' - line comments
and continuous comments.

Line comments
     take the form of a double hyphen (`--'), followed by a non-graphic
     character - usually a space - and is terminated by the end-of-line
     character or the end-of-file marker whichever comes first.

Continuous comments
     are the same as "C"-style comments: they are started by the
     characters `/*' and terminated by the characters `*/'.

   Note that if a line comment contains the `/*' lead characters of a
continuous comment, they are ignored: they are not interpreted as the
start of a continuous comment.

   However, a continuous comment may include a line comment, but if that
line comment contains the `*/' comment trail characters, the continuous
comment is terminated and the rest of the line is _not_ treated as a
comment.


File: april.info,  Node: Operator precedence grammar,  Next: Core April syntax,  Prev: Token syntax,  Up: April grammar

A.2 Operator precedence grammar
===============================

We shall use _Definite Clause Grammars_ (DCG) to write the grammar
rules for the operator precedence grammar.  A DCG rule looks like:

     TERM0  ==>  ( TERM0 )

which means that a `term0' can be formed by taking a `term0' and
enclosing it with the tokens ``('' and ``)''.

   It is permitted to include context sensitive tests in a DCG rule,
these are denoted by predicates which are enclosed by braces, as in
     _term(N)_  ==>  _preop(O,P,R) {P<=N}_ _term(R)_

which builds in a test that the value `P' is numerically less than `N'.

   The full operator precedence grammar of `April' is essentially very
simple:

     TERM ==> _term(2000)_ ;          -- Terms are terminated by a semi-colon.

     _term(N)_  ==>  _preop(O,P,R) {P<=N} term(R)_
       |  TERM(L) _infop(O,P,L,R)_ {P<=N} TERM(R)
       |  TERM(L) POSTOP(O,P,L) {P<=N}
       |  TERM0

     TERM0  ==>  IDENT
       |  NUMBER
       |  STRING                    -- A single string or a string sequence
       |  ( )                      -- Empty tuple
       |  [ ]                      -- Empty list
       |  { }                      -- Empty statement

       |  [ LIST_ELS ]                -- Non-empty list
       |  { _term(2000)_ }              -- Override operator precedences
       |  ( _term(2000)_ )              -- Override operator precedences
       |  ''' IDENT                   -- Escape operator and other interpretations
       |  % IDENT                     -- Type variable identifier
       |  TERM0 TERM0                 -- Function application

     LIST_ELS ==> _term(999)_
       | _term(999)_ , LIST_ELS
       | _term(999)_ ,.. _term(999)_

   Note that _preop(O,P,R)_ means that the identifier O is a prefix
operator with priority P and an expected right priority of R. In the
case of an associative prefix operator P = R; whereas in the case on a
non-associative prefix operator P = R+1.

   Similarly, `postop' and `infop' refer to postfix operators and infix
operators respectively.

   Note that we have two `bracketing' combinations: the `{}' pair and
the `()' pair. While these are semantically equivalent, we normally use
`()''s to group expression values, and we use `{}''s to group
statements.


File: april.info,  Node: Core April syntax,  Next: Presentation syntax,  Prev: Operator precedence grammar,  Up: April grammar

A.3 Core `April' syntax
=======================

The `core' `April' syntax refers to the core version of the language -
it represents the `minimal' form of `April'. In contradistinction to
the `presentation' syntax, core `April' lacks many features and
conveniences - such as message sending and recieving, `case' statements
and `repeat'...`until' loops.

   On the other hand, because core `April' is so minimal, it is
considerably easier to specify and to verify its soundness - hence the
distinction. Presentation `April' is converted into core `April' mostly
by means of standard macros that are automatically included by the
`April' compiler.

* Menu:

* Core April types::
* Core April expressions::
* Core April patterns::
* Core April statements::
* Core April programs::


File: april.info,  Node: Core April types,  Next: Core April expressions,  Up: Core April syntax

A.3.1 Core `April' types
------------------------


     TYPE ==> symbol
       | number                      -- Includes both integers and floating points
       | string
       | %IDENT                       -- type variable
       | TYPE[]                       -- list-type
       | TUPLE-TYPE
       | TYPE => TYPE                 -- function-type
       | TYPE {}                      -- procedure-type
       | %IDENT.TYPE                  -- bound type expression
       | typeof(EXP)                 -- `pick up' type of an expression
       | any                         -- universal type

     TUPLE-TYPE ==> TYPE ? IDENT
       | TYPE ? IDENT , TUPLE-TYPE

     TYPE-DECLARATION ==> TYPE-NAME ::= TYPE
       | TYPE-NAME ::= NEW-TYPE-DECLARATION

     NEW-TYPE-DECLARATION ==> IDENT
       | IDENT TYPE             -- labelled types
       | NEW-TYPE-DECLARATION '|' NEW-TYPE-DECLARATION

     TYPE-NAME ==> IDENT
       | IDENT (%IDENT,...,%IDENT)

Note that there are a number of `standard' types which are pre-defined
in the `April' language but which are not mentioned here - for example,
the `logical' type and the `handle' type. Such types, while they are
integral to the language, are defined by standard definitions; for
example, `logical' is defined:

     logical ::= false | true;


File: april.info,  Node: Core April expressions,  Next: Core April patterns,  Prev: Core April types,  Up: Core April syntax

A.3.2 Core `April' expressions
------------------------------


     EXP ==> IDENT                 -- may be a variable or a symbol
       | ' IDENT                  -- a symbol
       | NUMBER
       | STRING
       | TUPLE-EXPRESSION
       | IDENT TUPLE-EXPRESSION
       | LIST-EXPRESSION
       | EXPRESSION . EXPRESSION     -- Dot expression
       | EXP EXP                 -- function application
       | FUNCTION
       | PROCEDURE
       | EXP '|' EXP             -- limited to functions and procedures
       | valof STATEMENT          -- Statement should contain a `valis'
       | collect STATEMENT          -- Statement should contain `elemis'
       | try `exp' onerror FUNCTION
       | exception EXP

     TUPLE-EXPRESSION ==> COMMA-TUPLE
       | THETA-TUPLE
       | ()                      -- empty tuple
       | {}                       -- empty tuple

     COMMA-TUPLE ==> IDENT=EXP
       | IDENT=EXP , COMMA-TUPLE

     THETA-TUPLE ==> THETA-FIELD ;
       | THETA-FIELD ; THETA-FIELD
       | THETA-FIELD ; THETA-TUPLE

     THETA-FIELD ==> IDENT=EXP        -- constant field
       | IDENT:EXP               -- updateable field
       | TYPE-NAME ::= TYPE

     LIST-EXPRESSION ==> []
       | [ LIST-ELEMENTS ]

     LIST-ELEMENTS ==> EXP
       | EXP ,.. EXP
       | EXP , LIST-ELEMENTS

Note that there is significant processing for TUPLE expressions from
presentation `April' syntax to core `April' syntax. In particular,
field names may be automatically generated for `unlabelled' tuples and
fields themselves may be generated from default values in the case of
labelled types.

   Where field names must be generated automatically, they are typically
of a form which makes them unavailable to the programmer.

   Note also that higher-level expressions - such as
`if'...`then'...`else' - are typically macro-processed into special
instances of the form:

     FUNCTION EXP

I.e., a direct application of a literal function value to an expression.


File: april.info,  Node: Core April patterns,  Next: Core April statements,  Prev: Core April expressions,  Up: Core April syntax

A.3.3 Core `April' patterns
---------------------------

     PATTERN ==> IDENT                -- new variable or pre-defined symbol
       | TYPE ? IDENT               -- introduce typed variable
       | ' IDENT
       | LIST-PATTERN
       | TUPLE-PATTERN
       | IDENT TUPLE-PATTERN
       | STRING-PATTERN
       | ! EXP                     -- match literal expression
       | PATTERN :: PREDICATE        -- conditional pattern

     LIST-PATTERN ==> []
       | [ LIST-ELEMENT-PATTERN ]

     LIST-ELEMENT-PATTERN ==> PATTERN
       | PATTERN , LIST-ELEMENT-PATTERN
       | PATTERN , PATTERN

     TUPLE-PATTERN ==> PATTERN
       | PATTERN , TUPLE-PATTERN


File: april.info,  Node: Core April statements,  Next: Core April programs,  Prev: Core April patterns,  Up: Core April syntax

A.3.4 Core `April' statements
-----------------------------

     STATEMENT ==> STMT
       | STMT ; STATEMENT

     STMT ==> VARIABLE-DECLARATION
       | IDENT := EXP
       | EXP EXP                   -- Procedure call
       | valis EXP                 -- Valid in a `valof' statement only
       | elemis EXP                -- Valid in a `collect' statement only
       | STATEMENT                 -- Introduce new scope context
       | PATTERN .= EXPRESSION      -- Pattern match statement
       | EXPRESSION . STATEMENT     -- Dot statement
       | for PATTERN in EXPRESSION do STATEMENT
       | while EXPRESSION do STATEMENT
       | IDENT :: STATEMENT         -- Labelled statement
       | leave IDENT
       | try `statement' onerror PROCEDURE
       | exception EXP

     VARIABLE-DECLARATION ==> IDENT : EXPRESSION
       | IDENT = EXPRESSION         -- Read-only declaration


File: april.info,  Node: Core April programs,  Prev: Core April statements,  Up: Core April syntax

A.3.5 Core `April' programs
---------------------------

April programs are composed of functions, procedures and collections of
these, which are all first-class `April' expressions. One notable form
of program expression is the `theta' tuple; a theta-tuple is a tuple of
values which may include recursively defined functions and procedures
and updateable fields. Updateable fields are only updateable by
functions and procedures defined within the theta-tuple itself.

     FUNCTION ==> PATTERN => EXP

     PROCEDURE ==> PATTERN -> STATEMENT


File: april.info,  Node: Presentation syntax,  Prev: Core April syntax,  Up: April grammar

A.4 `April' presentation syntax
===============================

The presentation syntax is a strict super-set of `April''s core syntax.
It also clearly defines the expected contents of an `April' program
file.

   `April' presentation syntax also includes a number of convenience
features - such as allowing elements of labelled types to be written
using field names and to have default values associated with them. In
addition, the presentation syntax defines statements such as message
send and message receive.

     PROGRAM-FILE ==> FILE-ELEMENT
       | FILE-ELEMENT PROGRAM-FILE
       | PROGRAM-ELEMENT

     FILE-ELEMENT ==> MACRO-DEFINITION
       | TYPE-DECLARATION                 -- non-recursive only
       | INCLUDE STATEMENT

     MACRO-DEFINITION ==> #macro MACRO-PATTERN ==> MACRO-REPLACEMENT

     MACRO-PATTERN ==> NUMBER
       | STRING
       | _
       | number
       | symbol
       | string
       | list
       | tuple
       | IDENT                            -- may be literal or macro var
       | []                                 -- empty list
       | [MACRO-PATTERN ,..MACRO-PATTERN]
       | MACRO-PATTERN []
       | (MACRO-PATTERN,...,MACRO-PATTERN)
       | ? IDENT                          -- define new macro var
       | MACRO-PATTERN ? IDENT
       | MACRO-PATTERN ~ MACRO-PATTERN
       | MACRO-PATTERN @ MACRO-PATTERN
       | MACRO-PATTERN ./ MACRO-PATTERN
       | MACRO-PATTERN | MACRO-PATTERN
       | MACRO-PATTERN MACRO-PATTERN
       | 'IDENT

     MACRO-REPLACEMENT ==> NUMBER
       | STRING
       | IDENT                            -- may be literal or macro var
       | []
       | [MACRO-REPLACEMENT ,..MACRO-REPLACEMENT]
       | (MACRO-REPLACEMENT,...,MACRO-REPLACEMENT)
       | MACRO-REPLACEMENT ## MACRO-REPLACEMENT
       | MACRO-REPLACEMENT ./ MACRO-REPLACEMENT
       | MACRO-REPLACEMENT @ MACRO-REPLACEMENT
       | #macro MACRO-REPLACEMENT ==> MACRO-REPLACEMENT
       | #echo (MACRO-REPLACEMENT,MACRO-REPLACEMENT)
       | #error (MACRO-REPLACEMENT,MACRO-REPLACEMENT)
       | #warning (MACRO-REPLACEMENT,MACRO-REPLACEMENT)
       | #list MACRO-REPLACEMENT
       | #tuple MACRO-REPLACEMENT
       | MACRO-REPLACEMENT # { MACRO-DEFINITION;...;MACRO-DEFINITION}
       | MACRO-REPLACEMENT MACRO-REPLACEMENT

     PROGRAM-ELEMENT ==> PROGRAM
       | MODULE

     PROGRAM ==> program IMPORT in BODY execute IDENT

     MODULE ==> module IMPORT in BODY export IDENT-SEQUENCE

     IMPORT ==>
       | import IMPORT-SPEC

     IMPORT-SPEC ==> PROGRAM-SPEC from FILE
       | IMPORT-SPEC and IMPORT-SPEC

     PROGRAM-SPEC ==> TYPE ? IDENT

     BODY ==> VAR-DECLARATION   -- may be recursive
       | FUNCTION-DEFINITION
       | PROCEDURE-DEFINITION
       | TYPE-DECLARATION
       | BODY ; BODY


File: april.info,  Node: Standard operators,  Next: Standard error codes,  Prev: April grammar,  Up: Top

Appendix B Standard operators in `April'
****************************************

There are many operators in `April' syntax; the following table shows
`April''s standard operators, and the relative precedences of these
operators.  The higher the priority of an operator the more likely the
operator will be the `top' operator in an expression - and the less
tightly it `binds' its arguments.

     /*
      * Declaration of system operators
      */

     /* Standard syntax `core' operators */

     #op('#,prefix,1500);            -- Introduce macros and includes etc
     #op('macro,prefix,1450);
     #op('==>,infix,1400);            -- #macro Ptn ==> Replacement
     #op('macro,prefix,1450);
     #op('macro,prefix,1450);
     #op('./,right,860);
     #op('@,infix,300);
     #op('#,infix,650);               -- list indexing and relative macros
     #op('##,right,300);
     #op('##,prefix,300);
     #op('~,infix,900);

     #op('_nodebug_,prefix,1450);
     #op('_debug_,prefix,1450);

     #op('include,prefix,1450);      -- Include file

     /* Top-level program operators */
     #op('module,prefix,890);        -- Module marker
     #op('_module,prefix,890);       -- System module marker
     #op('program,prefix,890);       -- Program marker
     #op('export,infix,800);         -- Indicate export list
     #op('execute,infix,800);        -- Indicate entry point
     #op('import,prefix,800);        -- Indicate import list
     #op('from,infix,750);           -- Indicate export list
     #op('where,infix,1000);         -- Indicate program or module body
     #op('interface,prefix,799);     -- Load interface definition file
     #op('=>,right,1200);            -- Equation
     #op('->,infix,1200);            -- Statement Clause
     #op('::=,infix,1460);           -- Type definition

     #op('|,right,1250);             -- Type/function union

     #op(':=,infix,1100);            -- Assignment operator
     #op(':,infix,999);              -- Mutable variable declaration
     #op('=,infix,999);              -- Constant variable declaration
     #op('.,left,400);               -- Record selection

     -- #op(',,right,1000);             -- Tupling operator
     -- #op(';,right,1900);             -- Statement sequence/theta marker
     -- #op(';,postfix,1900);            -- Statement sequence/theta marker

     #op('do,right,1300);            -- Loop construct
     #op('for,prefix,1250);          -- Loop construct
     #op('while,prefix,1250);        -- Loop construct
     #op('case,prefix,1190);         -- Case statement/expression

     #op('else,right,1195);          -- Conditional statement/expression
     #op('then,infix,1190);
     #op('if,prefix,1150);

     #op('try,prefix,1300);          -- Error handling
     #op('onerror,infix,1299);
     #op('exception,prefix,900);     -- Raise an error

     #op(':-,infix,1140);            -- Labelled statement
     #op('leave,prefix,310);         -- exit labelled statement

     #op('let,prefix,500);           -- let ... in exp form
     #op('valof,prefix,500);         -- valof/valis form
     #op('valis,prefix,1100);
     #op('collect,prefix,500);       -- collect ... elemis form
     #op('setof,prefix,500);         -- setof ... elemis form
     #op('elemis,prefix,1100);

     #op('??,infix,510);             -- Type caste
     #op('%%,infix,510);             -- Type coercion
     #op('??,prefix,510);            -- Type caste to any

     /* Operators for the message receive variations */
     #op('receive,prefix,1300);      -- Message receive statement
     #op('->>,infix,1200);           -- Receive clause
     #op('repeat,prefix,1300);       -- Stream message receive
     #op('until,infix,1290);
     #op('alarm,prefix,1249);
     #op('timeout,prefix,1010);      -- Timeout clause in message receive
     #op('~~,prefix,940);
     #op('~~,infix,940);

     /* Operators for message send variations */
     #op('>>,infix,1100);            -- Message send
     #op('>>>,infix,1100);           -- Message forward
     #op('!>>,postfix,1100);          -- Send to self
     #op('>>*,infix,1100);           -- Multi-cast

     #op('?,left,510);               -- Variable pattern
     #op('?,prefix,310);             -- Variable pattern
     #op('%,prefix,1);               -- Type variable
     #op('::,infix,940);             -- Pattern guard
     #op('!,aprefix,910);            -- Expression pattern
     #op('!!,aprefix,910);           -- Global variable update

     /* Process fork related operators */

     #op('fork,prefix,500);
     #op('spawn,prefix,900);
     #op('using,infix,899);
     #op('as,infix,880);
     #op('error_link,infix,850);
     #op('public_spawn, infix, 1100);

     /* Arithmetic operators */
     #op('+,left,720);               -- Addition
     #op('+,prefix,300);             -- Unary plus
     #op('-,left,720);               -- Subtraction
     #op('-,prefix,300);             -- Unary minus
     #op('*,left,700);               -- Multiplication
     #op('*,postfix,700);            -- String closure
     #op('/,left,700);               -- Division
     #op('%,left,700);               -- Integer quotient
     #op('rem,left,700);             -- Integer remainder

     /* Set operation operators */
     #op('\/,left,820);              -- Set union
     #op('/\,left,800);              -- Set intersection
     #op('<>,right,800);             -- List append
     #op('\,left,820);               -- Set difference
     #op('^,left,850);               -- Set projection
     #op('^/,left,840);              -- Set select
     #op('^\,left,840);              -- Set reject
     #op('//,left,840);             -- Map a list
     #op('map,left,840);            -- Synonym
     #op('\\,left,840);             -- Reduce a list
     #op('reduce,left,840);         -- Synonym

     #op('++,right,800);             -- String concatenation

     #op('.=,infix,900);             -- Pattern match predicate
     #op('==,infix,900);             -- Equality predicate
     #op('!=,infix,900);             -- Not equality predicate
     #op('<,infix,900);              -- Inequality predicate
     #op('>,infix,900);              -- Inequality predicate
     #op('<=,infix,900);             -- Inequality predicate
     #op('>=,infix,900);             -- Inequality predicate
     #op('in,infix,900);             -- Set membership predicate
     #op('.. ,infix,820);            -- Set iota
     #op('step,infix,840);           -- Step increment for set iota

     #op('append,left,800);          -- Synonym for <>
     #op('select,left,840);          -- Synonym for ^/
     #op('reject,left,840);          -- Synonym for ^\

     #op('&&,right,920);             -- Conjunction
     #op('and,right,920);            -- Conjunction
     #op('||,right,930);             -- Disjunction
     #op('or,right,930);             -- Disjunction
     #op('!,aprefix,910);            -- Negation
     #op('not,aprefix,910);          -- Negation

     #op('secs,postfix,600);         -- Time operators
     #op('mins,postfix,600);
     #op('hours,postfix,600);
     #op('days,postfix,600);

     /* Assignment operators */
     #op('+:=,infix,1100);
     #op('*:=,infix,1100);
     #op('/:=,infix,1100);
     #op('-:=,infix,1100);
     #op('<>:=,infix,1100);
     #op('^/:=,infix,1100);
     #op('^\:=,infix,1100);

     /* Set abstraction operators */
     #op('forall,infix,910);
     #op('istrue,prefix,910);
     #op('bagof,prefix,500);		-- setof ... elemis form
     #op('of,infix,975);		-- set abstraction operator

     /* Object operators */
     #op('object,prefix,990);
     #op('with,infix,980);
     #op('also_export,infix,880);
     #op('!,infix,905);
     #op('return,prefix,1100);
     #op('exporting,infix,800);
     #op('public,prefix,500);
     #op('visible,prefix,500);


File: april.info,  Node: Standard error codes,  Next: Encoded term format,  Prev: Standard operators,  Up: Top

Appendix C Standard error codes
*******************************

Nearly every built-in function and procedure may give rise to an error
if invoked incorrectly. An error value is of the standard `error' type:

     error ::= error(string,symbol) | failed | timedout | clickedout ;

The `error' constructor has two arguments: a descriptive string
explaining the error and a symbol denoting the classification of the
error; In this appendix we list the standard error codes:

`'matcherr'
     This is raised when a match failed in a situation where it is not
     safe for it to do so.

`'privileged'
     This is raised when a privilege violation is flagged - such as
     attempting to execute a privileged operation, or an invalid access
     to teh file system.

`'system'
     This is raised when the operation is potentially correct but the
     system could not honour it - due to space limitation for example.

`'exec'
     This is raised when attempting an illegal instruction or executing
     non-valid code.

`'compval'
     This is raised when attempting to compare incomparible values -
     such as two code segments.

`'invalid'
     This is raised when arguments have invalid values - such as
     attempting to take the square root of a negative number.

`'arith'
     This is raised when an arithmetic operation raised a problem -
     such as divide by zero.

`'abort'
     This is raised when the user causes the system to abort.

`'fail'
     This is raised when an operation fails - such as attempting to
     open a nn-existent for reading.

`'eof'
     This is raised when attempting to read past the end of file.

`'io'
     This is raised when an I/O error is raised while reading or writing

`'net'
     This is raised when a network error occurs - such as being unable
     to find a host.


File: april.info,  Node: Encoded term format,  Next: Notes for April v4 programmers,  Prev: Standard error codes,  Up: Top

Appendix D Encoded term format
******************************

`April' uses a special _encoded term format_ for a number of purposes -
such as when sending messages off-board and the format of compiled
programs. This encoded term format is a binary format that is oriented
for maximum efficiency in generating, parsing and storing.

   In this appendix we describe this format, which is alos used for
encoding `Go!' values, for those occasions where you may need explicit
knowledge of the way the terms are handled and stored.

   The encoded term format format is `self-parsing' and is able to
represent symbols, numbers, arbitrary strings, program code, lists and
tuples of  objects. Each of these types of structures have analogues in
most programming languages: for example, the symbol type can be
represented in Prolog as an atom, in `April' as a symbol, and in C or
Java as a string. The message format is even able to represent circular
or graph structured values.

   The self-parsing nature of the message format is important as it
allows a great deal of flexibility: it is not necessary for the
receiving agent of a message to be able to predict accurately the
complete structure of a message prior to receiving it.

   The representation of values is network neutral, and quite
efficient. For certain common cases, the low-level representation is
optimized to minimize the length of the encoded message structure.

* Menu:

* representation of values::
* circular structures::
* representing types::
* encoded terms in files::


File: april.info,  Node: representation of values,  Next: circular structures,  Up: Encoded term format

D.1 Representation of values
============================

The low-level structure of an encoded term consists of a sequence of
8bit bytes. Each object is preceded by a tag byte, followed by
zero-or-more data value bytes. Some structures are nested - such as
lists and tuples - in which case the elements of the nested structure
follow the lead tag information.

   The order of bytes in the encoded representation is well defined;
and is independent of the natural byte order within words in computer
memories - no little-endian wars here.

* Menu:

* integer representation::
* floating point representation::
* variable representation::
* character encoding::
* symbol encoding::
* string representation::
* list encoding::
* structure encoding::
* program code::


File: april.info,  Node: integer representation,  Next: floating point representation,  Up: representation of values

D.1.1 Integer
-------------

The representation of integer values is a key aspect of the encoded
term format - since not are integer terms themselves represented using
this format, but also many of the other kinds of terms - such as the
arity of tuples for example - use the same basic representation.

   An integer is represented as the byte `0x1_k_' , where _k_ is in the
range `0x1'...`0xf', followed by _k_ bytes defining the integer's
value. The bytes making the value of the integer are in network - that
is most significant byte first - order. The value is represented in
standard 2's complement form.

   For example, the integers `3' and `100,000' are represented by the
sequences:
     0x11 0x03
   and
     0x13 0x01 0x86 0xa0
   respectively.  Note that the value 0 is represented using the
sequence
     0x11 0x00

   If the tag code is `0x10' then the length of the integer is itself
expressed as an integer following the tag code, and the integer data
itself follows the length. This allows arbitrary sized integers.

   The following C program shows how an integer can be converted into
the appropriate stream of bytes:

     unsigned char *EncodeInt(int tag,long long val,
                              unsigned char *buff)
     {
       int len=0;
       unsigned char bytes[16];
       unsigned long long v = val;

       if(v==0)              /* special case for 0 */
         bytes[len++]=0;
       else
         while(v>0){
           bytes[len++]=v&0xff;
           v >>= 8;
         }

      *buff++=tag|len;       /* 0x1n ... */

       while(len-->0)
         *buff++=bytes[len];
       return buff;
     }

D.1.1.1 Tagged length
.....................

In many of the other encodings described below we require a numeric
value to characterize them; for example, a string value has a length
associated with it, as do constructor terms, and program code. We use
the encoded integer format to represent the value; in general these
numeric values have the form:
     0x_k__n_ 0xI_1_ ... 0xI_n_
   where _k_ is a _key_ that denotes the intended reading of the value
(for example, strings use a key of `0x6', constructors use a key of
`0x9'. The integer value is encoded in the _n_ bytes
`0xI_1_'...`0xI_n_' that follow the lead byte.

   We will refer to this structure as a _k_-tagged value or a
_k_-tagged length where the tag _k_ is a number that characterizes the
use of the value. Tagged values are typically followed by _length_
bytes or even _length_ complete encoded values.


File: april.info,  Node: floating point representation,  Next: variable representation,  Prev: integer representation,  Up: representation of values

D.1.2 Floating point encoding
-----------------------------

A floating point number is represented using the tag byte `0x2_n_', or
`0x3_n_' depending on whether the floating point number is positive or
negative, followed by the exponent of the number - in unbaissed form -
encoded in the same format as an integer and then _n_ bytes of
mantissae.

   The following C program shows how a floating point number can be
converted into the appropriate stream of bytes:

     /* Convert a double into a string buffer */
     unsigned char *EncodeFlt(double f, unsigned char *buff)
     {
       unsigned char bytes[16], *bf = bytes;
      int i,exp,len,sign=0x20; /* positive float */

       if(f<0.0){
        sign = 0x30;         /* negative float */
         f = -f;
       }

       f = frexp(f, &exp);

       for(len=0;f!=0.0;len++){
         double ip;
         f = modf(f*256,&ip);

         *bf++ = (int)ip;
       }

      *buff++=sign|len;      /* the lead character of the number */
      buff = icmEncodeInt(exp,0x10,buff); /* the exponent */

       for(i=0;i<len;i++)
        *buff++=bytes[i];
       return buff;
     }


File: april.info,  Node: variable representation,  Next: character encoding,  Prev: floating point representation,  Up: representation of values

D.1.3 Variables' encoding
-------------------------

There are two aspects of a variable's encoding: identifying the
variable and linking different occurrences of the variable within a
term.

   A variable occurrence is identified by a `0' tagged integer; i.e., a
`0x0_k_' byte, followed by _k_ bytes which encode a _variable number_
in the same format as an integer.

   The scope rules for variables are not defined by the encoding;
although a `decoding engine' is required to differentiate variables
within a single encoded term. If it is required to properly scope
variable occurrences within an encoded term then one should use the
variable encoding in conjunction with the tag and reference encoding.

   For example, to encode an expression such as:
     (x,x)
   one could use a tag/variable (see *note circular structures::)
combination for the first occurrence of `x' and a reference for the
subsequence occurrences. This would result in the sequence:
     0x91 0x01 0xa1 0x00 0x01 0x00 0xb1 0x00


File: april.info,  Node: symbol encoding,  Next: string representation,  Prev: character encoding,  Up: representation of values

D.1.4 Symbol encoding
---------------------

A symbol is represented by a `4'-tagged length, followed by the
characters of the symbol itself - encoded in UTF-8.

   For example, the symbol `'apple'' is represented by the sequence:

     0x41 0x05 0x61 0x70 0x70 0x6c 0x6e


File: april.info,  Node: character encoding,  Next: symbol encoding,  Prev: variable representation,  Up: representation of values

D.1.5 Character encoding
------------------------

A character literal is represented by a leading `0x4_k_' byte, where
_k_ is a number in the range `0x1'...`0xf' followed by _k_ bytes which
encode the character as a Unicode value. Note that the character is NOT
encoded in UTF-8, its actual Unicode code value is directly encoded as
an integer.


File: april.info,  Node: string representation,  Next: list encoding,  Prev: symbol encoding,  Up: representation of values

D.1.6 String encoding
---------------------

A string or uninterpreted data block contains bytes that are not
interpreted as having an internal structure. Their type is analogous to
a string in Java or `April'.

   A string is represented with a leading `0x6'-tagged length, followed
by the characters of the string - encoded in UTF-8.

   For example, the string: `"apple"' is encoded as the byte sequence:

     0x61 0x05 0x61 0x70 0x70 0x6c 0x6e
   Note that `April' is Unicode based, however, the sequence of bytes
that form the string is encoded in UTF-8


File: april.info,  Node: program code,  Prev: structure encoding,  Up: representation of values

D.1.7 Program code
------------------

The encoding for program code has two layers - in the first layer a
block of bytes is signalled as a code block. The encoding supports code
blocks for different languages, not only `April'.

   A program code is necessarily quite platform specific. In our
representation of program codes, we assume that there is an internal
method for verifying that a piece of program code is of the correct
structure. From the point of view of the encoded term format, program
codes are encoded in a similar manner to uninterpreted strings or
uninterpreted data blocks.

   A program code is represented with a leading `0x7_k_' byte, where
_k_ is a number in the range `0x0'...`0xf' followed by a length number
_N_ - itself encoded in _k_ bytes - followed by _N_ bytes of data.


File: april.info,  Node: list encoding,  Next: structure encoding,  Prev: string representation,  Up: representation of values

D.1.8 List encoding
-------------------

A list is a sequence of values, intended to be held either in a Prolog,
LISP or `April' style list, or as an array of values in languages such
as C, or Java.

   Lists come in two `sizes': the empty list and the non-empty list. An
empty list is represented by the `0x80' byte - with no data following
it - and a non-empty list consists of the `0x81' byte, followed by the
encoding of the head of the list, followed by the encoding of the tail
of the list.

   For example, the list of integer:
     [1,2,3]
   is encoded using the sequence:
     0x81 0x11 0x01                              -- [1,
          0x81 0x11 0x02                         --  2,
               0x81 0x11 0x03                    --  3
                    0x80                         --  ]


File: april.info,  Node: structure encoding,  Next: program code,  Prev: list encoding,  Up: representation of values

D.1.9 Structure encoding
------------------------

A structure includes tuples and constructor terms. A structure is
encoded using a `9'-tagged length, followed by length encoded terms.
The first element in the sequence should be a symbol which is either
the constructor function's name or the symbol `()' to indicate a tuple.

   For example, the `April' tuple
     ('fred', 23, [])

   would be represented using the sequence:
     0x91 0x04                       -- A 4-element structure
       0x41 0x02 0x28 0x29           -- Its a tuple
       0x41 0x04 0x66 0x72 0x65 0x64 -- 'fred'
       0x11 0x17                     -- 23
       0x80                          -- []


File: april.info,  Node: circular structures,  Next: representing types,  Prev: representation of values,  Up: Encoded term format

D.2 Circular structure and graph structures
===========================================

Some structures must be represented using some kind of circular or
graphical structure combination of lists and tuples. An important
example of this is a program _closure_. The term encoding permits this
through the use of tags and references. A tag is a marker that
identifies a particular structure - giving it a kind of label. A
reference is a reference to a structure that is marked elsewhere in the
message: the value denoted by a reference is the value marked by the
corresponding tag.

   With this, we can embed circular and arbitrary graphical structures
in messages and reproduce their structure when the message is decoded.

   A tag is represented as the byte `0xa_n_' - where _n_ is a number in
the range `0x0'...`0xf' - followed by _n_ bytes which encode a tag
number _N_; followed by the encoding of the tagged structure itself.

   A reference is represented using the byte `0xB_n_' - where _n_ is a
number in the range `0x0'...`0xf' - followed by _n_ bytes which encode
a tag number _N_. The `value' of the encoded structure is determined by
the previously decoded tagged object for the same _N_.

   For example, the following circular structure:

     L0: (foo, 23, R0)

   where `R0' is a reference to the complete tuple, can be encoded
using:
     0xA1 0x00                                      -- L0:
          0x91 0x04 0x41 0x28 0x29                  -- ( tuple
                    0x41 0x03 0x66 0x6f 0x6f        -- foo
                    0x11 0x17                       -- 23
                    0xB1 0x00                       -- R0

* Menu:

* shorthand references::


File: april.info,  Node: shorthand references,  Up: circular structures

D.2.1 Shorthand references
--------------------------

A shorthand reference allows significant message compression by
avoiding repetition of elements of the message. The basic form of a
shorthand reference consists of a definition followed by a structure
which may (or may not) embed a reference to the definiens.

   A shorthard definition is encoded using the lead byte `0xc_n_' -
where _n_ is a number in the range `0x0'...`0xf' - followed by a number
_N_ which is the _key_, followed by an encoded term - which is the
definiens - followed by a second encoded term - which is the `value' of
the entire sequence.

   Note that `April' itself does not currently _generate_ any shorthand
references but it is able to _decode_ them correctly.

   For example, the structure

     ('foo', ('bar', 'foo'), 'foo')

   would normally be represented using the sequence:

     0x91 0x04 0x41 0x02 0x28 0x29             -- ( tuple
          0x41 0x03 0x66 0x6f 0x6f             -- foo
          0x91 0x03 0x41 0x02 0x28 0x29        -- (tuple
                    0x41 0x03 0x62 0x61 0x72   --  bar
                    0x41 0x03 0x66 0x6f 0x6f   -- foo )
          0x41 0x03 0x66 0x6f 0x6f             -- foo)

   There are three references to the symbol `foo'. Normally, each
reference would result in the symbol's name being represented in full;
however, using a shorthand reference we can instead represent the
structure using:

     0xc1 0x00 0x41 0x02 0x28 0x29             -- L0=()
     0xc1 0x01 0x41 0x03 0x66 0x6f 0x6f        -- L1=foo
          0x91 0x04 0xB1 0x00                  -- ( ref L0
               0xB1 0x01                       -- R1:foo
               0x91 0x03 0xb1 0x00             -- ( ref L0
                         0x41 0x03 0x62 0x61 0x72   --  bar
                         0xb1 0x01              -- R1:foo )
           0xB1 0x01                            -- R1:foo)
   which is both a little shorter than the original but also more
efficient to decode.

   Note that references to the shorthand object are made using the same
encoded sequence as references to values in a circular structure.

   The _scope_ of a shorthand reference is the single encoded term that
immediately follows the definition. It is possible for a sub-structure
to also contain shorthand references; furthermore, it is possible to
re-use a given shorthand reference code. In this latter case the inner
definition of the shorthand reference overrides the outer definition of
the shorthand reference.


File: april.info,  Node: representing types,  Next: encoded terms in files,  Prev: circular structures,  Up: Encoded term format

D.3 Representing types
======================

`April' programs occasionally communicate values with embedded type
expressions within them; this is particularly true for those type that
have _existential type variables_ - values of such types must have a
type expression included within them that represents the value of the
existential type variable for that expression.

   For example, an `any'-type expression such as:
     ??(34)
   has a run-time representation analogous to:
     ??(34,number)

   Type expressions are represented using the same basic mechanisms as
for representing other terms. However, we use additional internal
`cues' to distinguish type terms from other terms.

   Type terms come in two basic forms - particular type symbols and
particular type constructors.

* Menu:

* type symbols::
* type constructors::
* variables in types::


File: april.info,  Node: type symbols,  Next: type constructors,  Up: representing types

D.3.1 Type symbols
------------------

All non-polymorphic types are represented using a symbol. The encoding
for a type symbol is the same as for a regular program symbol; except
that the symbol's first character is always `#'. For example, the
run-time symbol used to represent the `number' type is `'#number''.
Thus the representation of the expression `??(34)' is:

     0x91 0x03
          0x41 0x02 ''? ''?               -- ??
          0x11 0x32                     -- 34
          0x41 0x07 ''# ''n ''u ''m ''b ''e ''r -- #number


File: april.info,  Node: type constructors,  Next: variables in types,  Prev: type symbols,  Up: representing types

D.3.2 Type constructors
-----------------------

Type constructors are represented in a similar way to regular
constructors, except that the constructor's function symbol's first
character is always a `#'. For example, the symbol used to denote a
function type is `#{}=>', and the representation of the type expression:
     (number,number) => number
   is
     0x91 0x03 0x41 0x03 ''# ''= ''>
          0x91 0x03 0x41 0x03 ''# ''( '')
                    0x41 0x07 ''# ''n ''u ''m ''b ''e ''r
                    0x41 0x07 ''# ''n ''u ''m ''b ''e ''r
          0x41 0x07 ''# ''n ''u ''m ''b ''e ''r

   The standard type constructors are:

`() Tuple types use the `#()' type constructor symbol.'

`=> Function types use the `#=>' type constructor symbol.'

`{} Predicate types use the `#{}' type constructor symbol.'

`- Quantified types use the `#-' type constructor symbol.'

   User defined polymorphic (and object) types have a type constructor
symbol of the form:
     #_name_
   A type expression such as
     tree(symbol)
   would be represented as:
     0x91 0x02 0x41 0x05 ''# ''t ''r ''e ''e
               0x41 0x07 ''# ''n ''u ''m ''b ''e ''r


File: april.info,  Node: variables in types,  Prev: type constructors,  Up: representing types

D.3.3 Variables in types
------------------------

A type variable occurring in a type expression is representing using
the same mechanisms as regular variables. Note, however, that most type
variables occuring in a type expression are expected to be _bound_ -
i.e., scoped within an explicit universal type quantifier expression.


File: april.info,  Node: encoded terms in files,  Prev: representing types,  Up: Encoded term format

D.4 Encoded terms in files
==========================

A complete encoded term - as a separate unit on a file stream for
example - is encoded as a string (see *note string representation::).
I.e., there is an outer wrapper to encoded terms that gives the length
of the entire encoded expression. The characters of the string are
derived from encoding the term itself. This has the advantage that
encoded terms are always `self-parsing' when presented on actual file
streams.

   Furthermore, a _file_ that contains an encoded term may be
optionally prefixed by a shell escape, such as
     #!/opt/april/bin/april
   The purpose of this is to support the Unix shell script convention
where a `data file' may be interpreted as a shell script. This permits,
for example, a compiled `April' program to be executed as though it
were a binary or regular script.


File: april.info,  Node: Notes for April v4 programmers,  Next: Concept index,  Prev: Encoded term format,  Up: Top

Appendix E Notes for April v4 programmers
*****************************************

The main difference between version 4 of `April' and version 5 relates
to the `handle' type and the communications infrastructure of `April'.
With version 5 `April' no longer uses the ICM for supporting
communication between different `April' invocations. In fact,
`off-board' communication is no longer built-in to the language.

   Instead, this will be provided with special communications libraries
that must be loaded by the applications programmer. This approach makes
it simpler to incorporate additional communications support, such as
support for specific Industry standard communications protocols such as
SOAP.

   Other changes include a change in the representation of string
values, a new `char' data type and changes in the way that the file
system is managed.

* Menu:

* Unicode compliance::                  April is now Unicode compliant
* The handle data type::                The handle structure
* Characters and strings::              The form of the string type
* Operators::                           Changes in operator priorities
* Macro language::                      Maros are deprecated
* Communications infrastructure::       How April programs communicate
* URLs and file systems::               How data streams are found
* Any values revisited::                Any values' representation
* Deprecated functions::                Functions no longer supported
* Changed functions::                   Functions whose semantics are changed
* New functions::                       New functions introduced in this release


File: april.info,  Node: Unicode compliance,  Next: The handle data type,  Up: Notes for April v4 programmers

E.1 Unicode compliance
======================

`April' is now fully Unicode compliant. Source programs may be in
Unicode - either in UTF8 or in UTF16 encodings - and all internal
character data is represented in Unicode.

   This has had an comcomitant effect of introducing a range of new
predicates aimed at testing different aspects of Unicode characters;
and some older functions are no longer supported.

   In addition, the lexical definition of an identifier is extended to
allow programs to be written in non-latin characters. `April''s
definition of an identifier follows the guidelines laid out in the
Unicode specification.


File: april.info,  Node: The handle data type,  Next: Characters and strings,  Prev: Unicode compliance,  Up: Notes for April v4 programmers

E.2 The `handle' data type
==========================

In version 4 of `April' the data type for handle was defined as:
     handle ::= handle(string?tgt,string?name,string?home,string[]?locs)

   In version 5 we have a simpler handle type definition:
     handle ::= nullhandle |
       hdl(symbol,symbol)

The `nullhandle' enumerated symbol was supported in version 4 of
`April', however we have `legitemized' it in version 5.

   The `hdl' constructor has two arguments, both of which should be a
symbol. The first element is the `thread identifier' and the second is
the `agent name'. As with version 4, `April' supports process groups -
groups of processes which share the same name.

   Note that the new `hdl' structure does not have the equivalent of
the `home' attribute, nor does it have the `locs' attribute. This is in
order to remove from the language definition features that more
properly are handled by the communications infrastructure.

   A cosmetic difference is that the `hdl' constructor's fields are not
`labelled' the way that the `handle' constructor fields were. This
reflects the fact that, in practice labelled fields in a constructor
tend to be more annoying than supportive.

   Finally, we note that we changed the constructor itself in order to
make it clear the distinction between version 4 `handle's and version 5
`handle's.


File: april.info,  Node: Characters and strings,  Next: Operators,  Prev: The handle data type,  Up: Notes for April v4 programmers

E.3 Strings and Characters
==========================

The semantics of `string' values is different in `April'; instead of
being an opaque type - as in Version 4 - a string in Version 5 is a
list of characters. We introduce a new data type - `char' - which
denotes a character value and we have slightly modified the syntax of
`April' to reflect this.

   A character literal is written:
     ''_char_
   where _char_ is a string character - i.e., a character that can
appear in a string literal (*note Strings::).

   Note that this notation used to refer to a single-character
`symbol'. That interpretation is no longer supported.


File: april.info,  Node: Operators,  Next: Macro language,  Prev: Characters and strings,  Up: Notes for April v4 programmers

E.4 Operators
=============

In order to make certain common language constructs more convenient we
have slightly adjusted a few of the operators' priorities in version 5.
The operators concerned are `case', `if', `then' and `else'; their new
declarations are shown below
     #op('case,prefix,1190);         -- Case statement/expression

     #op('else,right,1195);          -- Conditional statement/expression
     #op('then,infix,1190);
     #op('if,prefix,1150);
   This has the effect of allowing functions defined in terms of `case'
analysis to have one fewer level of bracketing:
     fact(X) => case {
       0 => 1
     | N => N*fact(N-1)
     };
   and
     fact(X) => if X==0 then 1 else N*fact(N-1);
   Note this change should not affect any programs that compile
properly under version 4.


File: april.info,  Node: Macro language,  Next: Communications infrastructure,  Prev: Operators,  Up: Notes for April v4 programmers

E.5 Macro language
==================

Beginning with version 5, macros are _deprecated_. I.e., `April' has an
official _presentation_ syntax - as documented in this reference manual
for example - and does not sanction the use of macros to extend the
syntax.

   Although deprecated, the compiler does still use macros in its
implementation of `April'. This internal macro language supports most
of the macro language of version 4; with a few exceptions. The most
notable being that the `@' is not supported at all.


File: april.info,  Node: Communications infrastructure,  Next: URLs and file systems,  Prev: Macro language,  Up: Notes for April v4 programmers

E.6 Communications infrastructure
=================================

Another major change in version 5 is `April''s relationship to
communications infrastructure. In version 4 - and earlier -
communications was `wired-in' to the language. Unfortunately there is
no one communications infrastructure that is right in all circumstances.

   In the case of the ICM, and of `April''s old-style handles, a
thread-to-thread communications model was supported. However, this
leads to an unnecessary exposure of internal application's
implementation - which in turn makes it diffult to keep control of the
application. There are many legitimate situations where it is unwise to
expose an application's implementation structure to the point that the
ICM forced one to.

   There were other problems also; perhaps the `ugliest' was that two
handles could be different and yet refer to the same thread of
computation.

   Therefore we have chosen to completely separate the particular
communications infrastructure used in a given situation from the
language itself. This has two immeadiate consequences - `April''s new
`hdl' constructor has no `address' information in it (and two `handle'
terms refer to the same thread iff they are identical) and in order to
actually _do_ communications between applications a library module is
required to be loaded and used.

   Currently we supply a simple communications system (SCS) that
supports a thread-to-thread communications framework but which is not
intended to be used at a large scale or across ownership or application
boundaries. In the future, we plan to also offer an additional
communications system - the Agent Communication System (ACS) - that may
be used across such boundaries but which does not itself support a
thread-to-thread paradigm.


File: april.info,  Node: URLs and file systems,  Next: Any values revisited,  Prev: Communications infrastructure,  Up: Notes for April v4 programmers

E.7 URLs and file systems
=========================

The `April' system has moved to a URL-based method for locating files.
I.e., there is no longer any automatic hierarchic directory searching
for files.

   This is primarily reflected in the form of a file name as it may
appear in a source program or as presented to the file system.

   The form of a file name is:

     _proto_:_host_/_file_
   where supported protocols currently include `http', `file' and `sys'.

   The `http' protocol is used to access the contents of a file from a
web server; the `April' system uses a very simple version of the `http'
protocol to access the file.

   Currently `http' is only support in read-only mode; although that
may change in the future.

   The `file' protocol refers to a file in the host computer's file
system.

   The `sys' protocol refers to a standard `April' _system_ file. It is
normally only used to load standard includes and modules. The precise
location of the system `library' may either be a regular file system
(i.e., `sys' may be mapped to a particular `file' directory) or it may
be one of the other supported location protocols.

   For program sources, `April' implements the standard HTTP semantics
for accessing relative URLs; i.e., if an `April' source file uses an
`#include' of the form:

     #include "myHeader.ah";
   and it was the case that the absolute URL for the source file
containing this was:
     file:///Users/me/SuperProject/main.ap
   then the URL computed for the header file is:
     file:///Users/me/SuperProject/myHeader.ah
   This applies both to included files and any code modules: the
latters' URLs being resolved at load-time rather than compile-time.


File: april.info,  Node: Any values revisited,  Next: Deprecated functions,  Prev: URLs and file systems,  Up: Notes for April v4 programmers

E.8 The representation of `any' values
======================================

In version 4 an `any' value was represented internally as a pair: the
value itself and a string which encoded the value's type. In version 5
this is changed, in that the type is no longer encoded in a string
value but is represented using normal `April' data structures.

   For example, the any value:
     any("foo")
   was represented as though it were the constructor term:
     ??("foo","S")
   where `"S"' encoded the fact that the type is a string. In version 5
this is changed to:
     ??("foo",'#list('#char))
   For the most part this change should have no visible effect on
`April' programs. This change is one of the many changes that make
interoperation between `April' and `Go!' possible.


File: april.info,  Node: Deprecated functions,  Next: Changed functions,  Prev: Any values revisited,  Up: Notes for April v4 programmers

E.9 Deprecated functions
========================

A number of built-in functions represent obsolete facilities that have
been replaced by more advanced functions. The functions that have been
removed from `April' are listed here.

`ascii'
     This function is based on `April''s prior assumption about
     characters and symbols of length 1. This function is no longer
     valid, use `charCode' instead to access the Unicode value of a
     character (*note charCode::).

`charof'
     This function is based on `April''s prior assumption about
     characters and symbols of length 1. This function is no longer
     valid, use `charOf' instead to map a Unicode value into a
     character (*note charOf::).

`nthchar'
     This function is based on `April''s prior assumption about
     strings. `April' `string's are now simply lists of `char'acters;
     so this function is obsolete. Use `#' (*note #::) instead to
     access the nth element of a list.

`nthascii' (removed)
     This function is based on `April''s prior assumption about
     strings. `April' `string's are now simply lists of `char'acters;
     so this function is obsolete. Use `#' (*note #::) instead to
     access the nth element of a list.

`ascii2sym' (removed)
     This function is based on `April''s prior assumption about
     characters and symbols. This function is no longer valid. To map a
     list of Unicode characters into a symbol one can use:

          implode(_Exp_//((X)=>charOf(X)))
     where *note implode:: converts a list of characters into a
     `symbol'.

`sym2ascii' (removed)
     This function is based on `April''s prior assumption about
     characters and symbols. This function is no longer valid. To map a
     symbol into a list of Unicode characters one can use:

          explode(_Exp_)//((X)=>charCode(X)))
     where *note explode:: converts a `symbol' into a list of
     characters.

`strlen' (removed)
     This function is based on `April''s prior assumption about
     strings. `April' `string's are now simply lists of `char'acters;
     so this function is obsolete. Use `listlen' (*note listlen::)
     instead to compute the length of a list.

`sprintf'
     This function is obsolete. In most cases formatting can be
     achieved with the string formatting operators `^' and `~'. Other
     special cases can be handled using the `num2str' function.

`hdl2str'
     This function is obsolete. Handle formatting can be achieved with
     the string formatting operators `^' and `~'.

`any2str'
     This function is obsolete.

`_any2str'
     This function is obsolete.

`_sig2str'
     This function is obsolete.

`location'
     This function is obsolete as `April' no longer has a
     language-level binding to a communications infrastructure. The
     standard function `hostname' (*note host::) has very similar
     functionality.

`_agent_alias'
     This function is obsolete as the notion of a `agent handle' is
     obsolete.

`_analyse_handle'
     This function is obsolete as the format of the `handle' is now a
     regular `April' constructor term.

`commserver'
     This function is obsolete as `April' no longer has a
     language-level binding to a communications infrastructure.

`,+'
     This function and pattern is deprecated since `April''s string
     notation is now based on lists of `char'acters. Use the regular
     list cons operator; i.e., use:

          [X,..L]
     instead of
          X,+L
     However, these patterns and expressions are still supported by the
     compiler as synonyms for the list processing equivalent.

`++'
     This function and pattern is deprecated since `April''s string
     notation is now based on lists of `char'acters. Use the regular
     list append operator; i.e., use:

          X<>Y
     instead of
          X++Y
     However, `++' patterns and expressions are still supported by the
     compiler as synonyms for the list processing equivalent.

`fseek'
     This function is obsolete.

`_debugname'
     This function is obsolete. If it is required to use a non-standard
     debugger handle, this can be done at the command line.

`.!'
     This function is no longer supported.



File: april.info,  Node: Changed functions,  Next: New functions,  Prev: Deprecated functions,  Up: Notes for April v4 programmers

E.10 Changed functions
======================

A few functions have had their semantics changed, either to enhance the
original or to reflect changes in `April' itself.

`strof'

`num2str'

`isLetter'
     This function's argument type has been changed from `symbol' to
     `char' reflecting the new character data type.


File: april.info,  Node: New functions,  Prev: Changed functions,  Up: Notes for April v4 programmers

E.11 New functions
==================

There are a number of new functions in `April', most of them referring
to the Unicode classification of characters.

`isCcChar'
     This predicate is true of the `Other, control char' class of
     Unicode characters.

`isCfChar'
     This predicate is true of the `Other, format char' class of
     Unicode characters.

`isCnChar'
     This predicate is true of the `Other, unassigned char' class of
     Unicode characters.

`isCoChar'
     This predicate is true of the `Other, private char' class of
     Unicode characters.

`isCsChar'
     This predicate is true of the `Other, surrogate char' class of
     Unicode characters.

`isLlChar'
     This predicate is true of the `Letter, lowercase char' class of
     Unicode characters.

`isLmChar'
     This predicate is true of the `Letter, modifier char' class of
     Unicode characters.

`isLoChar'
     This predicate is true of the `Letter, other char' class of
     Unicode characters.

`isLtChar'
     This predicate is true of the `Letter, title char' class of
     Unicode characters.

`isLuChar'
     This predicate is true of the `Letter, uppercase char' class of
     Unicode characters.

`isMcChar'
     This predicate is true of the `Mark, spacing char' class of
     Unicode characters.

`isMeChar'
     This predicate is true of the `Mark, enclosing char' class of
     Unicode characters.

`isMnChar'
     This predicate is true of the `Mark, nonspacing char' class of
     Unicode characters.

`isNdChar'
     This predicate is true of the `Number, decimal digit' class of
     Unicode characters.

`isNlChar'
     This predicate is true of the `Number, letter char' class of
     Unicode characters.

`isNoChar'
     This predicate is true of the `Number, other char' class of
     Unicode characters.

`isPcChar'
     This predicate is true of the `Punctuation, connector' class of
     Unicode characters.

`isPdChar'
     This predicate is true of the `Punctuation, dash char' class of
     Unicode characters.

`isPeChar'
     This predicate is true of the `Punctuation, close char' class of
     Unicode characters.

`isPfChar'
     This predicate is true of the `Punctuation, final quote' class of
     Unicode characters.

`isPiChar'
     This predicate is true of the `Punctuation, initial quote' class
     of Unicode characters.

`isPoChar'
     This predicate is true of the `Punctuation, other char' class of
     Unicode characters.

`isPsChar'
     This predicate is true of the `Punctuation, open char' class of
     Unicode characters.

`isScChar'
     This predicate is true of the `Symbol, currency char' class of
     Unicode characters.

`isSkChar'
     This predicate is true of the `Symbol, modifier char' class of
     Unicode characters.

`isSmChar'
     This predicate is true of the `Symbol, math char' class of Unicode
     characters.

`isSoChar'
     This predicate is true of the `Symbol, other char' class of
     Unicode characters.

`isZlChar'
     This predicate is true of the `Separator, line char' class of
     Unicode characters.

`isZpChar'
     This predicate is true of the `Separator, para char' class of
     Unicode characters.

`isZsChar'
     This predicate is true of the `Separator, space char' class of
     Unicode characters. This includes the ASCII space character itself.

`digitCode'
     The Unicode 3.1 standard has 248 digit characters in it -
     characters that represent a numeric value - as well as many other
     kinds of numeric characters.

     The `digitCode' function returns the numeric value associated with
     these characters.

`charOf'
     This function convert a numeric Unicode value into its equivalent
     `char' value.

`charCode'
     This function returns the Unicode value associated with a `char'.


File: april.info,  Node: Copying,  Next: Compiling April programs,  Prev: Top,  Up: Top

GNU GENERAL PUBLIC LICENSE
**************************

                         Version 2, June 1991

     Copyright (C) 1989, 1991 Free Software Foundation, Inc.
     675 Mass Ave, Cambridge, MA 02139, USA

     Everyone is permitted to copy and distribute verbatim copies
     of this license document, but changing it is not allowed.

Preamble
========

The licenses for most software are designed to take away your freedom
to share and change it.  By contrast, the GNU General Public License is
intended to guarantee your freedom to share and change free
software--to make sure the software is free for all its users.  This
General Public License applies to most of the Free Software
Foundation's software and to any other program whose authors commit to
using it.  (Some other Free Software Foundation software is covered by
the GNU Library General Public License instead.)  You can apply it to
your programs, too.

   When we speak of free software, we are referring to freedom, not
price.  Our General Public Licenses are designed to make sure that you
have the freedom to distribute copies of free software (and charge for
this service if you wish), that you receive source code or can get it
if you want it, that you can change the software or use pieces of it in
new free programs; and that you know you can do these things.

   To protect your rights, we need to make restrictions that forbid
anyone to deny you these rights or to ask you to surrender the rights.
These restrictions translate to certain responsibilities for you if you
distribute copies of the software, or if you modify it.

   For example, if you distribute copies of such a program, whether
gratis or for a fee, you must give the recipients all the rights that
you have.  You must make sure that they, too, receive or can get the
source code.  And you must show them these terms so they know their
rights.

   We protect your rights with two steps: (1) copyright the software,
and (2) offer you this license which gives you legal permission to copy,
distribute and/or modify the software.

   Also, for each author's protection and ours, we want to make certain
that everyone understands that there is no warranty for this free
software.  If the software is modified by someone else and passed on, we
want its recipients to know that what they have is not the original, so
that any problems introduced by others will not reflect on the original
authors' reputations.

   Finally, any free program is threatened constantly by software
patents.  We wish to avoid the danger that redistributors of a free
program will individually obtain patent licenses, in effect making the
program proprietary.  To prevent this, we have made it clear that any
patent must be licensed for everyone's free use or not licensed at all.

   The precise terms and conditions for copying, distribution and
modification follow.

    TERMS AND CONDITIONS FOR COPYING, DISTRIBUTION AND MODIFICATION
  1. This License applies to any program or other work which contains a
     notice placed by the copyright holder saying it may be distributed
     under the terms of this General Public License.  The "Program",
     below, refers to any such program or work, and a "work based on
     the Program" means either the Program or any derivative work under
     copyright law: that is to say, a work containing the Program or a
     portion of it, either verbatim or with modifications and/or
     translated into another language.  (Hereinafter, translation is
     included without limitation in the term "modification".)  Each
     licensee is addressed as "you".

     Activities other than copying, distribution and modification are
     not covered by this License; they are outside its scope.  The act
     of running the Program is not restricted, and the output from the
     Program is covered only if its contents constitute a work based on
     the Program (independent of having been made by running the
     Program).  Whether that is true depends on what the Program does.

  2. You may copy and distribute verbatim copies of the Program's
     source code as you receive it, in any medium, provided that you
     conspicuously and appropriately publish on each copy an appropriate
     copyright notice and disclaimer of warranty; keep intact all the
     notices that refer to this License and to the absence of any
     warranty; and give any other recipients of the Program a copy of
     this License along with the Program.

     You may charge a fee for the physical act of transferring a copy,
     and you may at your option offer warranty protection in exchange
     for a fee.

  3. You may modify your copy or copies of the Program or any portion
     of it, thus forming a work based on the Program, and copy and
     distribute such modifications or work under the terms of Section 1
     above, provided that you also meet all of these conditions:

       a. You must cause the modified files to carry prominent notices
          stating that you changed the files and the date of any change.

       b. You must cause any work that you distribute or publish, that
          in whole or in part contains or is derived from the Program
          or any part thereof, to be licensed as a whole at no charge
          to all third parties under the terms of this License.

       c. If the modified program normally reads commands interactively
          when run, you must cause it, when started running for such
          interactive use in the most ordinary way, to print or display
          an announcement including an appropriate copyright notice and
          a notice that there is no warranty (or else, saying that you
          provide a warranty) and that users may redistribute the
          program under these conditions, and telling the user how to
          view a copy of this License.  (Exception: if the Program
          itself is interactive but does not normally print such an
          announcement, your work based on the Program is not required
          to print an announcement.)

     These requirements apply to the modified work as a whole.  If
     identifiable sections of that work are not derived from the
     Program, and can be reasonably considered independent and separate
     works in themselves, then this License, and its terms, do not
     apply to those sections when you distribute them as separate
     works.  But when you distribute the same sections as part of a
     whole which is a work based on the Program, the distribution of
     the whole must be on the terms of this License, whose permissions
     for other licensees extend to the entire whole, and thus to each
     and every part regardless of who wrote it.

     Thus, it is not the intent of this section to claim rights or
     contest your rights to work written entirely by you; rather, the
     intent is to exercise the right to control the distribution of
     derivative or collective works based on the Program.

     In addition, mere aggregation of another work not based on the
     Program with the Program (or with a work based on the Program) on
     a volume of a storage or distribution medium does not bring the
     other work under the scope of this License.

  4. You may copy and distribute the Program (or a work based on it,
     under Section 2) in object code or executable form under the terms
     of Sections 1 and 2 above provided that you also do one of the
     following:

       a. Accompany it with the complete corresponding machine-readable
          source code, which must be distributed under the terms of
          Sections 1 and 2 above on a medium customarily used for
          software interchange; or,

       b. Accompany it with a written offer, valid for at least three
          years, to give any third party, for a charge no more than your
          cost of physically performing source distribution, a complete
          machine-readable copy of the corresponding source code, to be
          distributed under the terms of Sections 1 and 2 above on a
          medium customarily used for software interchange; or,

       c. Accompany it with the information you received as to the offer
          to distribute corresponding source code.  (This alternative is
          allowed only for noncommercial distribution and only if you
          received the program in object code or executable form with
          such an offer, in accord with Subsection b above.)

     The source code for a work means the preferred form of the work for
     making modifications to it.  For an executable work, complete
     source code means all the source code for all modules it contains,
     plus any associated interface definition files, plus the scripts
     used to control compilation and installation of the executable.
     However, as a special exception, the source code distributed need
     not include anything that is normally distributed (in either
     source or binary form) with the major components (compiler,
     kernel, and so on) of the operating system on which the executable
     runs, unless that component itself accompanies the executable.

     If distribution of executable or object code is made by offering
     access to copy from a designated place, then offering equivalent
     access to copy the source code from the same place counts as
     distribution of the source code, even though third parties are not
     compelled to copy the source along with the object code.

  5. You may not copy, modify, sublicense, or distribute the Program
     except as expressly provided under this License.  Any attempt
     otherwise to copy, modify, sublicense or distribute the Program is
     void, and will automatically terminate your rights under this
     License.  However, parties who have received copies, or rights,
     from you under this License will not have their licenses
     terminated so long as such parties remain in full compliance.

  6. You are not required to accept this License, since you have not
     signed it.  However, nothing else grants you permission to modify
     or distribute the Program or its derivative works.  These actions
     are prohibited by law if you do not accept this License.
     Therefore, by modifying or distributing the Program (or any work
     based on the Program), you indicate your acceptance of this
     License to do so, and all its terms and conditions for copying,
     distributing or modifying the Program or works based on it.

  7. Each time you redistribute the Program (or any work based on the
     Program), the recipient automatically receives a license from the
     original licensor to copy, distribute or modify the Program
     subject to these terms and conditions.  You may not impose any
     further restrictions on the recipients' exercise of the rights
     granted herein.  You are not responsible for enforcing compliance
     by third parties to this License.

  8. If, as a consequence of a court judgment or allegation of patent
     infringement or for any other reason (not limited to patent
     issues), conditions are imposed on you (whether by court order,
     agreement or otherwise) that contradict the conditions of this
     License, they do not excuse you from the conditions of this
     License.  If you cannot distribute so as to satisfy simultaneously
     your obligations under this License and any other pertinent
     obligations, then as a consequence you may not distribute the
     Program at all.  For example, if a patent license would not permit
     royalty-free redistribution of the Program by all those who
     receive copies directly or indirectly through you, then the only
     way you could satisfy both it and this License would be to refrain
     entirely from distribution of the Program.

     If any portion of this section is held invalid or unenforceable
     under any particular circumstance, the balance of the section is
     intended to apply and the section as a whole is intended to apply
     in other circumstances.

     It is not the purpose of this section to induce you to infringe any
     patents or other property right claims or to contest validity of
     any such claims; this section has the sole purpose of protecting
     the integrity of the free software distribution system, which is
     implemented by public license practices.  Many people have made
     generous contributions to the wide range of software distributed
     through that system in reliance on consistent application of that
     system; it is up to the author/donor to decide if he or she is
     willing to distribute software through any other system and a
     licensee cannot impose that choice.

     This section is intended to make thoroughly clear what is believed
     to be a consequence of the rest of this License.

  9. If the distribution and/or use of the Program is restricted in
     certain countries either by patents or by copyrighted interfaces,
     the original copyright holder who places the Program under this
     License may add an explicit geographical distribution limitation
     excluding those countries, so that distribution is permitted only
     in or among countries not thus excluded.  In such case, this
     License incorporates the limitation as if written in the body of
     this License.

 10. The Free Software Foundation may publish revised and/or new
     versions of the General Public License from time to time.  Such
     new versions will be similar in spirit to the present version, but
     may differ in detail to address new problems or concerns.

     Each version is given a distinguishing version number.  If the
     Program specifies a version number of this License which applies
     to it and "any later version", you have the option of following
     the terms and conditions either of that version or of any later
     version published by the Free Software Foundation.  If the Program
     does not specify a version number of this License, you may choose
     any version ever published by the Free Software Foundation.

 11. If you wish to incorporate parts of the Program into other free
     programs whose distribution conditions are different, write to the
     author to ask for permission.  For software which is copyrighted
     by the Free Software Foundation, write to the Free Software
     Foundation; we sometimes make exceptions for this.  Our decision
     will be guided by the two goals of preserving the free status of
     all derivatives of our free software and of promoting the sharing
     and reuse of software generally.

                                NO WARRANTY
 12. BECAUSE THE PROGRAM IS LICENSED FREE OF CHARGE, THERE IS NO
     WARRANTY FOR THE PROGRAM, TO THE EXTENT PERMITTED BY APPLICABLE
     LAW.  EXCEPT WHEN OTHERWISE STATED IN WRITING THE COPYRIGHT
     HOLDERS AND/OR OTHER PARTIES PROVIDE THE PROGRAM "AS IS" WITHOUT
     WARRANTY OF ANY KIND, EITHER EXPRESSED OR IMPLIED, INCLUDING, BUT
     NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND
     FITNESS FOR A PARTICULAR PURPOSE.  THE ENTIRE RISK AS TO THE
     QUALITY AND PERFORMANCE OF THE PROGRAM IS WITH YOU.  SHOULD THE
     PROGRAM PROVE DEFECTIVE, YOU ASSUME THE COST OF ALL NECESSARY
     SERVICING, REPAIR OR CORRECTION.

 13. IN NO EVENT UNLESS REQUIRED BY APPLICABLE LAW OR AGREED TO IN
     WRITING WILL ANY COPYRIGHT HOLDER, OR ANY OTHER PARTY WHO MAY
     MODIFY AND/OR REDISTRIBUTE THE PROGRAM AS PERMITTED ABOVE, BE
     LIABLE TO YOU FOR DAMAGES, INCLUDING ANY GENERAL, SPECIAL,
     INCIDENTAL OR CONSEQUENTIAL DAMAGES ARISING OUT OF THE USE OR
     INABILITY TO USE THE PROGRAM (INCLUDING BUT NOT LIMITED TO LOSS OF
     DATA OR DATA BEING RENDERED INACCURATE OR LOSSES SUSTAINED BY YOU
     OR THIRD PARTIES OR A FAILURE OF THE PROGRAM TO OPERATE WITH ANY
     OTHER PROGRAMS), EVEN IF SUCH HOLDER OR OTHER PARTY HAS BEEN
     ADVISED OF THE POSSIBILITY OF SUCH DAMAGES.

                      END OF TERMS AND CONDITIONS
How to Apply These Terms to Your New Programs
=============================================

If you develop a new program, and you want it to be of the greatest
possible use to the public, the best way to achieve this is to make it
free software which everyone can redistribute and change under these
terms.

   To do so, attach the following notices to the program.  It is safest
to attach them to the start of each source file to most effectively
convey the exclusion of warranty; and each file should have at least
the "copyright" line and a pointer to where the full notice is found.

     ONE LINE TO GIVE THE PROGRAM'S NAME AND AN IDEA OF WHAT IT DOES.
     Copyright (C) 19YY  NAME OF AUTHOR

     This program is free software; you can redistribute it and/or
     modify it under the terms of the GNU General Public License
     as published by the Free Software Foundation; either version 2
     of the License, or (at your option) any later version.

     This program is distributed in the hope that it will be useful,
     but WITHOUT ANY WARRANTY; without even the implied warranty of
     MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
     GNU General Public License for more details.

     You should have received a copy of the GNU General Public License
     along with this program; if not, write to the Free Software
     Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   Also add information on how to contact you by electronic and paper
mail.

   If the program is interactive, make it output a short notice like
this when it starts in an interactive mode:

     Gnomovision version 69, Copyright (C) 19YY NAME OF AUTHOR
     Gnomovision comes with ABSOLUTELY NO WARRANTY; for details
     type `show w'.  This is free software, and you are welcome
     to redistribute it under certain conditions; type `show c'
     for details.

   The hypothetical commands `show w' and `show c' should show the
appropriate parts of the General Public License.  Of course, the
commands you use may be called something other than `show w' and `show
c'; they could even be mouse-clicks or menu items--whatever suits your
program.

   You should also get your employer (if you work as a programmer) or
your school, if any, to sign a "copyright disclaimer" for the program,
if necessary.  Here is a sample; alter the names:

     Yoyodyne, Inc., hereby disclaims all copyright
     interest in the program `Gnomovision'
     (which makes passes at compilers) written
     by James Hacker.

     SIGNATURE OF TY COON, 1 April 1989
     Ty Coon, President of Vice

   This General Public License does not permit incorporating your
program into proprietary programs.  If your program is a subroutine
library, you may consider it more useful to permit linking proprietary
applications with the library.  If this is what you want to do, use the
GNU Library General Public License instead of this License.


File: april.info,  Node: Concept index,  Next: Function index,  Prev: Notes for April v4 programmers,  Up: Top

Concept index
*************

 [index ]
* Menu:

* _ in lhs of assignment:                Assignment statement. (line 45)
* _ in lhs of declaration:               Variable declaration statement.
                                                               (line 48)
* _ pattern:                             Anonymous variable pattern.
                                                               (line  6)
* Absolute value:                        Absolute value.       (line  6)
* Access click counter value:            Access click counter value.
                                                               (line  6)
* Access current clicks:                 Access current clicks.
                                                               (line  6)
* Access size of an April string:        StringSize.           (line  6)
* Access text of an April string:        StringText.           (line  6)
* accessing elements of a record.:       Dot expression.       (line  6)
* Accessing elements of strings:         Accessing elements of strings.
                                                               (line  6)
* Adding elements to lists lists:        List cons.            (line  6)
* Addition of numbers <1>:               Integer Addition.     (line  6)
* Addition of numbers:                   Addition.             (line  6)
* Allocate a new April pair:             allocatePair.         (line  6)
* Allocate a new April string <1>:       allocateString.       (line  6)
* Allocate a new April string:           allocateCString.      (line  6)
* Allocate a new April tuple:            allocateTpl.          (line  6)
* Allocate a sub-string of a April string: allocateSubString.  (line  6)
* Anonymous variable pattern:            Anonymous variable pattern.
                                                               (line  6)
* any pattern:                           any pattern.          (line  6)
* any type:                              Any values revisited. (line  6)
* any values:                            any type.             (line  6)
* Appending lists:                       <>.                   (line  6)
* Apply function to elements of a list:  List map.             (line  6)
* April communication:                   April communications. (line  6)
* April data values and types:           Data values and types.
                                                               (line  6)
* April environment primitives:          Environment.          (line  6)
* April formal grammar:                  April grammar.        (line  6)
* April grammar rules:                   April grammar rules.  (line  6)
* April modules:                         April modules.        (line  6)
* April plug-ins:                        Extending the April system.
                                                               (line  6)
* April presentation syntax:             Presentation syntax.  (line  6)
* April processes:                       Processes.            (line  6)
* April token syntax:                    Token syntax.         (line  6)
* APRIL_DIR environment variable:        Environment variables.
                                                               (line 12)
* Arc sine function:                     asin.                 (line  6)
* Arithmetic and math functions:         Arithmetic functions. (line  6)
* Arithmetic negation:                   Negation.             (line  6)
* Assigning to free variables:           Procedures and free variables.
                                                               (line 56)
* Assignment statement:                  Assignment statement. (line  6)
* Asynchronous stream oriented input/output: Stream input & output.
                                                               (line  6)
* auditTrail message attribute:          auditTrail message attribute.
                                                               (line  6)
* automatic run-time exception:          onerror statement.    (line 14)
* bagof abstraction operator:            bagof abstraction.    (line  6)
* Basic string functions:                Basic string functions.
                                                               (line  6)
* Basic symbol processing:               Basic symbol processing.
                                                               (line  6)
* Bitwise integer and:                   Bitwise and.          (line  6)
* Bitwise integer exclusive or:          Bitwise xor.          (line  6)
* Bitwise integer left shift:            Logical left shift.   (line  6)
* Bitwise integer negation:              Ones complement.      (line  6)
* Bitwise integer or:                    Bitwsie or.           (line  6)
* Bitwise integer right shift:           Logical right shift.  (line  6)
* Block file input <1>:                  inbytes.              (line  6)
* Block file input:                      inchars.              (line  6)
* building plug-in modules:              Defining a plug-in module.
                                                               (line  6)
* case expression:                       case expression.      (line  6)
* case expression as a function call:    Case expression as a function call.
                                                               (line  6)
* case statement:                        case statement.       (line  6)
* case statement as a procedure call:    Case statement as a procedure call.
                                                               (line  6)
* Change current directory:              fcd.                  (line  6)
* Change working directory:              fcd.                  (line  6)
* Changed functions:                     Changed functions.    (line  6)
* char literal:                          char type.            (line  6)
* Character handling:                    Character handling.   (line  6)
* Character matching:                    Character matching.   (line  6)
* Characters:                            Characters and strings.
                                                               (line  6)
* Clausal form of procedures:            Procedure clause.     (line  6)
* Close a file:                          fclose.               (line  6)
* Code verification:                     Code verification.    (line  6)
* Collapse string values into single string: collapse.         (line  6)
* collect elements into a list:          collect expression.   (line  6)
* collect elements into a set:           setof expression.     (line  6)
* Command line arguments:                command_line.         (line  6)
* Command line arguments to programs:    Command line arguments to programs.
                                                               (line  6)
* Comments in programs:                  Comments in programs. (line  6)
* Communications infrastructure:         Communications infrastructure.
                                                               (line  6)
* Communications manager:                Communications manager.
                                                               (line  6)
* Comparisons:                           Comparisons.          (line  6)
* Compound statements:                   Compound statements.  (line  6)
* Compound types:                        Compound types.       (line  6)
* Compute character from code:           charOf.               (line  6)
* Compute full name of file:             ffilename.            (line  6)
* Compute host name from IP address:     iptohost.             (line  6)
* compute integer and fraction part:     modf.                 (line  6)
* Compute IP addresses associated with a host name: hosttoip.  (line  6)
* Compute mantissae and exponent of f.p. number: frexp.        (line  6)
* Compute unicode code of character:     charCode.             (line  6)
* Computing fresh types:                 Type abstraction and reification.
                                                               (line  6)
* Computing the type of a program fragment: Type derivation.   (line  6)
* concatenate strings:                   concatenate strings.  (line  6)
* Conditional expression:                conditional expression.
                                                               (line  6)
* Conditional statement:                 Conditional statement.
                                                               (line  6)
* Conjunctions of set generating expressions: && abstraction condition.
                                                               (line  6)
* Connect to the SCS server:             scsConnectAs.         (line  6)
* Connect to the SCS server anonymously: scsConnect.           (line  6)
* Connecting to an external debugger:    Connecting to an external debugger.
                                                               (line  6)
* Constrained execution of a statement:  Constrained execution of a statement.
                                                               (line  6)
* constrained execution of expressions:  Constrained execution of a statement.
                                                               (line 33)
* Construct a list of integers <1>:      iota.                 (line  6)
* Construct a list of integers:          ...                   (line  6)
* Constructing values in a plug-in function: Returning values from a plug-in function.
                                                               (line 38)
* constructor functions, type of:        Type of constructor function expressions.
                                                               (line  6)
* Controlling CPU time:                  CPU time.             (line  6)
* Conventions for file names:            File names.           (line  6)
* Convert a date record into a raw time: datetotime.           (line  6)
* Convert a string into a symbol:        implode.              (line  6)
* Convert a string into ASCII list:      ascii.                (line  6)
* Convert a symbol into a string:        explode.              (line  6)
* Convert days to time values:           days.                 (line  6)
* Convert hours to time values:          hours.                (line  6)
* Convert minutes to time values:        mins.                 (line  6)
* Convert raw time into a date record:   timetogmt.            (line  6)
* Convert raw time into a date value:    timetodate.           (line  6)
* Converting a number to a single character symbol: Converting a number to a single character symbol.
                                                               (line  6)
* Converting a single character symbol to a number: Converting a single character symbol to a number.
                                                               (line  6)
* Converting and manipulating characters: Character handling.  (line  6)
* Converting from a list of symbols to a string: Converting from a list of symbols to a string.
                                                               (line  6)
* Converting from a string to a list of symbols: Converting from a string to a list of symbols.
                                                               (line  6)
* Core April expressions:                Core April expressions.
                                                               (line  6)
* Core April patterns:                   Core April patterns.  (line  6)
* Core April programs:                   Core April programs.  (line  6)
* Core April statements:                 Core April statements.
                                                               (line  6)
* Core April syntax:                     Core April syntax.    (line  6)
* Core April types:                      Core April types.     (line  6)
* Counting abstraction:                  counting abstraction. (line  6)
* Create a new directory:                fmkdir.               (line  6)
* Create sub file-manager:               sub_manager.          (line  6)
* Creating a new click counter:          Create a new Click Counter.
                                                               (line  6)
* Creator of current process:            creator.              (line  6)
* Cube root function:                    cbrt.                 (line  6)
* Current directory <1>:                 fpwd.                 (line  6)
* Current directory:                     fcd.                  (line  6)
* Current process handle:                self.                 (line  6)
* Data value equality <1>:               ==.                   (line  6)
* Data value equality:                   !=.                   (line  6)
* Data value less than test <1>:         >.                    (line  6)
* Data value less than test <2>:         <.                    (line  6)
* Data value less than test <3>:         >=.                   (line  6)
* Data value less than test:             <=.                   (line  6)
* Date and Time:                         Date and time.        (line  6)
* date type:                             date type.            (line  6)
* Debugging April programs:              Debugging April programs.
                                                               (line  6)
* Debugging messages:                    Debugging messages.   (line  6)
* declaring variables:                   Variable declaration. (line  6)
* decode n encoded term string:          sdecode.              (line  6)
* Define function with equations:        Equations.            (line  6)
* Defining a plug-in module:             Defining a plug-in module.
                                                               (line  6)
* Defining an operator grammar:          Defining an operator grammar.
                                                               (line  6)
* Defining new types:                    User defined type definition.
                                                               (line  6)
* Definite Clause Grammars:              Operator precedence grammar.
                                                               (line  6)
* Delay for some time:                   delay.                (line  6)
* Delete a file:                         frm.                  (line  6)
* Deprecated functions:                  Deprecated functions. (line  6)
* Directory list:                        fls.                  (line  6)
* Disambiguating infix and postfix:      Disambiguating infix and postfix.
                                                               (line  6)
* Disjunctions of set generating expressions: || abstraction condition.
                                                               (line  6)
* Division of numbers <1>:               Integer Division.     (line  6)
* Division of numbers <2>:               Division.             (line  6)
* Division of numbers <3>:               Integer quotient.     (line  6)
* Division of numbers:                   Remainder.            (line  6)
* dot expression:                        Dot expression.       (line  6)
* dot statement:                         dot statement.        (line  6)
* element generating condition:          element generating condition.
                                                               (line  6)
* Encapsulate value pattern:             any pattern.          (line  6)
* encode a value into a string:          sencode.              (line  6)
* Encoded Input/Output:                  Encoded Input/Output. (line  6)
* End of file test:                      eof.                  (line  6)
* enumerated symbols:                    User defined type definition.
                                                               (line 16)
* Environment variables:                 Environment variables.
                                                               (line  6)
* Equality of data values <1>:           !=.                   (line  6)
* Equality of data values:               ==.                   (line  6)
* error type <1>:                        onerror statement.    (line 40)
* error type <2>:                        error type.           (line  6)
* error type:                            onerror expression.   (line 22)
* Establish a TCP connection:            tcp_connect.          (line  6)
* Establish a TCP server:                tcp_server.           (line  6)
* exception expression:                  exception expression. (line  6)
* exception statement:                   exception statement.  (line  6)
* exception, run-time:                   onerror statement.    (line 14)
* Execute a Unix sub-process:            exec.                 (line  6)
* Exit April system:                     exit.                 (line  6)
* Exponential function:                  exp.                  (line  6)
* expressions, recovering from run-time errors: onerror expression.
                                                               (line  6)
* Extending April with plug-in modules:  Extending the April system.
                                                               (line  6)
* Extract end elements <1>:              back.                 (line  6)
* Extract end elements:                  tail.                 (line  6)
* Extract front elements:                front.                (line  6)
* Extract head element:                  head.                 (line  6)
* Extract nth char from a string as ASCII: nthascii.           (line  6)
* f abstraction operator:                counting abstraction. (line  6)
* File input, byte block read:           inbytes.              (line  6)
* File input, string read:               inchars.              (line  6)
* File manager process:                  File manager.         (line  6)
* File modes:                            fopen.                (line  6)
* File opening mode:                     File open mode.       (line  6)
* File permission:                       File permission.      (line  6)
* File positioning:                      File positioning.     (line  6)
* File renaming:                         fmv.                  (line  6)
* File system access modes:              File system access modes.
                                                               (line  6)
* Files and Directories:                 Files and Directories.
                                                               (line  6)
* Files and file descriptors:            Files and file descriptors.
                                                               (line  6)
* Fixed width string pattern:            Fixed width string pattern.
                                                               (line  6)
* Floating point power raise:            ldexp.                (line  6)
* Flush output from buffered files:      fflush.               (line  6)
* for statement:                         for statement.        (line  6)
* Fork a publically named sub-process:   Spawning with a public name.
                                                               (line  6)
* formal parameters of functions:        Equations.            (line 34)
* formal parameters of procedures:       Procedure clause.     (line 35)
* Format a string from an integer:       int2str.              (line  6)
* Format of an april program:            Standard April programs.
                                                               (line  6)
* Format of April expressions:           Expressions.          (line  6)
* Format of April statements:            Statements.           (line  6)
* Format value into string:              strof.                (line  6)
* Free variables:                        Procedures and free variables.
                                                               (line  6)
* Function application:                  Function application. (line  6)
* function application expression:       Function application expression.
                                                               (line  6)
* Function declaration:                  Function declaration. (line  6)
* Function equation:                     Equations.            (line  6)
* Function expressions:                  Function expressions. (line  6)
* function type:                         function type.        (line  6)
* Function union:                        Function union.       (line  6)
* Functions and procedures:              Functions and procedures.
                                                               (line  6)
* Functions no longer supported:         Deprecated functions. (line  6)
* Functions with changed semantics:      Changed functions.    (line  6)
* Garbage collection and plugh-in modules: Protecting pointers.
                                                               (line  6)
* General power function:                pow.                  (line  6)
* Generalization of types:               Type abstraction and reification.
                                                               (line  6)
* Generate random integer function:      irand.                (line  6)
* Generate random number function:       rand.                 (line  6)
* generating list elements in an abstraction expression: element generating condition.
                                                               (line  6)
* Get environment variable:              getenv.               (line  6)
* Get file permissions:                  fmode.                (line  6)
* Get file status:                       fstat.                (line  6)
* Get file type:                         ffiletype.            (line  6)
* Grammar rules:                         Operator precedence grammar.
                                                               (line  6)
* Greater than or equal test:            >=.                   (line  6)
* Greater than test:                     >.                    (line  6)
* guarded pattern:                       Guarded pattern.      (line  6)
* Halt execution of April:               halt.                 (line  6)
* handle of current process:             self.                 (line  6)
* handle pattern:                        handle pattern.       (line  6)
* handle values:                         handle type.          (line  6)
* Higher-level notation for formatting values: Formatting values.
                                                               (line  6)
* home directory:                        File names.           (line 14)
* Hostnames and host addresses:          Hostnames and host addresses.
                                                               (line  6)
* How data streams are found:            URLs and file systems.
                                                               (line  6)
* How operator declarations are interpreted: How operator declarations are interpreted.
                                                               (line  6)
* How the communications manager works:  How the communications manager works.
                                                               (line  6)
* How values are encoded in messages:    Encoded term format.  (line  6)
* How values are represented in encoded terms: representation of values.
                                                               (line  6)
* Hyperbolic cosine function:            cosh.                 (line  6)
* Hyperbolic sine function:              sinh.                 (line  6)
* Hyperbolic tangent function:           tanh.                 (line  6)
* Identification Functions:              Identification functions.
                                                               (line  6)
* Identity of the commserver:            commserver.           (line  6)
* Identity of the processes file manager process: file_manager.
                                                               (line  6)
* if-then-else statements:               Conditional statement.
                                                               (line  6)
* importing a plug-in module:            Using a plug-in module.
                                                               (line  6)
* Importing more than one module in a program: Importing multiple modules.
                                                               (line  6)
* Importing programs from modules:       Importing programs from modules.
                                                               (line  6)
* Including other source files:          Including other source files.
                                                               (line  6)
* Index element from a list:             #.                    (line  6)
* Inequality:                            !=.                   (line  6)
* Input and output primitives:           Input and output.     (line  6)
* Integer ceiling:                       Integer ceiling.      (line  6)
* Integer floor:                         Integer floor.        (line  6)
* Integer rounding:                      Truncate to Integer.  (line  6)
* Integral test:                         Integral test.        (line  6)
* Introducing new names for types:       Type renaming.        (line  6)
* IntVal plug-in support macro:          IntVal.               (line  6)
* Inverse cosine function:               acos.                 (line  6)
* Inverse hyperbolic cosine function:    acosh.                (line  6)
* Inverse hyperbolic sine function:      asinh.                (line  6)
* Inverse hyperbolic tangent function:   atanh.                (line  6)
* Inverse tangent function:              atan.                 (line  6)
* Invoke Unix shell:                     shell.                (line  6)
* Join strings together:                 concatenate strings.  (line  6)
* Join up lists of strings:              collapse.             (line  6)
* Kill process:                          kill.                 (line  6)
* Labelled statement:                    Labelled statement.   (line  6)
* labelled type pattern:                 labelled type pattern.
                                                               (line  6)
* labelled type, type of:                Type of constructor function expressions.
                                                               (line  6)
* lazy generation of elements:           generator abstraction.
                                                               (line  6)
* leaseTime message attribute:           leaseTime message attribute.
                                                               (line  6)
* leave statement:                       leave statement.      (line  6)
* Length of a list:                      listlen.              (line  6)
* Length of a string:                    strlen.               (line  6)
* Less than or equal test:               <=.                   (line  6)
* Less than test:                        <.                    (line  6)
* List and other compound patterns:      List and other compound patterns.
                                                               (line  6)
* List and set handling functions:       Lists and sets.       (line  6)
* List append pattern:                   Append pattern.       (line  6)
* List cardinality:                      listlen.              (line  6)
* List files in directory:               fls.                  (line  6)
* list generating condition:             element generating condition.
                                                               (line  6)
* List membership test:                  in.                   (line  6)
* List Operations:                       List operations.      (line  6)
* List pattern:                          Append pattern.       (line  6)
* list pattern:                          List pattern.         (line  6)
* List processing in plug-in functions:  Returning values from a plug-in function.
                                                               (line  6)
* list syntax:                           list syntax.          (line  6)
* List values:                           list type.            (line  6)
* Lists and patterns:                    Pattern based operations on lists.
                                                               (line  6)
* Lists and set abstractions:            Lists and set abstractions.
                                                               (line  6)
* Literal symbol pattern type:           Literal symbol pattern type.
                                                               (line  6)
* location of host computer:             location.             (line  6)
* Logarithm base 10 function:            log10.                (line  6)
* Logical conjunction:                   &&.                   (line  6)
* Logical connectives:                   Logical connectives.  (line  6)
* Logical disjunction:                   ||.                   (line  6)
* Logical negation:                      !.                    (line  6)
* logical values:                        logical type.         (line  6)
* macros:                                Macro language.       (line  6)
* Managing access to the communications system: Communications manager.
                                                               (line  6)
* Managing access to the file system:    File manager.         (line  6)
* Map function over elements of a list:  List map.             (line  6)
* matching numbers:                      number pattern.       (line  6)
* Mathematical Functions:                Mathematical functions.
                                                               (line  6)
* Message attribute type:                Message attribute type.
                                                               (line  6)
* Message attributes:                    Message attributes.   (line  6)
* message forwarding:                    >>>.                  (line  6)
* Message sending:                       Sending messages.     (line  6)
* Message streams <1>:                   repeat until.         (line  6)
* Message streams:                       Receiving messages.   (line 11)
* Message terminated message stream:     repeat until.         (line  6)
* Miscellaneous arithmetic functions:    Miscellaneous arithmetic functions.
                                                               (line  6)
* Modify a click counter:                Modify a click counter.
                                                               (line  6)
* Modifying message attributes:          Modifying message attributes.
                                                               (line  6)
* Module files:                          April modules.        (line  6)
* Move a file:                           fmv.                  (line  6)
* Moving within files:                   File positioning.     (line  6)
* Multiplication of numbers <1>:         Multiplication.       (line  6)
* Multiplication of numbers:             Integer Multiplication.
                                                               (line  6)
* Name of host machine:                  host.                 (line  6)
* Natural exponent function:             exp.                  (line  6)
* Natural logarithm function:            log.                  (line  6)
* Negated set abtraction condition:      ! abstraction condition.
                                                               (line  6)
* Negation of numbers:                   Negation.             (line  6)
* New functions:                         New functions.        (line  6)
* Null statement:                        Null statement.       (line  6)
* Number of days:                        days.                 (line  6)
* Number of hours:                       hours.                (line  6)
* Number of minutes:                     mins.                 (line  6)
* Number of seconds:                     secs.                 (line  6)
* number pattern:                        number pattern.       (line  6)
* number values:                         number type.          (line  6)
* off-board communication:               Remote communication. (line  6)
* onerror statement:                     onerror statement.    (line  6)
* Open a file:                           fopen.                (line  6)
* Open a pipe connection:                popen.                (line  6)
* Open a stream:                         sio_open.             (line  6)
* Open a stream TCP connection:          sio_connect.          (line  6)
* Open a stream TCP server:              sio_server.           (line  6)
* Opening and closing files:             Opening and closing files.
                                                               (line  6)
* Opening file mode:                     File open mode.       (line  6)
* Operator precedence grammar:           Operator precedence grammar.
                                                               (line  6)
* Operator priorities:                   Operator priorities.  (line  6)
* operator priority:                     Defining an operator grammar.
                                                               (line 29)
* operators:                             Operators.            (line  6)
* Output buffering:                      fflush.               (line  6)
* Parameters in user type definitions:   Type parameters.      (line  6)
* parent of this process:                creator.              (line  6)
* Pattern assignment:                    Assignment statement. (line 17)
* Pattern based operations on lists:     Pattern based operations on lists.
                                                               (line  6)
* Pattern based selection of a set:      select elements.      (line  6)
* Patterns and pattern matching:         Patterns.             (line  6)
* Post a message on own message queue:   self post.            (line  6)
* prepending characters to strings:      string character prepend.
                                                               (line  6)
* Primitive patterns:                    Primitive patterns.   (line  6)
* Primitive statements:                  Primitive statements. (line  6)
* Primitive types:                       Primitive types.      (line  6)
* Privileged processes:                  Privileged processes. (line  6)
* Procedure application:                 Procedure application.
                                                               (line  6)
* Procedure Call statement:              Procedure Call statement.
                                                               (line  6)
* Procedure clause:                      Procedure clause.     (line  6)
* Procedure declaration:                 Procedure declaration.
                                                               (line  6)
* Procedure expressions:                 Procedure expressions.
                                                               (line  6)
* procedure type:                        procedure type.       (line  6)
* Procedure union:                       Procedure union.      (line  6)
* Procedures and free variables:         Procedures and free variables.
                                                               (line  6)
* Processes and process control:         Processes and process control.
                                                               (line  6)
* Program Control:                       Program control.      (line  6)
* Protecting pointers from garbage collection: Protecting pointers.
                                                               (line  6)
* Quantified types:                      Quantified types.     (line  6)
* Re-format a string:                    strpad.               (line  6)
* Read a block of bytes:                 inbytes.              (line  6)
* Read a block string:                   inchars.              (line  6)
* Read a byte as ASCII:                  inascii.              (line  6)
* Read a data value in encoded form:     fdecode.              (line  6)
* Read a single character:               inchar.               (line  6)
* Read a text line:                      inline.               (line  6)
* read-only variable:                    Variable declaration. (line 47)
* Reading and writing to files:          String oriented input/output.
                                                               (line  6)
* receiptRequest message attribute:      receiptRequest message attribute.
                                                               (line  6)
* Receiving messages:                    Receiving messages.   (line  6)
* Record pattern:                        record pattern.       (line  6)
* Record values:                         record type.          (line  6)
* Records of functions and procedures:   Semantics of modules. (line  6)
* recovering from run-time errors:       onerror statement.    (line 14)
* recovering from run-time errors in expressions: onerror expression.
                                                               (line  6)
* Reduce a list function:                List reduction.       (line  6)
* Remove a directory:                    frmdir.               (line  6)
* Remove elements from a set:            reject elements.      (line  6)
* Rename a file:                         fmv.                  (line  6)
* replyTo message attribute:             replyTo message attribute.
                                                               (line  6)
* Report current directory:              fpwd.                 (line  6)
* Report current file position:          ftell.                (line  6)
* Report current time:                   now.                  (line  6)
* Report environment variables:          envir.                (line  6)
* Report home directory:                 fhome.                (line  6)
* Report status of process:              state.                (line  6)
* Report system clock:                   ticks.                (line  6)
* Report today's date:                   today.                (line  6)
* Reporting errors from a plug-in function: Reporting errors from a plug-in function.
                                                               (line  6)
* Resource limited execution of programs: Resource limited execution.
                                                               (line  6)
* Returning values from a plug-in function: Returning values from a plug-in function.
                                                               (line  6)
* scomms library:                        the scomms library.   (line  6)
* scope of labels:                       Labelled statement.   (line 16)
* Scope of type definition:              Scope of type definitions.
                                                               (line  6)
* scope of variables <1>:                Variable declaration. (line 10)
* scope of variables <2>:                Variable declaration statement.
                                                               (line 26)
* scope of variables:                    dot statement.        (line 14)
* scope of variables, in guarded patterns: Guarded pattern.    (line 15)
* scope of variables, in receive clauses: receive.             (line 40)
* scope of variables, in while statements: while statement.    (line 24)
* SCS server:                            the communications server.
                                                               (line  6)
* Seed generator function:               seed.                 (line  6)
* Semantics of modules:                  Semantics of modules. (line  6)
* send a message:                        >>.                   (line  6)
* set abstractions:                      Lists and set abstractions.
                                                               (line  6)
* Set file permissions:                  fchmod.               (line  6)
* Set file position:                     fseek.                (line  6)
* Set random number seed:                seed.                 (line  6)
* Set rejection:                         reject elements.      (line  6)
* Set selection:                         select elements.      (line  6)
* Set Unix environment variable:         setenv.               (line  6)
* setof abstraction operator:            setof abstraction.    (line  6)
* Sleep until some time:                 sleep.                (line  6)
* Sort list:                             sort.                 (line  6)
* Spawn a sub-process:                   spawn.                (line  6)
* Spawning with a different file manager: Spawning with a different file manager.
                                                               (line  6)
* Spawning with a public name:           Spawning with a public name.
                                                               (line  6)
* Special characters in file names:      File names.           (line  6)
* Split a string into related segments:  expand.               (line  6)
* Square root function:                  sqrt.                 (line  6)
* Standard April Types:                  Standard April Types. (line  6)
* Standard arithmetic functions:         Standard arithmetic functions.
                                                               (line  6)
* Standard debugging message type:       Standard debugging message type.
                                                               (line  6)
* Standard error codes:                  Standard error codes. (line  6)
* Standard error file stderr:            Standard files.       (line 21)
* Standard files:                        Standard files.       (line  6)
* Standard input file stdin:             Standard files.       (line 17)
* Standard operators in April:           Standard operators.   (line  6)
* Standard output file stdout:           Standard files.       (line 12)
* Standard processes:                    Standard processes.   (line  6)
* Statement sequence:                    Statement sequence.   (line  6)
* Statement, Constrained execution of:   Constrained execution of a statement.
                                                               (line  6)
* Statement,Type definition:             Type definitions.     (line  6)
* stream I/O:                            Stream input & output.
                                                               (line  6)
* streams of messages <1>:               repeat until.         (line  6)
* streams of messages:                   Receiving messages.   (line 11)
* String and Character handling:         String handling.      (line  6)
* String formatting:                     String formatting.    (line  6)
* String list membership test:           Membership test.      (line  6)
* String oriented input/output primitives: String oriented input/output.
                                                               (line  6)
* String partitioning:                   String partitioning.  (line  6)
* string pattern:                        string pattern.       (line  6)
* String patterns:                       String patterns.      (line  6)
* string values:                         string type.          (line  6)
* Strings:                               Characters and strings.
                                                               (line  6)
* Subtraction of numbers <1>:            Subtraction.          (line  6)
* Subtraction of numbers:                Integer Subtraction.  (line  6)
* Support for floating point numbers <1>: frexp.               (line  6)
* Support for floating point numbers <2>: modf.                (line  6)
* Support for floating point numbers:    ldexp.                (line  6)
* Support functions and macros:          Support functions and macros.
                                                               (line  6)
* Suspend process for a fixed time:      delay.                (line  6)
* symbol pattern:                        symbol pattern.       (line  6)
* symbol type:                           symbol type.          (line  6)
* Syntax errors:                         Disambiguating infix and postfix.
                                                               (line 54)
* Syntax of April comments:              Comments.             (line  6)
* Syntax of April identifiers:           Identifier syntax.    (line  6)
* Syntax of April numbers:               Number syntax.        (line  6)
* Syntax of primitive expressions:       Primitive syntax expressions.
                                                               (line  6)
* Syntax of programs:                    April syntax.         (line  6)
* TCP connection, establish a:           tcp_connect.          (line  6)
* TCP server, establish a:               tcp_server.           (line  6)
* TCP stream server:                     sio_server.           (line  6)
* TCP streams:                           sio_connect.          (line  6)
* Term equality:                         ==.                   (line  6)
* Term matching <1>:                     .=.                   (line  6)
* Term matching:                         Term matching.        (line  6)
* Test file is ready for I/O:            fready.               (line  6)
* Test for end of file:                  eof.                  (line  6)
* Test for integer:                      Integral test.        (line  6)
* Test for presence of file:             ffile.                (line  6)
* Test for process termination:          done.                 (line  6)
* Testing all elements in a set abstraction: forall abstraction condition.
                                                               (line  6)
* Testing for elements in a set abstraction: istrue abstraction condition.
                                                               (line  6)
* Tests and conditions:                  Tests and conditions. (line  6)
* The accept_debug message:              accept_debug message. (line  6)
* The assign_debug message:              assign_debug message. (line  6)
* The break_debug message:               break_debug message.  (line  6)
* The code verifier:                     verify code.          (line  6)
* The die_debug message:                 die_debug message.    (line  6)
* The difference between ^ and string%%: Formatting values.    (line 42)
* The entry_debug message:               entry_debug message.  (line  6)
* The error_debug message:               error message.        (line  6)
* The exit_debug message:                exit_debug message.   (line  6)
* The fail procedure:                    The fail procedure.   (line  6)
* The fork_debug message:                fork_debug message.   (line  6)
* The form of a function:                Function.             (line  6)
* The form of a procedure:               Procedure.            (line  6)
* The front_debug message:               front_debug message.  (line  6)
* The general iota function:             iota.                 (line  6)
* The handle data type:                  The handle data type. (line  6)
* The iota function:                     ...                   (line  6)
* The line_debug message:                line_debug message.   (line  6)
* The message receive statement:         receive.              (line  6)
* The return_debug message:              return_debug message. (line  6)
* The scope_debug message:               scope_debug message.  (line  6)
* The send_debug message:                send_debug message.   (line  6)
* The signature structure:               The signature structure.
                                                               (line  6)
* The standard April debugger:           The standard April debugger.
                                                               (line  6)
* The suspend_debug message:             suspend_debug.        (line  6)
* The type of an expression as a type:   type_of type function.
                                                               (line  6)
* The voidfun function:                  The voidfun function. (line  6)
* Theta expression:                      theta expression.     (line  6)
* theta expressions:                     programs and theta expressions.
                                                               (line  6)
* theta variables:                       theta variables.      (line  6)
* Timed message stream statement:        repeat alarm.         (line  6)
* Timing out on a message receive:       timeout.              (line  6)
* Token syntax:                          Token syntax.         (line  6)
* Trigonometric cosine function:         cos.                  (line  6)
* Trigonometric sine function:           sin.                  (line  6)
* Trigonometric tangent function:        tan.                  (line  6)
* try...onerror expression:              onerror expression.   (line  6)
* tuple pattern:                         Tuple pattern.        (line  6)
* Tuple values:                          tuple type.           (line  6)
* tuples of arity 1:                     allocateTpl.          (line 11)
* Type abstraction and reification:      Type abstraction and reification.
                                                               (line  6)
* type coercion expression:              type coercion.        (line  6)
* Type coercion to string compared to string formatting: Formatting values.
                                                               (line 42)
* Type definition, scope of:             Scope of type definitions.
                                                               (line  6)
* Type definition,statement:             Type definitions.     (line  6)
* Type derivation:                       Type derivation.      (line  6)
* Type equality:                         Equality of type expressions.
                                                               (line  6)
* Type generalization:                   Type abstraction and reification.
                                                               (line  6)
* Type reification:                      Type reification.     (line  6)
* Type signature representation:         Type signature representation.
                                                               (line  6)
* Type variables:                        Type variables.       (line  6)
* type, any:                             any type.             (line  6)
* type, char:                            char type.            (line  6)
* type, function:                        function type.        (line  6)
* type, handle:                          handle type.          (line  6)
* type, list:                            list type.            (line  6)
* type, logical:                         logical type.         (line  6)
* type, number:                          number type.          (line  6)
* type, procedure:                       procedure type.       (line  6)
* type, record:                          record type.          (line  6)
* type, renaming:                        Type definitions.     (line 22)
* Type, renaming:                        Type renaming.        (line  6)
* type, string:                          string type.          (line  6)
* type, tuple:                           tuple type.           (line  6)
* type,symbol:                           symbol type.          (line  6)
* type_of type function:                 type_of type function.
                                                               (line  6)
* Types and statements:                  Types and statements. (line  6)
* Types and type inferencing:            Types and type inferencing.
                                                               (line  6)
* Types as patterns:                     Types as patterns.    (line  6)
* Types of patterns:                     Types and patterns.   (line  6)
* Underlying semantics of message receive: Underlying semantics of message receive.
                                                               (line  6)
* Unicode compliance:                    Unicode compliance.   (line  6)
* Union of functions:                    Function union.       (line  6)
* Union of procedures:                   Procedure union.      (line  6)
* updating structures in a plug-in function: Returning values from a plug-in function.
                                                               (line 77)
* URLs and file systems:                 URLs and file systems.
                                                               (line  6)
* User defined type definition:          User defined type definition.
                                                               (line  6)
* User defined types:                    Type definitions.     (line  6)
* Using a plug-in module:                Using a plug-in module.
                                                               (line  6)
* using interface files to import plug-in modules: Using a plug-in module.
                                                               (line 20)
* Using interface specification files:   Using interface specification files.
                                                               (line  6)
* valof expression:                      valof expression.     (line  6)
* Value extraction:                      Value extraction.     (line  6)
* Variable declaration statement:        Variable declaration statement.
                                                               (line  6)
* variable, declaration:                 Variable declaration. (line  6)
* variable, read-only <1>:               Equations.            (line 34)
* variable, read-only <2>:               Variable declaration. (line 47)
* variable, read-only:                   Procedure clause.     (line 35)
* Wait for process termination:          waitfor.              (line  6)
* while statement:                       while statement.      (line  6)
* wild card variable in assignment:      Assignment statement. (line 45)
* wild card variable in variable declaration: Variable declaration statement.
                                                               (line 48)
* Write an April value in encoded form:  fencode.              (line  6)
* Write character string to file:        outchar.              (line  6)
* Writing infix expressions:             Infix expressions.    (line  6)
* Writing postfix expressions:           Postfix expressions.  (line  6)
* Writing prefix expressions:            Prefix expressions.   (line  6)
* {} statement:                          Null statement.       (line  6)

