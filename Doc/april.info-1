This is april.info, produced by makeinfo version 4.8 from april.texi.

INFO-DIR-SECTION Programming
START-INFO-DIR-ENTRY
* april: (april).		Agent programming language
END-INFO-DIR-ENTRY


File: april.info,  Node: Top,  Next: Copying,  Up: (dir)

Overview
********

This is the on-line Reference Manual for the `April' language, Version
5.0.0-beta-14.

   This manual offers an in-depth and complete description of the
`April' language. However, it is not a tutorial on the language, and
the order of presentation within the manual reflects that. For a more
tutorial introduction, the reader is referred to _Programming in April:
An Agent Process Interaction Language_ (by F.G. McCabe and K.L. Clark).
For a compact description of the facilities and features of `April' the
reader is referred to the _April Pocket Reference Guide_. In addition,
see `http://www.nar.fujitsulabs.com'.

   (C) 1994-2004 Imperial College and F.G. McCabe

   This program is free software; you can redistribute it and/or modify
it under the terms of the GNU General Public License as published by
the Free Software Foundation; either version 2 of the License, or (at
your option) any later version.

   This program is distributed in the hope that it will be useful, but
WITHOUT ANY WARRANTY; without even the implied warranty of
MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
General Public License for more details.

   You should have received a copy of the GNU General Public License
along with this program; if not, write to the Free Software Foundation,
Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

   For a more complete description of the licence terms under which this
software may be used *note Copying::.

   All rights reserved.  Last updated 16 April 2004

* Menu:

* Copying::                     Your rights and freedoms
* Compiling April programs::    Using the `April' compiler
* How to invoke April::         Getting started
* April programs::              Format of an `April' program
* Data values and types::       Legal `April' values and types
* Expressions::                 Format of valid `April' expressions
* Patterns::                    Format of `April' patterns
* Statements::                  Format of `April' patterns
* Functions and procedures::    Format of `April' functions and procedures
* Tests and conditions::        `April''s standard test functions.
* Arithmetic functions::        Standard arithmetic functions.
* Input and output::            Standard procedures and functions for I/O.
* String handling::             Standard string handling functions.
* Lists and sets::              Standard compound structure handling functions.
* Processes::                   Standard functions for process manipulation.
* April communications::        How April programs communicate
* Environment::                 Access to standard O/S functions.
* Resource limited execution::  Executing programs in a limited environment
* Debugging April programs::    Interfacing with the debugger.
* April syntax::                Rules for writing `April' programs
* Extending the April system::  Extending April with plug-in modules
* April grammar::               `April's formal grammar.
* Standard operators::          April's standard predefined operators
* Standard error codes::        April's standard error codes
* Encoded term format::         How April values are encoded in messages
* Notes for April v4 programmers:: Differences between V4 and V5 of `April'
* Concept index::
* Function index::


File: april.info,  Node: Compiling April programs,  Next: How to invoke April,  Prev: Copying,  Up: Top

1 Compiling `April' Programs
****************************

Before an `April' program can be executed, the source code must first
be compiled into abstract machine instructions - this is done using a
separate compiler program.  The `April' compiler is called using the
`apc' command as follows :
     apc [-g] [-E] [-I PATH] [-X STANDARD] [-x] [-o OUT]
         [-M ] [-# GLUE] FILE*
   where FILEs specify one or more `April' source files.  The options
have the following meanings:

`-g'
     Compiles extra debugging information.  When the compiled program is
     run with the ``-g'' option as well, messages are sent to a debugger
     process.  A sample debugger program is being developed and will be
     made available soon for reference.

`-I PATH'
     Changes the default `include path' - which is the list of
     directories that are searched when handling `#include' directives
     - from `"."' to PATH.

`-X STANDARD'
     Normally the compiler loads a standard header file - `stdlib.ah' -
     which defines standard macros and operators. It is as if the first
     line of every source file read:

          #include <stdlib.ah>;

     The `-X' option is used to change this, making it effectively:
          #include "standard";

     Note that `standard' is interpreted relative to any INCLUDE PATH
     that might be established.

     Using the `-X' option has two effects: it alters the compiler's
     default location for system include files - to be the same
     directory that contains STANDARD - and it suppresses the
     definition of all the standard macros and operators.

     In order to `recover' the standard operators, the programmer should
     include the line:

          #include "/opt/april/include/operators.ah";

     in the file `standard';

     _Hint:_

          Using the `-X' option, together with the `-E' option, is a
          good technique for viewing the effect of user defined macros
          on your program.

`-E'
     Performs the macro-processing stage of the compilation only - the
     output is copied to standard output rather than to a file. The
     output contains the preprocessed input - i.e., after macro
     processing and comments removal has taken place.

`-# STRING'
     This changes the `glue' string used during macro processing for
     generating new symbols to STRING. Normally, this is set to "`#'".

`-o OUTPUT'
     Normally, the compiled output goes to the file `FILE.aam' where
          FILENAME = FILE.ap

     however, with the `-o' option, this can be overridden to write the
     code file to OUTPUT.

`-M'
     This option can be used to automatically generate a module
     `interface' file when compiling a module file.

     When this option is used, a file - called `PROG.af' where the
     module file being compiled is called PROG`.ap' - is created.

     The format of the generated AF-FILE is sufficient for another
     module to import it using a module `interface' reference - *note
     Using interface specification files::.

     An important benefit of using generated `interface' files is that
     the type of the module is exactly as written in the `.af' file.
     Hand-written `interface' files can often be shorter but they are
     prone to error for complex cases.(1)

`-x'
     This option marks the output file as a pure executable file;
     usually used in conjunction with the `-o' option. Thus instead of
     running the result with:

          april file args

     we can simply use:

          file args

     Note that this still requires `April' itself to be installed and on
     the current `PATH'.

   The FILENAME is assumed to contain `April' source code.  The
standard extension for `April' source programs is `.ap'.

   The output of the compiler is a file with extension ``.aam''. The
contents of this file is a single code module which may embed
procedures and functions within it.

   ---------- Footnotes ----------

   (1) This is a new feature of version 4.2.7.


File: april.info,  Node: How to invoke April,  Next: April programs,  Prev: Compiling April programs,  Up: Top

2 Running `April' programs
**************************

In order to run an `April' program, it is first of all necessary to
ensure that the communications server is running on your machine. The
details of running the `icm' are detailed in the companion reference
manual `InterAgent Communications Model Reference Manual'; however, in
order to start the `icm' all that is necessary is to type the command:

     % icm

The command will terminate immediately, but the communications server is
left running as a daemon in the background.(1)

   A typical invocation of `April' from a Unix shell is

     % april OPTIONS FILENAME ARG1 ARG2 ...

where the arguments ARG1, ARG2 etc. are collected together as a tuple
and made available as the value of the `command_line' built-in function.

* Menu:

* Summary of command options:: April command options
* Environment variables:: Controlling `April''s standard search paths

   ---------- Footnotes ----------

   (1) The `icm' is designed to be started as a daemon during the
normal boot process.


File: april.info,  Node: Summary of command options,  Next: Environment variables,  Up: How to invoke April

2.1 Summary of `April' command options
======================================

`-g DEBUGGER'
     Turns on symbolic debugging.  As a pre-requisite, the program must
     have been compiled with the `-g' compiler option.  Executing a
     program with the `-g' option will cause numerous messages to be
     sent to the debugger process (whose name is DEBUGGER). This
     process can thereby `take control' of this process: and will
     typically show where in the program the process is, what variables
     are being assigned and so forth.

     *Note Debugging April programs:: for a description of these
     messages and the standard `April' debugger program.

`-N NAME'
     The argument is used to override the default name for the
     `invocation' of `April'.

     By default, each `April' invocation has a name which is generated
     automatically in a way calculated to ensure its uniqueness.
     Typically it is of the form:

          host#12345

     where `host' is the host name of the machine and `12345' is the
     Unix process ID of the `April' invocation.

     However, for some applications it is necessary to be able to
     override this default. In particular if it is required that the
     invoked `April' application is `recoverable' - i.e., that it can
     restart after a machine crash possibly on another machine - then
     the invocation may have to be set. However, the invocation name is
     still required to be globally unique.

     The `invocation' name of the `April' system is also used as the
     default `agent' portion of the handles of anonymously forked
     processes.

`-H HOME'
     The argument is used to override the default home part of the
     invocation name. By default, the HOME is derived from the hostname
     of the computer running the `April' application.

     The NAME and HOME combination is intended to provide a method for
     giving `April' programs a globally unique name.

     It is always possible for an executing `April' program to spawn off
     a sub-process with a particular name. The difference being that
     using the command line option gives the top-level of the `April'
     application a specific name - one selected by the invoker of the
     `April' application.

`-l ADDRESS'
     The argument is a string giving a host name or IP address that
     will be used as an additional location for processes executing in
     this invocation. Up to 8 additional addresses(1) may be offered.

`-h SIZE'
     This sets the initial size of the heap to SIZEK words - each word
     is normally 4 bytes. The heap will grow automatically as needed,
     but setting a higher heap size can increase performance
     considerably (even if the application does not need the space).

     The default initial heap size is 100K words, or approximately
     0.5MB.

`-v'
     Display the current version of the `April' engine on a banner line
     before executing the program.

`-L LOG'
     Set the `log' file to LOG. This is used in the `log_msg' built-in
     command and the `april_log_msg' API function.

     If LOG is the string "`-'", then logging messages are printed to
     `stderr'; if no `-L' option is given then logging messages are
     ignored.

`-p PATH'
     Adds PATH to the search path. This is used when dynamically
     loading modules.


   ---------- Footnotes ----------

   (1) The current host's IP address is always available as an address
for processes.


File: april.info,  Node: Environment variables,  Prev: Summary of command options,  Up: How to invoke April

2.2 Environment variables
=========================

Generally, it is not necessary to use or set environment variables.
However, there are a few environment variables which may be of interest
to the `April' progammer:
`APRIL_DIR'
     This environment variable would not normally be set by the user.
     By default, its value is set to `April''s `home' directory - i.e.,
     the directory where the `April' system itself resides.(1) 

`APRIL_COMMSERVER'
     This environment variable is used to control the location of the
     communications server. By default, the `April' engine looks for a
     communications server on the same computer; by setting the
     `APRIL_COMMSERVER' environment variable, the engine can use a
     `remote' communications server.

`APRIL_COMMS_PORT'
     This environment variable would not normally be set by the user.
     This environment variable is used to identify the port number that
     the communications server will be using. This environment variable
     may be overridden by using the `-P' command-line option.


   ---------- Footnotes ----------

   (1) Usually this is `/opt/april'.


File: april.info,  Node: April programs,  Next: Data values and types,  Prev: How to invoke April,  Up: Top

3 Format of an `April' source file
**********************************

Each `April' source file contains either a single `executable' program
or a single module. Either may contain any number of procedures and
functions and an `April' application may be constructed from modules
and programs in any number of source files but there can only be a
single program or module in any given source file.

* Menu:

* Standard April programs::     Format of an `executable' `April' program
* April modules::               Format of `April' modules
* Including other source files::


File: april.info,  Node: Standard April programs,  Next: April modules,  Up: April programs

3.1 Standard `April' programs
=============================

A simple program file which contains a simple program to display the
infamous `Hello world' banner is:

     program{
       /* How to say hello in this world */
       main(){
         "Hello world\n" >> stdout   -- send message to stdout
       }
     } execute main;

A `program' file consists of two main components: a set of procedures,
functions and type definitions enclosed in `{}''s after the `program'
keyword and an `execute' clause which identifies the `main' program to
execute. The main program of a `program' file identifies the program
that will be executed when the program is loaded.

   The statement:

     "Hello world\n" >> stdout
   is `April' for:

     "Send the message `"Hello world\n"' to the process `stdout'"

which has the side-affect of displaying it on the console.

   Within the `program''s braces, there can be any number of procedures
and functions (technically there must be at least one procedure or
function in the `program' body). For example, the same effect as the
program above can be achieved by:

     program{
       hello() => "Hello world";
       main(){
         hello() ++ "\n" >> stdout;
       }
     } execute main;

In this program we have defined an auxiliary function - called `hello'
- which returns the string `"hello world"'. This function is called in
the body of `main' within the message send statement. The `++' operator
is a function that concatenates two strings together (*note concatenate
strings::).

* Menu:

* Comments in programs::
* Command line arguments to programs::


File: april.info,  Node: Comments in programs,  Next: Command line arguments to programs,  Up: Standard April programs

3.1.1 Comments in programs
--------------------------

`April' has two styles of comments - `line' comments and `continuous'
comments. Line comments are introduced using a double-dash `--'
followed by a white space character and terminated by end of line or
end-of-file.

   Continuous comments are introduced using the characters `/*',
followed by any sequence of characters up until a closing `*/' pair.

   Note that a comment `takes the place' of a white space character - it
is not possible to have a comment embedded within an identifier for
example.


File: april.info,  Node: Command line arguments to programs,  Prev: Comments in programs,  Up: Standard April programs

3.1.2 Command line arguments to programs
----------------------------------------

If we wish to pass command line arguments to a program we can do so
easily by adding extra parameters to the initial procedure we invoke.
For example, we can write a more general echo program using:

     program
     {
       main(S)
       {
         S ++ "\n" >> stdout
       }
     } execute main;

Here, `main' has a single argument - `S' - which the type checker
infers must have type `string' (because it is mentioned in a string
concatenation expression - *note Types and type inferencing::).

   When running `echo', the `April' run-time system will verify that it
is called with at least one argument which is interpreted as a string:

     % april echo hello

If `echo' is run without supplying at least one argument, then a
run-time error will be displayed:

     arguments [] incorrect, expecting: (string)

Since all `April' data types can be coerced to the `string' data type
this is the only error that can arise from this program. But if `main'
expected an integer as argument and was not given one then an analogous
error message would be displayed.


File: april.info,  Node: April modules,  Next: Including other source files,  Prev: Standard April programs,  Up: April programs

3.2 `April' module files
========================

The second principal form of program file in `April' is the _module
file_. A module file is similar to a program file in that it may
contain a number of procedures and functions. However, there is no
declared `entry point' to a module file; instead one or more of the
embedded functions and procedures are exported.

   For example, we might encapsulate the `hello' function from *Note
Standard April programs:: to form a module file:

     module{
       hello() => "Hello world"
     } export hello;

Where more than one program is to be exported, use a tuple sequence of
names.

* Menu:

* Importing programs from modules::
* Importing multiple modules::
* Using interface specification files::


File: april.info,  Node: Importing programs from modules,  Next: Importing multiple modules,  Up: April modules

3.2.1 Importing programs from modules
-------------------------------------

In order to be able to use a module, which has been embedded within a
module file, it is necessary to _import_ the module. This is done by
adding an `import' clause before the body of a `program' (or module)
body. Below, we see the `hello' function is imported from this module -
assuming that its source is located in the file `hello.ap' and the
compiled code in the file `hello.aam'.

     program
     import {()=>string}?hello from "hello.aam" where
     {
       main(){
         hello() ++ "\n" >> stdout;
       }
     } execute main;

Notice that in the `import' clause we have to be quite specific about
the types of procedures and functions that we declare; in addition, the
import clause must match exactly the sequence of procedures and
functions listed in the `export' clause of the module that we are
importing from. On the other hand it is _not_ necessary to use the same
names for programs in the `import' clause and the defining module file
- `April' uses a name-free mechanism for exporting and importing from
modules.

   It is possible for a module file to itself import other modules.
This is done in an analogous manner to program files importing modules.
Below, we have an alternative module where the `hello' function itself
invokes a sub-function `world' - which is imported from another module:

     module
     import {()=>string}?world from "world_name.aam" where
     {
       hello() => "Hello " ++ world()
     } export hello;

Of course, we now also require the additional module `world_name.aam'
(whose source is in the file `world_name.ap') to define the `world'
function; this is shown in:

     module{
       world() => "world"
     } export world;


File: april.info,  Node: Importing multiple modules,  Next: Using interface specification files,  Prev: Importing programs from modules,  Up: April modules

3.2.2 Importing multiple modules
--------------------------------

A module or program may import several modules simultaneously. This is
simply a combination of importing individual modules - the `clauses'
which describe the import specification of specific modules are
separated by the `and' operator. For example, in the `Hellow world'
example, we might import two modules:

     program
     import {{()=>string}?hello} from "hello.aam" and
            {{()=>string}?world} from "world_name.aam" where
     {
       main(){
         hello() ++ world() ++ "\n" >> stdout;
       }
     } execute main;


File: april.info,  Node: Using interface specification files,  Prev: Importing multiple modules,  Up: April modules

3.2.3 Using interface specification files
-----------------------------------------

As an alternative to an explicit specification when importing from a
module, it is possible to use an interface file. The contents of an
interface file is an import specification. For example, we could have:

     {()=>string}?hello from "hello.aam"

in a file `hello.af', and

     {{()=>string}?world} from "world_name.aam"

in the file `world_name.af'

   Then, the above example program may be more conveniently written as:

     program
     import interface "hello.af" and
            interface "world_name.af" where
     {
       main(){
         hello() ++ world() ++ "\n" >> stdout;
       }
     } execute main;

Using interface files in this way has the benefit of ensuring that the
exact specification of a module only needs to be held in a single file;
and there is no special need to modify the sources of programs which
import modules if the module's specification is changed.

   However, if a module's interface specification is changed then both
the implementing module and any programs and modules which import the
modified module _will_ need to be recompiled.

   Note that `.af' files can be generated automatically by the compiler
using the `-M `af-file'' command-line option.


File: april.info,  Node: Including other source files,  Prev: April modules,  Up: April programs

3.3 Including other source files
================================

A source file can be included `in place' using the `#include'
statement. There are two forms of the `#include' statement:

     #include "FILE";

and

     #include <FILE>;

The latter form is used for accessing `system' include files which form
part of the `April' distribution or other published include files. It
searches `April''s installation directories for the source of the file,
whereas the former form only looks in the user's directories (*note
Compiling April programs:: for how the search path for include files
can be specified).


File: april.info,  Node: Data values and types,  Next: Expressions,  Prev: April programs,  Up: Top

4 `April' data values and types
*******************************

We can classify `April' values into three main catagories: primitive
values, complex or compound values and values of user-defined types.
`April' is a higher-order language - which means that the range of
values is greater than many conventional languages; in particular
procedures, functions and collections of them are also values in the
language.

   In addition to being a higher-order language, `April' is also a
symbolic language. What this means is that, compared to so-called
`engineering' languages, `April''s values have a standard `written
representation' - that is, it is possible to write an explicit literal
value of any particular type. For example, the expression:

     10.34

refers to a number, and

     ["alpha","beta"]

is a list of strings. As we introduce the various types of values we
also describe how to write literals in the type. However, the programmer
should be aware that the way of writing a particular class of values can
be dramatically altered if user-defined operators are involved.

   In this chapter we describe the standard types of `April' and how to
write values of these types.

* Menu:

* Primitive types::
* Compound types::
* Type definitions::
* Standard April Types::
* Types and type inferencing::


File: april.info,  Node: Primitive types,  Next: Compound types,  Up: Data values and types

4.1 Primitive types
===================

A primitive or scalar type is one whose values have no `internal
structure' - they can be manipulated and processed but they cannot be
inspected. The simplest example of a primitive value is number - it
makes no sense to talk about the `first component' of an integer for
example.

* Menu:

* number type::
* symbol type::
* char type::
* string type::


File: april.info,  Node: number type,  Next: symbol type,  Up: Primitive types

4.1.1 `number' type
-------------------

`April' numbers are either integers or floating points - the precision
of arithmetic is implementation dependent, but is at least equivalent
to IEEE double precision.(1)

   `April' does not distinguish between the two kinds of numbers (i.e.,
`1' = `1.0') Nearly all of the standard arithmetic functions handle
integers as easily as floating point numbers - with the exception of
some binary arithmetic functions such as `bitwise and' - *note Bitwise
and::.

   `April' supports octal and hexadecimal literal integer notation as
well as regular decimal notation. For example, the numbers:

     16  0x10  020

all refer to the same number (sixteen). See *Note Number syntax:: for
the precise rules for writing numeric values in programs.

   The type of numeric values is `number'. As is explained in *Note
number pattern::, not only is `number' a type but it is also also a
run-time pattern test.

   ---------- Footnotes ----------

   (1) The current version of the `April' engine uses 64-bit integers
when representing integral values. This implies that integers have a
larger range than floating point numbers...


File: april.info,  Node: symbol type,  Next: char type,  Prev: number type,  Up: Primitive types

4.1.2 `symbol' type
-------------------

The `symbol' type refers to symbol literals in the program. Symbols are
identified by prefixing an identifier with a quote character:

     'foo


File: april.info,  Node: char type,  Next: string type,  Prev: symbol type,  Up: Primitive types

4.1.3 `char' type
-----------------


File: april.info,  Node: string type,  Prev: char type,  Up: Primitive types

4.1.4 `string' type
-------------------

A `string' is a data type that may hold arbitrary sequences of Unicode
characters. In fact, a `string' is a synonym for a list of `char'acters.

   As noted in *note string syntax::, `string' values are written as
sequences of characters surrounded by double-quote characters:

     "This is a string of 33 characters"

   This is entirely equivalent to the list:

     [''T,''h,''i,''s,'' ,''i,''s,'' ,''a,'' ,''s,''t,''r,''i,''n,''g,
       '' ,''o,''f,'' ,''3,''3,'' ,''c,''h,''a,''r,''a,''c,''t,''e,''r,''s]


File: april.info,  Node: Compound types,  Next: Type definitions,  Prev: Primitive types,  Up: Data values and types

4.2 Compound types
==================

`April' has three built-in methods for composing objects - lists,
tuples and records. In addition, a labelled record is a form of
tuple/record which is introduced by means of a user-defined type
declaration. Records are similar to tuples where individual components
of the tuple are identified by name rather than by position. In
addition, there are other styles of compound type - such as function
and procedure types; the `encapsulated' type `any' provides a mechanism
for `escaping' the type system.

* Menu:

* list type::                   Lists of values
* tuple type::                  Tuples of values
* record type::                 Record tuples
* function type::               Type of functions
* procedure type::              Type of procedures
* any type::                    Encapsulated values
* Quantified types::


File: april.info,  Node: list type,  Next: tuple type,  Up: Compound types

4.2.1 List type
---------------

A list is an ordered sequence of values , all of which have the _same_
type. Lists are written as a comma-separated sequence surrounded by
`[]'s. For example, a list of the first 5 prime numbers would be
written:

     [2, 3, 5, 7, 11]

and the _type_ of this list would be written:

     number[]

There are two special forms of list that should be discussed - the empty
list which is written:

     []

and _list patterns_ which look like:

     [E1,...,EK,..TAIL]

The type inference system will deduce that the type of an empty-list
literal is:

     %A[]

where `%A' signifies an unbound type variable (*note Type variables::).
I.e., the type of an empty list literal is LIST-OF-SOMETHING where the
SOMETHING is not yet apparent and is represented as a type variable. In
all likelihood, the context of the empty list literal will further
constrain the types so that SOMETHING can be deduced - but this is not
essential.

   A LIST expression is a generalization of literal lists. It allows us
to write down a literal list where the tail of the list is not known to
be `[]' but is the value of an expression.

   In the program:

     app = {
       ([],Y) => Y
     | ([E,..Z],Y) => [E,..app(Y,Z)]
     }

we use list expressions in two contexts - as a pattern and as a regular
expression. In the expression `[E,..app(Y,Z)]' we know the first
element of the list - `E' - but the tail of the list is computed from
the function call - `app(Y,Z)'.

   A list expression as a pattern allows us to extract the head of a
list and the tail of the list without needing to know how long the list
is. The pattern `[?E,..?Z]' could match the list:

     [2, 3, 5, 7, 11]

by assigning `E' to `2' and assigning `Z' to `[3, 5, 7, 11]'.

   The type inference system can compute the type of a list literal
automatically - based on the types of the elements. All the elements of
a list must have the same type, a fact that the type inference system
will verify. The rule for computing the type of a list expression is
completely analogous, but note that the type of the `tail' expression is
the same type as the whole list itself.


File: april.info,  Node: tuple type,  Next: record type,  Prev: list type,  Up: Compound types

4.2.2 Tuple type
----------------

A tuple is a ordered sequence of values, each of which is potentially
of a _different_ type. Tuples are written as a comma-separated sequence
surrounded by `()'s. For example, a tuple consisting of a string and a
number representing the name and age of a client may be:

     ("Fred. U. Are", 40)

The _type_ of a tuple such as this is also a tuple - a tuple of the
types of the tuple elements:

     (string, number)

The components of a tuple such as this can only be accessed via a
pattern matching expression.


File: april.info,  Node: record type,  Next: function type,  Prev: tuple type,  Up: Compound types

4.2.3 Record type
-----------------

A record is a tuple in which the elements are identified by a field
name. A record type is similarly a tuple type in which elements of the
type are identified by field name.

   A normal record literal is written using a notation such as:

     (name="Fred. U. Are", age=40)

the type description for a name/age record such as this might be:

     (string?name, number?age)

where `name' and `age' are symbolic field names identifying the first
and second elements of the record.

   `April' requires that elements of record literals follow the same
order as in the appropriate type description. For example, the nearly
`equivalent' record:

     (age=40, name="Fred. U. Are")

has a different, incompatible, type.

   Note that a record value is not compatible with a tuple value(1) A
record value such as the one above is _not_ of the same type as:

     (40,"Fred. U. Are")

A major example of a record is the theta expression - *note theta
expression::. Theta expressions are used to contain functions and
procedures.

   Field names are most often used in conjunction with the `dot'
operator (*note Dot expression::), for example we can access the name
of a client using:

     R.name

Note, however, that the dot operator in `April' is considerably more
powerful than in most programming languages.

   ---------- Footnotes ----------

   (1) This is new in version 4.2.7, prior to this version tuples were
compatible with records. However, there are semantic problems
associated with this confusion.


File: april.info,  Node: function type,  Next: procedure type,  Prev: record type,  Up: Compound types

4.2.4 Function type
-------------------

As with any higher order programming language, a function is a first
class object in `April', and has a type. We explore functions more
completely in *Note Function:: and *Note programs and theta
expressions::. Here we note the form of a function type; the type of a
function, such as:

     (P1,...,PK) => E

is

     (T1,...,TK) => T

where the type system can infer that the types of the patterns PI are
TI and the type of E is T respectively.


File: april.info,  Node: procedure type,  Next: any type,  Prev: function type,  Up: Compound types

4.2.5 Procedure type
--------------------

Like functions, a procedure is a first class object in `April', and has
a type. We explore procedures more completely in *Note Procedure:: and
*Note programs and theta expressions::. Here we note the form of a
procedure type; the type of a procedure, such as:

     (PTN1,...,PTNK)->STATEMENT

is

     (T1,...,TK){}

where the type system can infer that the types of the patterns PTNI are
TI respectively.


File: april.info,  Node: any type,  Next: Quantified types,  Prev: procedure type,  Up: Compound types

4.2.6 `any' type
----------------

The `any' type is a kind of universal type; more accurately, the `any'
type acts as a kind of encapsulation of other values. An `any' value
can be safely sent in messages across the network, saved in files, and
both the original value and its type can be recovered.(1)

   An `any' value is written using the `any' constructor:

     any(foo)

the type of this expression is `any'.  Type `any' can encapsulate any
`April' value; however most operators will not accept an `any' value
directly.

   This means that it is possible, for example, to construct a list of
heterogenous values where the types of the list elements cannot be
predicted at compile time.

   For example, to construct a list of numbers and strings one could
use:

     a_list : [any(10), any("foo"), any(12.4)]

In order to access an element of this list, and to be able to operate on
it, it is necessary to use an `any' pattern to extract the value:

     if any(X) .= a_list#2 then
       ...

Such an `any' pattern will verify that the actual type of the `payload'
of the `any' value is consistent with the expected use of the value. In
this case, the second element of the `a_list' list will be checked
against the constraints on the use of `X' implied in the rest of the
program. For example, if `X' is involved in an arithmetic operation:

     Y : 10;
     if any(X) .= a_list#2 then
       Y := Y+X

then `X' must be a `number' and the list element will be verified that
it is a `number' (at run-time). A more explicit pattern that does the
same might be:

     Y : 10;
     if any(number?X) .= a_list#2 then
       Y := Y+X

If `a_list#2' were not a `number' then the match would fail.

   _Hint:_

     It is likely that most of the time, programmers will not need to
     consider `any' values. However, the `April' system uses them to
     wrap messages that may be sent between processes.

   ---------- Footnotes ----------

   (1) The syntax and semantics of `any' values changed with version
4.2.7.


File: april.info,  Node: Quantified types,  Prev: any type,  Up: Compound types

4.2.7 Quantified types
----------------------

Since `April' is a polymorphic language, we can expect there to be
types that are more general than individual literal types. Such types
have _type variables_ in them. In the context of a given type
expression, a type variable may be _free_ or _bound_. A bound type
variable expression introduces a type variable and at the same time
delimits the scope of that type variable.

   A universally quantified type expression denotes a `universal' or
polymorphic type. For example, the type expression:

     %x-((%x){},()=>%x)

denotes a tuple - a pair - consisting of a procedure and a function.
The procedure `consumes' a value and the function `produces' a value of
the same type. The universal quantifier gives an explicit scope to the
type variable `%x'.(1)

   ---------- Footnotes ----------

   (1) Universal quantifiers are a new feature of version 4.2.7


File: april.info,  Node: Type definitions,  Next: Standard April Types,  Prev: Compound types,  Up: Data values and types

4.3 Type definitions
====================

A user-defined type is a new type introduced by the programmer using a
type definition statement:

     TYPE-HEAD ::= TYPE-BODY

where TYPE-HEAD is either a symbol or of the form:

     NAME(TV1,...,TVK)

where TVI are _type variables_.

   The body of a user-defined type is built from three fundamental
components - `symbol's, labelled types and disjunctions.

   Semantically, there are two kinds of user-defined type definition: a
completely new type or a new name for an existing type. The `April'
compiler can (usually) tell the difference automatically.  

   A truly new type, involving constructor functions, is especially
useful in certain contexts where values need to be communicated with
other applications.

* Menu:

* Type renaming::
* User defined type definition::
* Scope of type definitions::


File: april.info,  Node: Type renaming,  Next: User defined type definition,  Up: Type definitions

4.3.1 Type renaming definition
------------------------------

A type renaming has a simple form:

     TYPE-HEAD ::= EXISTING-TYPE

where EXISTING-TYPE is a type expression involving previously declared
or built-in types. In particular, a type re-naming definition does not
introduce any new constructor functions or enumerated symbols (*note
User defined type definition::), neither does it involve a disjunction.
Conversely, a type definition which introduces a completeley new type
is not permitted to rename an existing type.

   A type renaming definition is essentially a macro; all occurrences of
the new type are replaced by the EXISTING-TYPE. This form of type
definition is essentially a convenience feature that makes it easier to
construct clear and readable programs. One common use for this feature
is to define types in terms of built-in types such as lists and records.

   Type renaming definitions can be polymorphic, and they can refer to
polymorphic types. Generally, a renamed type is less polymorphic than
the types is renames to.


File: april.info,  Node: User defined type definition,  Next: Scope of type definitions,  Prev: Type renaming,  Up: Type definitions

4.3.2 User defined type definition
----------------------------------

A new type definition introduces a new type into the language together
with one or more new _enumerated symbols_ and CONSTRUCTOR FUNCTIONS.
The form of a new type definition is:

     TYPE-HEAD ::= TYPE-BODY

where TYPE-BODY is typically a disjunction of SYMBOL ENUMERATIONS and
CONSTRUCTOR FUNCTION definitions.

   For example, the `weekday' type - which introduces the days of the
week - can be defined using: 

     weekday ::= monday | tuesday | wednesday | thursday | friday |
                 saturday | sunday;

Any symbols introduced in this way must be unique - i.e., not occurring
in any other type definition that is currently in scope.

   A constructor function definition looks like:
     NAME TYPE

although we typically enclose the TYPE argument in parentheses.  For
example, given the type definition:

     kqmlItem ::= ontology(string) | language(string) | ... ;

a reference to the `ontology' constructor looks like:

     X : ontology("animal-world")

Constructor functions are so-named because semantically they are
functions: with the particular property that every expression involving
the constructor function has an exact inverse. This property allows
constructor functions to be used as patterns as well as in other
expressions.

   More formally, a type definition such as:

     tr(%t) ::= e | n(tr(%t),%t,tr(%t));

can be viewed as introducing a new type or a class of types -
`tr(TYPE)' - together with one or more enumerated symbols and
CONSTRUCTOR FUNCTIONS that return values of that type. In this case,
the enumerated symbol `e' introduced has type:

     tr(%t)
   and the constructor function `n' has type
     %t-((tr(%t),%t,tr(%t)) => tr(%t))

   _Hint:_

     A significant benefit of user defined types arises when we want to
     communicate values between programs: typically two programs will
     have a specific protocol for the messages that can be sent. We can
     often express the elements of the protocol - as opposed to any
     required ordering between messages in the protocol - as a
     user-defined type:

          myProtocol ::= openX(string) | closeX(string) |
                  inform(kqmlMsg) |...;

     Such a type definition gives added documentation about the form of
     the messages between processes.


File: april.info,  Node: Scope of type definitions,  Prev: User defined type definition,  Up: Type definitions

4.3.3 Scope of type definitions
-------------------------------

A type definition statement is only valid at the top-level and at the
top-level within an theta expression (*note theta expression::).
Furthermore, only types introduced within theta records may be mutually
recursive.

   The scope of a type definition introduced globally is the remainder
of the source of the program; whereas the scope of a type definition
introduced in a record expression is the whole of the record body -
including any text in the record _before_ the type definition.

   This extension of scope is necessary for type definitions (as it is
for function and procedure definitions in record expressions) in order
to permit mutually recursive type definitions.


File: april.info,  Node: Standard April Types,  Next: Types and type inferencing,  Prev: Type definitions,  Up: Data values and types

4.4 Standard `April' Types
==========================

The complete `April' language system includes a number of standard
types - these are types which may be defined using type definition
statements (*note Type definitions::) but nevertheless are considered to
be part of the `April' language.

* Menu:

* logical type::
* handle type::                 Type of a process handle
* error type::
* type_of type function::


File: april.info,  Node: logical type,  Next: handle type,  Up: Standard April Types

4.4.1 `logical' type
--------------------

The `logical' type is a pre-defined type that is defined to be
equivalent to the definition (*note Type definitions::):

     logical ::= true | false

`logical' values are obviously very important in any programming
language - since expressions of this type are often used to control the
flow of execution.


File: april.info,  Node: handle type,  Next: error type,  Prev: logical type,  Up: Standard April Types

4.4.2 `handle' type
-------------------

`handle's are objects which identify processes. When a new process is
`spawn'ed (*note spawn::) a new `handle' is generated to correspond to
the new process. The `handle' type is a standard type associated with
process handles.

   A process `handle' can identify a process sufficiently to allow
messages to be sent to it from anywhere in the Internet.(1)

   Process `handle's are constructed around a standard form of
constructor function (*note User defined type definition::). The
`handle' type is a system declared type of the form:

     handle ::= nullhandle | hdl(symbol,symbol);

where the first symbol in the `hdl' term gives a process identifier
within a named group, and the second symbol is the name of the group.

   The `nullhandle' enumerated symbol is a special handle that is
guaranteed not to represent any executing process.

   ---------- Footnotes ----------

   (1) Notwithstanding minor barriers to communication such as security
`Fire-walls'.


File: april.info,  Node: error type,  Next: type_of type function,  Prev: handle type,  Up: Standard April Types

4.4.3 `error' type
------------------

Values of the `error' type is used by many built-in functions and
procedures to encapsulate critical data when an exception is raised. The
standard definition of the `error' type is:

     error ::= error(string,symbol) | failed | timedout | clickedout;

The `error' constructor is the most common instance of an `error'
value. The `string' field is a descriptive string that denotes the
cause of the error or exception, and the `code' field gives a
formalized classification of the error. For errors raised in
application programs any symbolic value may be used for the error code;
for system built-ins, the legal error codes and their interpretations
are listed in *Note Standard error codes::.(1)

   The `failed' value is raised when an equation or statement clause
fails to apply to a set of arguments.

   ---------- Footnotes ----------

   (1) The form of the `error' type changed in version 4.4.0-pre2.


File: april.info,  Node: type_of type function,  Prev: error type,  Up: Standard April Types

4.4.4 `type_of' type function
-----------------------------

The `type_of' `function' can be used to access explicitly the type of
an expression and make it available as a type expression. `type_of' is
not a function - in the sense that it does not have any run-time value
associated with it - the value of a `type_of' expression is a type.

   Thus, the type associated with the type expression:

     type_of(EXP)

is the type of EXP. This can be used to explicitly link the types of
two expressions which would not otherwise normally be linked; for
example in:

     type_of(3) ? X = EXP

is entirely equivalent to:

     number ? X = EXP

because the type of the literal `3' is `number'. More normally, a
`type_of' expression involves variables, as in:

     type_of(E) ? X = EXP

Here, we are declaring that the type of `X' is the same type as the
type of `E'; but there need be no run-time connection between `X' and
`E'.


File: april.info,  Node: Types and type inferencing,  Prev: Standard April Types,  Up: Data values and types

4.5 Types and type inferencing
==============================

The `April' compiler uses _type inferencing_ to deduce the types of
variables and expressions in programs. Type inferencing is a powerful
tool that permits most programs to have very sparse type information
written in them, while at the same time ensuring strong type safety.

   For example, the compiler is able to infer the type of the variable
`S' in the declaration:

     S : "foo";

as a `string'. This means that it is not necessary for the programmer
to assert the type of `S' - although the compiler will accept such
assertions and verify them:

     string?S = "foo";

The rules for inferring the type of an expression, and for verifying
type integrity of variable assignments and expressions, are quite
straightforward.

* Menu:

* Type variables::
* Type abstraction and reification::
* Equality of type expressions::
* Type derivation::
* Types and patterns::
* Types and statements::
* Type parameters::


File: april.info,  Node: Type variables,  Next: Type abstraction and reification,  Up: Types and type inferencing

4.5.1 Type variables
--------------------

A type variable is a compiler's variable - not a programmer's variable.
It refers to the type of some attribute of the program - such as the
type of a variable (programmer's that is) or the type of a function.

   The compiler assigns a type variable to any program fragment that
could reasonably have type associated with it - program variables,
functions  procedures, and so on. In addition, the programmer can
explicitly introduce type variables within type expressions. The form of
a programmer introduced type variable is:

     %IDENT

   where IDENT is an identifier.

   Type variables are important because they can be _instantiated_ as a
result of satisfying some constraint implied by the program. For
example, in:

     S : "foo";

a type variable is attached to `S' - %TV1 say - as a result of the
declaration of `S'. The compiler knows that literal strings have type
`string', so this match statement induces a _type constraint_ of the
form:

     %TV1 = string

which can be satisfied by _instantiating_ or _binding_ %TV1 to
`string'. Subsequent occurrences of the variable `S' will introduce
additional constraints, which may also result in further type variables
being introduced and constrained.

   Each variable declaration is associated with a separate type variable
and each occurrence of the variable implies one or more additional type
constraints.  The most common constraint takes the form:

     %TV = TYPE

All these equations must be satisfied simultaneously, which means that
in general, the type checker must solve equations of the form:

     TYPEA = TYPEB

The `April' type checker uses a unification-based algorithm to do this
- in effect two types are equal if they can be reduced to the same
syntactic form. For example, the equation:

     (TYPEA, %TV1) = (%TV2, TYPEB)

is solveable by instantiating %TV1 to TYPEB and %TV2 to TYPEA. However,
the equation:

     (TYPEA, %TV1) = (%TV2, TYPEB)[]

has no solution because no list is ever equal to a tuple. If the type
checker is faced with this kind of constraint then it will report a type
error about the program.


File: april.info,  Node: Type abstraction and reification,  Next: Equality of type expressions,  Prev: Type variables,  Up: Types and type inferencing

4.5.2 Type abstraction and reification
--------------------------------------

In some contexts - notably when determining the type of function and
similar expressions and when checking the types in a function or
procedure application - it becomes important to know how type variables
are treated.

   We use two concepts to clarify how types are handled in these
situations - type generalization (or type abstraction) and type
`freshening' (or type reification). Both of these can be expressed in
terms of the scope of type variables in relation to the position of the
binding quantifiers for the variables. Type abstraction is used when
computing the type of a function or procedure, and type reification is
used when computing the types in a function application or procedure
call.

* Menu:

* Type abstraction::            Compute the type of a function or procedure
* Type reification::            Remove bounds from a bound type expression


File: april.info,  Node: Type abstraction,  Next: Type reification,  Up: Type abstraction and reification

4.5.2.1 Type abstraction
........................

In order to compute the type of a function (or by extension a procedure)
the type inference system proceeds by assuming that the types of the
arguments of the function are unknown - i.e., are type variables - and
computes the type of the right hand side of the function:

     foo(X,Y) => X<>Y

results initially in the type assignments:

     X/%A1
     Y/%A2

where `%A1' and `%A2' are completely new type variables not occuring
anywhere else. After computing the type of the right hand side
expression, these type assignments are constrained to:

     X/%A3[]
     Y/%A3[]

where `%A3' also is a type variable.  I.e., the types of the input
arguments must be `lists of something', and the `something' should be
the same type.

   We can now determine the type of the function as:

     (%A3[],%A3[]) => %A3[]

This `foo' function can be applied to any arguments provided that they
are lists, and are lists of the same type.

   However, the type variable in this type expression - `%A3' - is
really what is known as a quantified type variable:

     %A3 - ( (%A3[],%A3[])=>%A3[])

The key feature of this expression is that its meaning is preserved when
we change the quantified variable to something else:

     %U - ((%U[],%U[])=>%U[])

even if this expression appeared in a larger type expression that also
mentions the original type variable `%A3' and those other occurrences
are not replaced.

   This becomes useful when we want to apply functions in more than one
kind of situation.

   Type abstraction then is the process of attaching quantifiers to the
computed type of a function. The specific rule for this is that the type
of a function expression of the form:

     PTN => EXP

is

     %a1-(%a2-...-(TP => TE))

where TP is the type of the pattern PTN, TE is the type of the
expression EXP and AI are all the type variables that occurr in `Tp'
and TE that _do not_ appear elsewhere in the program.


File: april.info,  Node: Type reification,  Prev: Type abstraction,  Up: Type abstraction and reification

4.5.2.2 Type reification
........................

Type reification(1) refers to the process of removing the quantifiers
in a quantified type expression, especially in the context of type
checking a function application.

   In a function application, such as:

     foo([1,2,3],X)

the type checker computes the type of `foo' and determines if it is
applicable to the arguments - `[1,2,3]' and `X' in this case. When the
type of `foo' is determined, it will be an expression of the form:

     %U-(%U[],%U[])=>%U[]

as determined by the definition of `foo' - see *note Type abstraction::.
Additionally, the type checker can compute the types associated with the
arguments to be:

     (number[],%A33)

for example. In order to apply the constraint imposed by `foo'
correctly we have to match the left hand side of `foo''s type with the
type of the arguments. However, before we can do that, we must `strip
off' the bounds on the type variable `%U'. This process is called type
reification.

   Logically, we can observe the equivalence:

     forall X. ((forall Y. X R Y) and (forall Y. X S Y))
     ==>
     forall X. forall Y1. forall Y2. ( X R Y1 and X S Y2)

I.e., we can remove the bounds on a type expression by renaming the
bound type variable to something completely new and moving the
quantifier to the start of the entire type expression.

   Elsewhere in the type checking literature, this process of type
reification is sometimes called `computing a fresh type', and we
sometimes use the same terminology here.

   ---------- Footnotes ----------

   (1) According to Websters on-line: Main Entry: reify
Function: transitive verb
Inflected Form(s): reified; reifying
Etymology: Latin res thing - more at REAL
Date: 1854
: to regard (something abstract) as a material or concrete thing.


File: april.info,  Node: Equality of type expressions,  Next: Type derivation,  Prev: Type abstraction and reification,  Up: Types and type inferencing

4.5.3 Equality of type expressions
----------------------------------

The `April' type inference system needs to test the equality of types
in two main situations: where two expressions might be used to compute
a value the types of the two expressions must be equal, and where a
function or procedure is applied to arguments, the type of the function
or procedure being applied must be `compatible' with the types of the
arguments.

   For the most part, type equality and type compatibility are identical
concepts. They differ only in the treatment of quantification and the
compatibility of functions and procedures.

   The rules for type equality - i.e., when are two types the same - are
straightforward:

IDENTICAL LITERALS
     Two type literals are equal if they are identical. For example,

          string = string

     and, so is

          weekday = weekday

     if `weekday' is a symbol of a user-defined type.

LIST TYPES
     Two _list types_ (*note list type::) are equal if their element
     types are:

          TYPEA[] = TYPEB[]

     providing that
          TYPEA = TYPEB

TUPLE TYPES
     Two tuple types are equal provided that they have the same arity
     and their component types are equal:

          (TYPEA1,...TYPEAK) = (TYPEB1,...TYPEBK)

     providing that
          TYPEA1 = TYPEB1
          ...
          TYPEAK = TYPEBK

USER DEFINED TYPES
     Two occurrences of a user defined type are equal provided that
     they have the same name, and if the type has an argument type, the
     argument types themselves are also equal.

FUNCTION TYPES
     Two functions types are equal if their argument tuple and result
     types are equal:

          (TYPEA1,...TYPEAK) => TYPEA = (TYPEB1,...TYPEBK) => TYPEB

     providing that:

          TYPEA1 = TYPEB1
          ...
          TYPEAK = TYPEBK

          TYPEA = TYPEB

PROCEDURE TYPES
     Two procedure types are equal if their argument tuples are equal:

          (TYPEA1,...TYPEAK){} = (TYPEB1,...TYPEBK){}

     providing that:

          TYPEA1 = TYPEB1
          ...
          TYPEAK = TYPEBK

QUANTIFIED TYPES
     Two quantified types are equal iff the quantified variables are
     the same and the quantified expressions are the same. Note that
     the meaning of a quantified formula is unchanged if the quantified
     variables are renamed (provided that the new name does not iteself
     occur in the quantified formula).

     So, we can show that two quantified types are equal iff we can
     rename one or more of the quantified variables (remembering to
     replace all occurrences of the old variable with the new one) and
     then after such renaming the two quantified types are equal.

     For example, the two quantified type expressions:

          %a-((%a[])=>(%a))
     and
          %b-((%b[])=>(%b))
     are equal because we can rename `%a' to `%b'.

     More formally, we can say that
          %A-TYPEA = %B-TYPEB
     iff there is a %C which does not occur in either of TYPEA or TYPEB
     and:
          TYPEA' = TYPEB'
     where TYPEA' results from replacing all occurrences of %A by %C in
     TYPEA and TYPEB' results from replacing all occurrences of %B by
     %C in TYPEB


File: april.info,  Node: Type derivation,  Next: Types and patterns,  Prev: Equality of type expressions,  Up: Types and type inferencing

4.5.4 Type derivation
---------------------

In addition to computing whether two types are equal, the `April' type
checker must also be able to determine what the type of each program
fragment is. As we shall see, this depends on the type equality relation
we saw in *Note Equality of type expressions::.

   The rules for computing the type associated with a program fragment
are based on the core syntax of `April' program. Here we define a
`type-of' `function' with two parameters:

     type-of(EXP, ENV)

where EXP is a program fragment, and ENV is a list of pairs of the form:

     (symbol,TYPE)

The ENV is effectively an environment giving the appropriate
interpretation of any symbols that may occur in the program.

* Menu:

* Numeric literal type::
* String literal type::
* Symbolic literal type::
* Literal symbol type::
* Empty list literal type::
* Non empty list literal type::
* Tuple literal type::
* Record literal type::
* Function application expression type::
* Type of constructor function expressions::
* Dot expression type::
* valof expression type::
* collect/setof expression type::
* any expression type::
* Function type::
* Procedure type::


File: april.info,  Node: Numeric literal type,  Next: String literal type,  Up: Type derivation

4.5.4.1 Numeric literal type
............................

The type of a numeric literal - such as `34.5' - is `number':

     type-of(X,ENV) = number  for all literal numbers X


File: april.info,  Node: String literal type,  Next: Symbolic literal type,  Prev: Numeric literal type,  Up: Type derivation

4.5.4.2 String literal
......................

The type of a string literal - such as `"FooBar"' - is `string'.

     type-of(X,ENV) = string  for all literal strings X


File: april.info,  Node: Symbolic literal type,  Next: Literal symbol type,  Prev: String literal type,  Up: Type derivation

4.5.4.3 Symbolic literal type
.............................

The type of a symbol literal is `symbol':

     type-of('X,ENV) = symbol
     type-of(''X,ENV) = symbol


File: april.info,  Node: Literal symbol type,  Next: Empty list literal type,  Prev: Symbolic literal type,  Up: Type derivation

4.5.4.4 Literal symbol type
...........................

The type of a symbol or identifier is found by looking in the
environment; each program feature such as a variable or a function will
have an entry in the environment:

     type-of(X,ENV) = TYPE if TYPE?X in ENV

We will see how the environment is extended below.


File: april.info,  Node: Empty list literal type,  Next: Non empty list literal type,  Prev: Literal symbol type,  Up: Type derivation

4.5.4.5 Empty list literal type
...............................

The type of the empty list literal - `[]' - is given by:

     type-of([],ENV) = (%TV)[]

where %TV is a new type variable. In effect, this is saying that the
type of `[]' is a list - but we do not yet have sufficient information
to determine what kind of list.


File: april.info,  Node: Non empty list literal type,  Next: Tuple literal type,  Prev: Empty list literal type,  Up: Type derivation

4.5.4.6 Non empty list literal type
...................................

Where there is a non-empty list expression; then we compute the type as
follows:

     type-of([HEAD,..TAIL],ENV) = type-of(TAIL,ENV)
   where
     type-of(`Head',ENV)[] = type-of(TAIL,ENV)

I.e., we compute the type of the head of the list, and the type of the
tail of the list, then we make sure that the tail's type is compatible
with the type of the head, and the type of the whole of the list is the
same as the type of the tail (after the additional constraint relating
to the head).


File: april.info,  Node: Tuple literal type,  Next: Record literal type,  Prev: Non empty list literal type,  Up: Type derivation

4.5.4.7 Tuple literal type
..........................

The type of a tuple is a tuple of the types of the elements of the tuple
literal:

     type-of((E1,...,EK),ENV) =
             (type-of(E1,ENV),...,type-of(EK,ENV))


File: april.info,  Node: Record literal type,  Next: Function application expression type,  Prev: Tuple literal type,  Up: Type derivation

4.5.4.8 Record literal type
...........................

The type of a record literal is a set of the types of the elements of
the record literal:

     type-of((E1=F1,...,EK=FK),ENV) =
             {type-of(E1,ENV)?F1,...,type-of(EK,ENV)?FK}


File: april.info,  Node: Function application expression type,  Next: Type of constructor function expressions,  Prev: Record literal type,  Up: Type derivation

4.5.4.9 Function application expression type
............................................

The type of a function application expression is computed as:

     type-of(F ARG, ENV) = TYPE
   where
     fresh(type-of(F,ENV)) = A => TYPE
     type-of(ARG,ENV) = A

where `fresh' is a function that `reifies' a type  - see *note Type
reification::. This process involves removing any quantifiers and
replacing the quantified variables with fresh variables not occurring
elsewhere in the program.


File: april.info,  Node: Type of constructor function expressions,  Next: Dot expression type,  Prev: Function application expression type,  Up: Type derivation

4.5.4.10 Type of constructor function expressions
.................................................

We can understand the types of constructor expressions (and enumerated
symbols) by seeing them as occurrences of `constructor functions'.

   A type declaration such as:

     tree(%a) ::= empty | node(tree(%a),%a,tree(%a))

introduces two new `functions' - `empty' and `node'. The type of the
`node' function is given as:

     %a-(tree(%a),%a,tree(%a) => tree(%a))

An expression such as:

     node(empty,"foo",empty)

can then be typed using the same type rules as for regular functions, in
this case the type is

     tree(string)

The `empty' symbol is associated with the type:

     tree(%a)

where `%a' is a new type variable, and any occurrence of `empty' in the
text of the program will be given a similar type.


File: april.info,  Node: Dot expression type,  Next: valof expression type,  Prev: Type of constructor function expressions,  Up: Type derivation

4.5.4.11 Dot expression type
............................

The type of a ``.'' expression is determined as follows:

     type-of(R.E,ENV) = type-of(E,type-of(R,ENV)\/ENV)

I.e., we compute the type of the record R and compute the type of E in
an environment that has been extended by the set that forms the type of
R. This extension is similar to a union - except that the elements in
the type of R override any prior types associated with names that match
the fields of R.


File: april.info,  Node: valof expression type,  Next: collect/setof expression type,  Prev: Dot expression type,  Up: Type derivation

4.5.4.12 `valof' expression type
................................

The type of a `valof' expression is the type of the expression
associated with the `valis' statements within the `valof' body. The
types associated with each `valis' statement must all agree within a
given `valof' body.


File: april.info,  Node: collect/setof expression type,  Next: any expression type,  Prev: valof expression type,  Up: Type derivation

4.5.4.13 `collect'/`setof' expression type
..........................................

The type of a `collect' or `setof' expression is `TV[]' where TV is the
type associated with all the `elemis' statements occurring within the
body of the `collect' or `setof'.


File: april.info,  Node: any expression type,  Next: Function type,  Prev: collect/setof expression type,  Up: Type derivation

4.5.4.14 any expression type
............................

An `any' expression is used to partially escape the type inference
system. However, there is still some type inference involved in an
`any' expression:

     type-of(any(EXP),ENV) = any

where the type of the expression EXP is still computed. (It is not used
directly during normal type inference.)


File: april.info,  Node: Function type,  Next: Procedure type,  Prev: any expression type,  Up: Type derivation

4.5.4.15 Function expression type
.................................

There are two cases for functions - equations and function union. The
type of a function equation is determined as follows:

     type-of(PTN => EXP, ENV) =
             generalize(type-of(PTN,ENV)=>type-of(EXP,EXTE))

where EXTE is computed as:
     EXTE = EnvOf(PTN,ENV)
   where `EnvOf' extends the `Env' with new type variables for each of
the variables declared within the head pattern of PTN and `generalize'
is a function that `generalizes' the type computed by `type-of' - see
*note Type abstraction::.

   Where a _function union_ is concerned, the type is derived from the
component functions:

     type-of({F | G },ENV) = TYPE
     where
             TYPE = type-of(F,ENV)
     and
             TYPE = type-of(G,ENV)

I.e., the types of the two components of the function union are
determined, and their types must be the same. In the type inference
algorithm, this is achieved using type unification.


File: april.info,  Node: Procedure type,  Prev: Function type,  Up: Type derivation

4.5.4.16 Procedure type
.......................

As for functions, there are two kinds of procedures: a clause and a
procedure union. The type of a procedure clause is determined as
follows:

     type-of(PTN{STMT}, ENV) =
             generalize(type-of(PTN,ENV){})
     where
     stmt-type-constraint(STMT,EXTE)

where EXTE is computed as:
     EXTE = EnvOf(PTN,ENV)
   and where `stmt-type-constrain' enforces type constraints implied by
the statements in STMT.

   Note that `April' restricts the type of the arguments of a procedure
to be a tuple form.


File: april.info,  Node: Types and patterns,  Next: Types and statements,  Prev: Type derivation,  Up: Types and type inferencing

4.5.5 Types and patterns
------------------------

A pattern also has a type associated with it; however, in addition to a
type, a pattern also has an `output' environment. In many situations, a
variable in a pattern has scope that extends beyond the pattern itself.
Therefore, in the elaboration of the types of patterns below, we
describe the `tP' function which takes the general form:

     tP(PTN,ENV) = (TYPE,NEW-ENV)

* Menu:

* Numeric pattern type::
* Literal symbol pattern type::


File: april.info,  Node: Numeric pattern type,  Next: Literal symbol pattern type,  Up: Types and patterns

4.5.5.1 Numeric pattern type
............................

The type of a numeric literal pattern is `number':

     tP(N,E) = (number,E) where N is a number

Notice that the environment is not extended by this type of pattern.


File: april.info,  Node: Literal symbol pattern type,  Prev: Numeric pattern type,  Up: Types and patterns

4.5.5.2 Literal symbol pattern type
...................................

The type of a literal symbol expression is `symbol':

     tP('S,E) = (symbol,E)
     tP(''S,E) = (symbol,E)


File: april.info,  Node: Types and statements,  Next: Type parameters,  Prev: Types and patterns,  Up: Types and type inferencing

4.5.6 Types and statements
--------------------------

Generally, statements do not themselves have a type - they are not
values - but they do give rise to new type expressions and type
constraints. While a statement does not have a type, it can be said to
have an _environment_ associated with it. The environment makes
explicit the scope of program variables as they appear in the program.

   Thus for any statement, we can ask what its effect is on the
environment:

     env-of(S,ENV)

where ENV is the environment of the statement's context: i.e., the
environment associated with the statement in which `S' is embedded.

* Menu:

* variable declaration statement type environment::
* assignment statement type environment::
* match statement type environment::
* statement sequence type environment::
* conditional statement type environment::


File: april.info,  Node: variable declaration statement type environment,  Next: assignment statement type environment,  Up: Types and statements

4.5.6.1 Variable declaration statement type environment
.......................................................

A variable declaration statement takes the form:

     X : E

for a mutable variable, or

     X = E

for a non-mutable variable. In either case, this results in an extended
environment which contains the new variable X:

     env-of(X : E,ENV) = NEW-ENV where
       NEW-ENV = extend-env(X,ENV) and
       type-of(X,NEW-ENV) = type-of(E,ENV)
     env-of(X = E,ENV) = NEW-ENV where
       NEW-ENV = extend-env(X,ENV) and
       type-of(X,NEW-ENV) = type-of(E,ENV)


File: april.info,  Node: assignment statement type environment,  Next: match statement type environment,  Prev: variable declaration statement type environment,  Up: Types and statements

4.5.6.2 Assignment statement type environment
.............................................

An assignment statement, which is of the form:

     LHS := RHS

induces the type constraint:

     type-of(LHS,ENV) = type-of(RHS,ENV)
     env-of(LHS := RHS,ENV) = ENV

I.e., an assignment statement does not extend the environment in any
way, and variables which may be declared within RHS do not extend their
scope beyond the assignment statement.


File: april.info,  Node: match statement type environment,  Next: statement sequence type environment,  Prev: assignment statement type environment,  Up: Types and statements

4.5.6.3 Match statement type environment
........................................

A match statement, which is of the form:

     LHS .= RHS

also induces the type constraint:

     env-of(LHS=RHS,ENV) = NEW-ENV where
       NEW-ENV=extend-env(LHS,ENV) and
       type-of(LHS,NEW-ENV) = type-of(RHS,ENV)

Note that a match statement can introduce variable declarations, and
this is reflected in the fact that the environment is extended as a
result of the match statement - as well as introducing a type
constraint.


File: april.info,  Node: statement sequence type environment,  Next: conditional statement type environment,  Prev: match statement type environment,  Up: Types and statements

4.5.6.4 Statement sequence type environment
...........................................

A sequence of statements - separated by the `;' operator - does not
itself extend the environment, although the environment may be extended
within the sequence:

     env-of(S1;S2,ENV) = ENV where
       NEW-ENV = env-of(S2,env-of(S1,ENV))

I.e., the environment of S2 is extended by S1, but that extension is
not communicated out of the sequence. In practice this rule enforces
`April''s scope rules for statement sequences.


File: april.info,  Node: conditional statement type environment,  Prev: statement sequence type environment,  Up: Types and statements

4.5.6.5 Conditional statement type environment
..............................................

In the case of a conditional statement:

     if TEST then
       S1
     else
       S2

the environment for ``then'' statement S1 is the same as the extended
environment; however, the environment for the ``else'' statement S2 is
_not_ extended by the TEST.

   As a whole, a conditional statement does not extend the environment
of any sequence of statements that it is embedded within.

     env-of(if TEST then S1 else S2,ENV) = ENV where
       ENV1 = env-of(S1,extend-env(TEST,ENV)) and
       ENV2 = env-of(S1,ENV)


File: april.info,  Node: Type parameters,  Prev: Types and statements,  Up: Types and type inferencing

4.5.7 Type parameters
---------------------

A user type definition (of either variety) may contain _type
parameters_. These parameters are interpreted by the type checker as
names of type variables; in particular they are `generic' type
variables.

   A type definition of the form:

     user(%alpha,...,%beta) ::= BODY

introduces type variables %ALPHA ... %BETA for each different
occurrence of a value of type `user(...)'.


File: april.info,  Node: Expressions,  Next: Patterns,  Prev: Data values and types,  Up: Top

5 `April' expressions
*********************

The legal expressions in a programming language can be classified into
`value expressions' - such as arithmetic or list expressions - and
`syntax expressions' - which reflect syntactic constructs in the
language. A common example of a syntax expression found in many
programming languages is the conditional expression - *note conditional
expression::.

   In this chapter we focus on the format of `April' expressions,
particularly on those features which are novel in `April'. The
available value expressions are documented in other chapters.

* Menu:

* Value expression forms::
* Syntactic expression forms::  Special `April' expressions


File: april.info,  Node: Value expression forms,  Next: Syntactic expression forms,  Up: Expressions

5.1 Value expression forms
==========================

Many of the value expression forms are described in *Note Data values
and types::. In this section we show some of the other value expression
forms.

* Menu:

* Function application expression::


File: april.info,  Node: Function application expression,  Up: Value expression forms

5.1.1 Function application expression
-------------------------------------

A function application expression takes the form:

     FUN ARG

where FUN and ARG are also all expressions. In the case of the FUN
expression, it should evaluate to a function value. In the case of ARG,
it will often evaluate to a tuple of arguments; the value of the
expression is the result of applying the function to the arguments
ARG1,...,ARGK.

   Note that FUN may be a _literal_ function value, in which case this
expression is analogous to a `case' expression (*note case expression::.

   Functions, and function values are described more fully in *note
Function::.


File: april.info,  Node: Syntactic expression forms,  Prev: Value expression forms,  Up: Expressions

5.2 Syntactic expressions forms
===============================

`April' has a relatively rich collection of syntax expressions as well
as a rich collection of value expressions. Typically, an `April' syntax
expression relates the value of an expression to the execution of one
or more _statements_.

* Menu:

* valof expression::            Execute statements in an expression
* onerror expression::
* exception expression::
* collect expression::          Collect a list of values
* setof expression::
* case expression::             Switch on an expression
* conditional expression::
* type coercion::
* theta expression::
* Dot expression::              Accessing elements of records


File: april.info,  Node: valof expression,  Next: onerror expression,  Up: Syntactic expression forms

5.2.1 `valof' expression
------------------------

The `valof' expression allows the value of an expression to be
determined as a result of executing one or more statements. The form of
the `valof' expression is:

     valof STATEMENT

where STATEMENT should include an `valis' statement:

     valis EXPRESSION

The value of the VALOF expression - and its associated type - is the
value (and type) computed by the `valis' statement. Executing a `valis'
statement inside the body of the `valof' also terminates the body.

   For example, one way of expressing classical conditional expression
in *note conditional expression:: is to use a standard
`if'-`then'-`else' statement together with the `valof' expression:

     valof {
       if TEST then
         valis EXP1
       else
         valis EXP2
     }

The type of a `valof' expression is determined by the types of the
expressions associated with any `valis' statements embedded in the
body, all of which must have the same type.

   Note that if no `valis' statement is executed in the body of the
`valof' statement, a run-time error exception is raised. This exception
has as its error code the string `"valof exception"'. See *Note onerror
statement:: for the standard method of handling and recovering from
run-time errors.


File: april.info,  Node: onerror expression,  Next: exception expression,  Prev: valof expression,  Up: Syntactic expression forms

5.2.2 `try'...`onerror' expression
----------------------------------

A `try'...`onerror' expression allows a programmer to handle failure
within an expression. It is related to the `try'...`onerror' statement
(*note onerror statement::).

   The form of a `try'...`onerror' expression is:

     try
       EXP
     onerror
       FUN

where EXP is evaluated, and if successful, becomes the value of the
entire expression. If a run-time exception is raised during the
evaluation of EXP, then EXP is terminated, and FUN is entered.

   FUN is a single-argument function, whose argument is of type `error'
(*note error type::).  It is applied to the error code generated as a
result of the run-time exception. The value returned by FUN becomes the
value returned by the entire `try'...`onerror' expression.

   Note that typically, the error-handling FUN is given explicitly as a
set of cases of a `case' expression:

     X = {
            {
              if I < 10 then I
              else
                exception error("Foo", 'foo)
            } onerror {
               error("Foo", _) => 20
            }
         };


File: april.info,  Node: exception expression,  Next: collect expression,  Prev: onerror expression,  Up: Syntactic expression forms

5.2.3 `exception' expression
----------------------------

The `exception' expression does not have a value, although it does have
an argument!  Instead it forces the termination of current evaluation,
and causes the generation of a run-time exception. The exception
generated is based on the argument of the `exception' expression:

     exception EXP

This value is `collected' by the right hand side of the `onerror'; in
this case by matching against the `error()' pattern and returns a
default value.


File: april.info,  Node: collect expression,  Next: setof expression,  Prev: exception expression,  Up: Syntactic expression forms

5.2.4 `collect' expression
--------------------------

The `collect' expression allows a list of values to be computed - as
the result of a statement. The form of a `collect' expression is:

     collect STATEMENT

where STATEMENT is expected to contain at least one `elemis' statement.
The `elemis' statement(s) represent the elements of the resulting list
- each time an `elemis' statement is executed, the value associated
with it is added to the end of the list being constructed.

   We can use `collect' expressions in many situations, it allows a
powerful and expressive way of determining the elements of a list. For
example, the common MAP higher-order operator can be represented as a
`collect' expression. A MAP expression such as

     L // double

where `L' is a list of numbers and `double' is a single argument
function that doubles its argument, can be represented using the
`collect' expression:

     collect {
       for I in L do
         elemis double(I)
     }

The `list collection' is terminated when the STATEMENT body of the
`collect' expression terminates. The type of the `collect' expression
is a list of the type associated with the `elemis' statements. All the
`elemis' statements inside a given `collect' body must agree to a
common type.

   Note that if _no_ `elemis' statements are executed in a `collect'
body, then the result is the empty list.

   The `collect' expression is a unique feature of `April'. `collect'
has an interesting `history'. In standard mathematics, it is common to
represent sets using _set abstractions_. A set abstraction is a way of
writing down the elements of a set without enumerating them explicity;
for example, the set abstraction:

     { X | X in L & X<5 }

represents the set of elements of `L' which are smaller than 5.
`April''s `collect' expression is a direct representation of a similar
expressive power but relating to lists rather than sets.


File: april.info,  Node: setof expression,  Next: case expression,  Prev: collect expression,  Up: Syntactic expression forms

5.2.5 `setof' expression
------------------------

The `setof' expression is similar to the `collect' expression, except
that the resulting list is sorted with duplicates removed - i.e., a set
is returned ratehr than a bag.  The form of a `setof' expression is:

     setof STATEMENT

where STATEMENT is expected to contain at least one `elemis' statement.
The `elemis' statement(s) represent the elements of the set.

   _Hint:_

     Using the raw `collect' expression/statement to `capture' set
     abstractions can sometimes lead to complicated code. The set
     abstraction notation in *Note Lists and set abstractions::
     considerably `raises the level' of `collect' and `setof'
     expressions.


File: april.info,  Node: case expression,  Next: conditional expression,  Prev: setof expression,  Up: Syntactic expression forms

5.2.6 `case' expression
-----------------------

The `case' expression allows the value of an expression to be
determined by cases in the value of a governing expression.

   The form of the `case' expression is:

     case EXP in {
       PTN1 => E1
     | ...
     | PTNK => EK
     }

where PTNI are all PATTERNS compatible with EXP, and expressions EI are
all expressions of the same type. The value of a `case' expression
depends on the first pattern PTNI that matches EXP. This pattern
selects a corresponding expression - EI - which is the value returned
by the `case'.

   The patterns PTNI can declare variables - whose scopes extend to the
corresponding selected expressions.

   At least one of the matching patterns PTNI must match the value of
the expression EXP; if none do, then a `failed' exception will be
raised; *Note onerror expression::.

   Note that the `case' expression is the only form of expression that
can involve values with disjunctive types. If the governing expression
EXP is of a disjunctive type, then the individual matching patterns can
separately handle the different cases of the disjunctive type.

   Note that the body of the `case' expression takes the form of a
disjunction of equations - i.e., it takes  the form of a function. This
is not an accident: the body of a `case' expression is indeed a
function. It is possible to supply the function in a `case' expression
in a different style; for example as the value of a variable:

     case EXP in FUN_VAR

The `case' expression is discussed more fully in *Note Case expression
as a function call::.


File: april.info,  Node: conditional expression,  Next: type coercion,  Prev: case expression,  Up: Syntactic expression forms

5.2.7 Conditional expression
----------------------------

An expression such as in:

     I := {if I>10 then I-1 else I+1 }:

is a _conditional expression_. The predicate part of the expression is
evaluated, and depending on whether it evaluates to `true' or `false',
the value of the complete expression is EXP1 or EXP2 respectively.

   Conditional expressions are useful in the definition of simple
functions as well as in statements:

     app(X,Y) => {
       if [?El,..?Z] .= X then [El,..app(Z,Y)]
       else Y
     }

Conditional expressions are equivalent to a specific use of the `valof'
construct. The above function definition is entirely equivalent to:

     app(X,Y) => valof {
       if [El,..Z] .= X then valis [El,..app(Z,Y)]
       else valis Y
     }


File: april.info,  Node: type coercion,  Next: theta expression,  Prev: conditional expression,  Up: Syntactic expression forms

5.2.8 Type coercion expression
------------------------------

A type coercion expression can be used to convert values of one type
into another. Of course not all values are convertible, but `April'
attemptsto be as generous as possible in this area.

   The form of a type coercion expression is:

     TYPE %% E

The type of such an expression - provided it has a value - is always
TYPE. However, not all forms of type coercion are legal. In particular,
type coercions involving programs are only legal if the type of the
input expression is convertible to a value of the required type.

   The legal transformations supported by `%%' are:

TYPE to TYPE
     Any null-coercion is allowed. This refers to the situation where
     the type of the input is already of the required type of the
     output.

TYPE to `string'
     Any `April' value may be coerced to a `string' value. However,
     this coercion is not guaranteed to be reversable: in particular,
     the result of coercing functions and procedures to `string' values
     only results in a display of the type of the function or procedure.

`string' to `number'
     A `string' value may be converted to a `number' value, provided
     that the contents of the string can be said to represent a
     `number' using `April''s normal rules for the syntax of numbers.

tuple to/from record
     A tuple of values may be coerced to or from a record of values,
     provided that successive elements of the tuples are coercible
     to/from the corresponding record elements.

Note that it is _not_ permitted to coerce a value to type `any', or a
type involving `any'.


File: april.info,  Node: theta expression,  Next: Dot expression,  Prev: type coercion,  Up: Syntactic expression forms

5.2.9 Theta expression
----------------------

In some situations, a record can be viewed as a kind of binding
environment. The fields of the record introduce `variables' which have a
certain scope. In the case of regular anonymous records and labelled
tuples the scope of the field variables does not extend to the values
defined in a given record literal itself. In the case of theta
expressions, the scope of fields _includes_ the fields themselves.

   A theta expression is written using semi-colon to separate a sequece
of fields; each of which is denoted either by an `=' - for a read-only
definition - or by a `:' for a read/write definition.(1)

     {
       FIELD1;
       ...
       FIELDK
     }

In the case of the `:' form of field declaration, the field may be
_updated_ by procedures and functions defined within the _same_ theta
record. An `=' field defines a read-only value that cannot be updated.
In either case, no field of a theta record is updateable directly by
procedures or functions which are defined _outside_ the theta - on the
other hand, such an `outside' procedure or function may invoke an
updating procedure that is `inside' the theta.

   Theta expressions are described more fully in *note programs and
theta expressions::.

   ---------- Footnotes ----------

   (1) In the case that there is only a single field, then it must be
followed by a semi-colon ``;'' in order to distinguish the expression
as a theta expression.


File: april.info,  Node: Dot expression,  Prev: theta expression,  Up: Syntactic expression forms

5.2.10 Dot expression
---------------------

The `dot' expression allows elements of a record to be accessed by field
name. The form of a dot expression is:

     R.E

where R on the left hand side of the dot expression must be a record
type, and E on the right hand side can be any expression.

   The meaning of a dot expression can be summarized as follows: if the
type of R is a record with fields F1 to FK, then the value of R.E is
the value of E where F1 to FK act as _read-only variables_ whose values
are extracted as the corresponding fields of R.

   In addition to the fields of R being declared, the value of R itself
is also available within E - as the value of the standard variable
`environment'. This is convenient for cases where R is a complex
expression - such as the returned value of a function - where both the
entire value and the internal fields are required in some expression.

   This is slightly different to `standard' record accessing operators
where the right hand side of dot expressions is restricted to a single
field name of R. This form of record accessing allows multiple fields
of a record to accessed in a single expression, and it allows
expressions to involve the combination of several records.

   For example, if R is a record variable, of type:

     (number?i,number?j,string?a)

then the expression:

     R.(i+j)

has as its value the value of the I field and the J field of R added
together.

   An important feature of `April''s dot operator is that the
expression E does not need to refer exclusively to elements of R - it
may additionally refer to other variables currently within the scope of
E.(1) Furthermore, it is possible to `nest' record access; as in the
expression:

     R.(S.(i+k))
   where I is a field of R and K is a field of S.

     _Hint:_ theta expressions are also defined to be records, and we
     can use record access to access elements of such expressions. For
     example, in the expression

          {
            fact = {
              0 => 1
            | X => X*fact(X-1)
            };
          ...
          }.fact

     we `export' the definition of `fact' from the theta record
     expression. This is an effective way of defining the semantics of
     a system of modules.

   _Note:_

     There is a subtle difference between an expression such as:

          R.f(A)

     and the expression:
          (R.f)(A)

     They both apply the function `f' found in `R' to argument `A'.
     However, the former may `find' `A' in `R' whereas the latter will
     not look in `R' for any definition of `A'.

     This can lead to mysterious problems where both `R' and the current
     scope has a definition for `A'.

   ---------- Footnotes ----------

   (1) It does not even need to refer to _any_ of R's fields.


File: april.info,  Node: Patterns,  Next: Statements,  Prev: Expressions,  Up: Top

6 Patterns and pattern matching
*******************************

In `April', patterns are ubiquitous: they are used in handling
messages, processing lists, specifying macros and the formal parameters
of functions and procedures. Patterns are important because the
programming style they encourage - pattern directed computation - is
often much easier to design and understand than purely `value-driven'
computation.

   Note however that not all values in `April' are comparable - in
particular functions and procedures may not be tested for equality. It
is posible to have a _pattern_ that matches a function or procedure;
but it is not possible to verify that a given procedure or function is
the same procedure as another.

   As for values, we classify patterns into primitive patterns and
compound patterns.

* Menu:

* Primitive patterns::          Basic patterns
* List and other compound patterns::  Patterns involving complex values
* Types as patterns::
* String patterns::             Patterns for matching and parsing strings


File: april.info,  Node: Primitive patterns,  Next: List and other compound patterns,  Up: Patterns

6.1 Primitive patterns
======================

The  primitive patterns correspond to the primitive data types.

* Menu:

* number pattern::              Match a number
* symbol pattern::              Match a symbol
* string pattern::              Match a string
* Variable declaration::
* Anonymous variable pattern::
* any pattern::


File: april.info,  Node: number pattern,  Next: symbol pattern,  Up: Primitive patterns

6.1.1 `number' pattern
----------------------

The `number' pattern matches any numeric value. The type of the
`number' pattern is also `number'. Note also that a literal number is
also a pattern. In this case, the pattern will only match that
particular number.


File: april.info,  Node: symbol pattern,  Next: string pattern,  Prev: number pattern,  Up: Primitive patterns

6.1.2 `symbol' pattern
----------------------

The `symbol' pattern matches symbolic values. The type of the `symbol'
pattern is also `symbol'.

   In addition to the `symbol' pattern, literal symbol expressions are
also patterns. Recall that a literal symbol is written using a quote
prefix:

     'foo

Such a pattern only matches the particular identified literal `symbol'.


File: april.info,  Node: string pattern,  Next: Variable declaration,  Prev: symbol pattern,  Up: Primitive patterns

6.1.3 `string' pattern
----------------------

The `string' pattern matches strings - of any length. The type of the
`string' pattern is also `string'. There is a rich class of string
patterns which are further discussed in *Note String patterns::.


File: april.info,  Node: Variable declaration,  Next: Anonymous variable pattern,  Prev: string pattern,  Up: Primitive patterns

6.1.4 Variable declaration pattern
----------------------------------

A variable is declared in a pattern by its first occurrence - there
does not need to be any special marking identifying the variable. Note
that subsequent occurrences of an identifier will refer to the same
variable; including situations where the variable was first declared in
an outer scope.  

   For example, in the function:

     gp(X) => collect {
       for (X,Y) in parent do
         for (Y,Z) in parent do
           elemis (X,Z)
     }

The variable `X' is the same variable throughout, and refers to the
parameter of the function. On the other hand, the variable `Y' is first
declared in the pattern:

       for (X,Y) in parent do

and is used again in the pattern:

         for (Y,Z) in parent do

Similarly, this pattern declares a new variable `Z' which is referred
to in the body of the `for'...`do' statement.

   In addition to variables declared automatically, they can also be
declared explicitly in a pattern, using the form:

     TYPE?VAR

This declares a new variable - even if a variable of the same name
already exists - and also identifies its type.

   For example, the pattern:

     number ? X

declares `X' to be a `number' variable.

   _Note:_

     A variable that is declared in a pattern is a _single-assignment_
     or _read-only_ variable. This means that the variable may not be
     side-affected by any statement that is `controlled' by the pattern
     - for example within the right hand side of a message `receive'
     clause.

     This includes formal parameters of functions and procedures, since
     semantically the formal parameters of a function equation or
     procedure clause are derived by means of patterns.


File: april.info,  Node: Anonymous variable pattern,  Next: any pattern,  Prev: Variable declaration,  Up: Primitive patterns

6.1.5 Anonymous variable pattern
--------------------------------

A `_' symbol occurring on its own in a pattern signifies a `wild card'
or anonymous variable pattern. `_' will match any value - and the value
is ignored. `_' patterns are useful as placeholders in more complex
patterns where only part of the structure needs to be matched against.


File: april.info,  Node: any pattern,  Prev: Anonymous variable pattern,  Up: Primitive patterns

6.1.6 Encapsulated value patterns
---------------------------------

The `any' pattern allows the value embedded inside an encapsulated
`any' value to be `extracted'. The form of the `any' pattern is:

     any(PTN)

Such a pattern will match an encapsulated value, such as produced using
the `any' expression (*note any type::), providing that the actual type
of the encapsulated value is the same as the type of PTN.(1)

   This type comparison must typically be done at run-time rather than
at compile time since it is often not known what the type of the
embedded value is until then. This dynamic aspect of `any' values is
one of their most important attributes; it allows programs to manipulate
arbitrary values in a type-consistent manner.

   ---------- Footnotes ----------

   (1) This is new in version 4.2.7.


File: april.info,  Node: List and other compound patterns,  Next: Types as patterns,  Prev: Primitive patterns,  Up: Patterns

6.2 List and other compound patterns
====================================

* Menu:

* List pattern::                Match a list of elements
* Append pattern::
* Tuple pattern::               Match a tuple of elements
* record pattern::
* labelled type pattern::
* handle pattern::              Match a handle
* Guarded pattern::             Attach a test to a pattern


File: april.info,  Node: List pattern,  Next: Append pattern,  Up: List and other compound patterns

6.2.1 List pattern
------------------

A list pattern mimics the from of the list expression; the empty list -
`[]' - matches the empty list, and the list pattern:

     [HEAD,..TAIL]

matches a non-empty list provided that the head of that list matches
HEAD and the remainder of the list matches TAIL.

   For example, the list pattern in:

     case X in {
       [?H,..?T] => ...
     ...
     }

matches a non-empty list, and binds the variable `H' to the first
element of the list, and `T' to the tail of the list. The type
associated with `H' is the `element type' of `X' and the type
associated with `T' is the same as the type of `X'.


File: april.info,  Node: Append pattern,  Next: Tuple pattern,  Prev: List pattern,  Up: List and other compound patterns

6.2.2 Append pattern
--------------------

A list pattern may also take the form of two or more list fragments
appended together - using the `<>' operator.  The pattern

     L1 <> L2

will nondeterministically split a list into two partitions: L1 and L2 -
which may have further constraints on them. For example, the pattern in
the condition:

     if ['head] <> L1 <> ['middle] <> L2 <> ['end] .= List then

will `parse' the `List' into 5 sections:
  1. The head of the list must be the symbol `'head'

  2. Then there is a fragment of the list which may contain anything.
     This fragment is bound to the variable `L1'

  3. Then there is a symbol `middle' in the middle of the list.

  4. Then there is another fragment of the list - which is bound to the
     variable `L2'

  5. The end of the list is marked with the symbol `'end'.

Note that using list append patterns may be quite expensive since the
list may have to be decomposed in an arbitrary way. In general this may
lead to exponential time matching of the input list.


File: april.info,  Node: Tuple pattern,  Next: record pattern,  Prev: Append pattern,  Up: List and other compound patterns

6.2.3 Tuple pattern
-------------------

A tuple pattern is written using the normal tuple notation. Where the
elements of the tuple themselves may declare variables with the variable
pattern, it also has the effect of declaring local variables. If we have
the receive clause:

     (V1,...,VK) ->> S

in a message receive statement (*note Receiving messages::) then this
clause will fire with a k-tuple and will bind local variables V1...VK
during the execution of S.


File: april.info,  Node: record pattern,  Next: labelled type pattern,  Prev: Tuple pattern,  Up: List and other compound patterns

6.2.4 Record pattern
--------------------

A record pattern is written as a tuple of the fields of the record where
each field pattern is of the form:

     PTN.=FIELD

Where a field is to be ignored an anonymous variable can be used. For
example, given a value of type:

     (string?name,number?age,string?dept)

We can match the `name' and `age', ignoring the `dept' using the
pattern:

     (N.=name,A.=age,_)

where N and A are patterns that will be matched against the `name' and
`age' fields respectively.

   Note that all the fields must be present, the ignored ones should be
marked with an anonymous variables, in the correct order. Note also that
the pattern:

     (N,A,_)

_would_ match a value of the above type (assuming that `N' and `A' are
new variables). However the types of these variables may surprise you:
the type associated with `N' would be the singleton record:

     string?name

not simply `string'. Thus to access the value of `N' one would need to
use an expression of the form: `N.name'. This is also true in reverse;
i.e., if `N' were a variable of this type, then

     (N,age=30,dept="finance")

is a legal instance of a record, and its type is also:

     (string?name,number?age,string?dept)


File: april.info,  Node: labelled type pattern,  Next: handle pattern,  Prev: record pattern,  Up: List and other compound patterns

6.2.5 labelled type pattern
---------------------------

A labelled pattern simply consists of the label and a pattern that
should match the legal arguments of the label - as determined by the
type definition where the label is introduced.

   For example, given the definition of `tree':

     tree(%s) ::= empty | node(tree(%s),%s,tree(%s))

A `node' pattern may look like:

     node(l,lb,r) ->> ...

This pattern matches a `node' labelled type, involving three variables
`l', `lb' and `r' which are bound to the three elements of the `node'
structure. If the input is a `node' labelled type then the three
variables will be bound to the elements of the labelled tuple.

   Note that where a labelled term is really a labelled record - again
as per the type definition where the label is introduced - then the
argument of the labelled pattern must also be a record of the
appropriate form.


File: april.info,  Node: handle pattern,  Next: Guarded pattern,  Prev: labelled type pattern,  Up: List and other compound patterns

6.2.6 `handle' pattern
----------------------

Process handles are generated when processes are forked and are often
passed within messages.

   There are two major ways of denoting a `handle' in a pattern: the
`handle' keyword denotes a `handle' pattern - it matches any `handle' -
and the `hdl' constructor term.  The type of a `handle' pattern is also
`handle'.

   A `hdl' labelled tuple is a pattern based on the pre-defined type
declaration:

     handle::= nullhandle | hdl(symbol,symbol);

where the first element is the _thread_ identifier and the second is the
_name_ of a group of threads - typically implementing an agent.
`nullhandle' is the handle of no possible process.

   The actual representation of a `handle' is not guaranteed to be
identical to this labelled record; however, the `April' programmer can
rely on these fields being present in a handle.

   The `hdl' record pattern can be used to filter out messages based on
properties of the `handle':

     receive
       PTN::(hdl(_,nme)::nme in ALLOWED).=sender ->> ...

assumed that ALLOWED is a list of the allowed names that this process
wishes to receive messages from.


File: april.info,  Node: Guarded pattern,  Prev: handle pattern,  Up: List and other compound patterns

6.2.7 Guarded pattern
---------------------

A pattern of the form:

     PTN :: TEST

is a _guarded pattern_. This pattern applies if both PTN applies and
the predicate TEST evaluates to `true'. Note that variables declared in
PTN or TEST _may_ extend their scope outside the pattern - depending on
the context of the guarded pattern. In the case of variables declared
within TEST variables that are declared at the top-level of `Test' may
extend their scope.  

   For example, in:

     I ::  K .= I && ( J .= K || L .= I*I )

variables `I' and `K' extend their scope outside the guarded pattern
but `J' and `L' do not - since they are declared within a disjunction
in the test.


File: april.info,  Node: Types as patterns,  Next: String patterns,  Prev: List and other compound patterns,  Up: Patterns

6.3 Types as patterns
=====================

Any type can also be pressed into service as a pattern, by including it
in a query pattern - i.e., a variable defining pattern. For example,
the `tree' type:

     tree(%a) ::= empty | node(tree(%a), %a, tree(%a));

can also be used in patterns. This is useful when sending values of such
types in messages. If a user-defined type is used as a pattern, care
must be taken with type parameters:

     tree(number)?X ->> ...

One particular use for this is in receiving functions and procedures in
messages.

   For example, in the message receive clause:

     (exec,{(handle)=>string}?F) ->> ...

we are looking for a 2-tuple, whose second element is a function from
`handle's to `string's. A function pattern matches a function whose
type is unifyable with the argument types and result type given in the
pattern.

   Note that it is not possible to verify that a given function is the
same as another one: i.e., in the above pattern we cannot include a
further test of `F' of the form:

     (exec,{(handle)=>string}?F)::F==G ->> ...

This is because functions are not comparable with each other.


File: april.info,  Node: String patterns,  Prev: Types as patterns,  Up: Patterns

6.4 String patterns
===================

`April' has a few simple but powerful matching operators for matching
strings. These allow a string to be partitioned, a string segment to be
tested against a list of literal strings and for an arbitrary value to
be `read' from a string.

* Menu:

* Character matching::
* String partitioning::         Splitting a string via matching
* Fixed width string pattern::
* Membership test::
* Value extraction::


File: april.info,  Node: Character matching,  Next: String partitioning,  Up: String patterns

6.4.1 Character matching
------------------------

A string is formed of a sequence of characters, and the `,+' pattern
can be used to match against the first character of a string. As a
pattern, `,+' is the compliment of its use as an expression (*note
string character prepend::).

   The `,+' pattern `splits' an incoming `string' into a lead character
- which is of type `symbol' - and remainder string. If the incoming
`string' is empty, then the `,+' pattern fails.

   For example, the pattern:

     C,+A .= STRING_VALUE

puts the first character of STRING_VALUE into the variable `C', and the
remainder in `A'.(1)

   ---------- Footnotes ----------

   (1) This feature is not yet finalized.


File: april.info,  Node: String partitioning,  Next: Fixed width string pattern,  Prev: Character matching,  Up: String patterns

6.4.2 String partitioning
-------------------------

The string concatenation operator `++' can also be used in string
_patterns_. In this context, the behaviour of `++' is subtly different
to its normal behaviour: instead of joining two strings together to
form a new one, the `++' string matching operator splits the string
being matched into two portions. Recall that, in the context of
matching, the `result' value is always known: we are trying to match a
known value against a pattern.

   The `++' string match operator takes this known value and
non-deterministically splits it into a front portion and back portion.
The the string matching operands of the `++' operator must match the
front and back portions of the string as generated by the split.

   This, combined with `April''s existing matching operators, allows
some very powerful operations, for example to extract the substring
between a front and tail string, we can use:

     "front" ++ sub ++ "tail" .= STRING_VALUE

This has the effect of extracting the middle portion of STRING_VALUE
and assigning it to the variable SUB.


File: april.info,  Node: Fixed width string pattern,  Next: Membership test,  Prev: String partitioning,  Up: String patterns

6.4.3 Fixed width string pattern
--------------------------------

The `~' string pattern can be used to `pinch off' a fixed portion of a
string in a string pattern match. The form of this pattern is:

     PTN~W

This pattern matches a `string' - or a portion of a `string' if the `~'
is combined with a string concatenation operator - whose width is fixed
to the value of W - provided it also matches PTN.

   For example, the string pattern:

     C~1++R.=STRING_VALUE

extracts the first character of STRING_VALUE and puts it into the
variable `C'. The remainder of the string is placed in the `R' variable.

   The slightly more complicated example:

     (F++"*"++R)~10++L .= STRING_VALUE

matches the first 10 characters of the STRING_VALUE against the pattern:

     F++"*"++R

The variable `L' is bound to the remainder of the string value if a
`"*"' is found in the first 10 characters.(1)

   ---------- Footnotes ----------

   (1) The fixed width pattern is deprecated in version 4.2.7; use
character matching instead.


File: april.info,  Node: Membership test,  Next: Value extraction,  Prev: Fixed width string pattern,  Up: String patterns

6.4.4 Membership test
---------------------

The `in' test may be used in a string pattern to verify that a
sub-string is also a member of a list of strings. The form of this
string pattern is:

     VAR in STRING-LIST

For example, the `string' pattern in:

     front ++ X in ["alpha", "beta", "gamma"] ++ tail .= ...

will match a string such as `"majorbetaminor"' and bind the variables
`front', `X' and `tail' to the substrings `"major"', `"beta"' and
`"minor"' respectively.


File: april.info,  Node: Value extraction,  Prev: Membership test,  Up: String patterns

6.4.5 Value extraction
----------------------

The `%%' operator can be used to `read' a value from a string. The form
of this `string' pattern is:

     TYPE %% VAR

where TYPE is any type expression. This `string' pattern will parse the
string to verify that the string contains a TYPE value and binds the
variable VAR to that value.

   This operator is able to parse values of any legal `April' value.
For example, a number can be stripped from the front of a string using:

     number%%X ++ tail .= ...

Complex data values can also be parsed; for example a `tree' of
`number' values can be parsed using:

     tree(number)%%T ++ tail .= "node(empty,10,node(empty,12,empty))"

where a `tree' is defined using the type definition:

     tree(%a) ::= empty | node(tree(%a),%a,tree(%a))


File: april.info,  Node: Statements,  Next: Functions and procedures,  Prev: Patterns,  Up: Top

7 `April' statements
********************

`April' supports a rich range of statements, including standard
procedural operations and message handling operations.  In `April' we
classify statements into _primitive_ statements and _compound_
statements - primitive statements do not have other statements embedded
within them.

   In addition, there are a number of statements which are not
`primitive' in `April' - they are processed into combinations of
primitive statement. Typically, these refer to common programming
clichees - such as message handling streams.

* Menu:

* Primitive statements::        Statements with no internal structure
* Compound statements::         Composite statements
* Sending messages::            Sending messages between processes
* Receiving messages::          Handling messages sent to a process


File: april.info,  Node: Primitive statements,  Next: Compound statements,  Up: Statements

7.1 Primitive statements
========================

`April' has relatively few different kinds of primitive statement,
although there is a rich collection of built-in procedures.

* Menu:

* Variable declaration statement::  Declare variables in a procedure
* Assignment statement::        Reassign a variable to a new value
* Null statement::              No operation statement
* Procedure Call statement::    Invoke a procedure


File: april.info,  Node: Variable declaration statement,  Next: Assignment statement,  Up: Primitive statements

7.1.1 Variable declaration statement
------------------------------------

A variable declaration statement takes the one of the forms:

     PTN = E

or

     PTN : E

The declaration statements combine a pattern match with vairable
declaration. In the case of an `=' statement, the  embedded variables
are declared single-asignment or read-only; in the `:' form, the
variables are declared multi-assignment or read-write.

   In both cases the initial values of the variable(s) are taken from
the expression on the right hand side. Note that `April' does NOT
permit the declaration of a variable without an initial value.

   The scope of a variable introduced by means of a variable declaration
statement is from the first statement _after_ the declaration (i.e., V
is not is scope within the declaration statement itself) to the last
statement of the statement group that directly encloses the declaration.  

   Note that it is not permitted to `hide' a variable which was
previously in scope with a variable declaration statement. In other
words, if V already is a variable in scope then a "variable re-declared"
syntax error will be raised by the compiler.

   Since the left hand side of a variable declaration is a pattern, it
is possible that the pattern match might fail. In this situation, a
`"match error"' exception is raised.

   It is possible to explicitly indicate the type of the variable being
declared by using a `?' operator:

     T ? V : E

In this case, the compiler will verify that the type of the initial
value of the variable - E - is consistent with the type T.

   Note that any anonymous variables (i.e., the `_' pattern) in the
pattern on the left hand side of the declaration statement represent
components of the right hand side that are discarded: it is not possible
to have a variable whose name is `_'.  


File: april.info,  Node: Assignment statement,  Next: Null statement,  Prev: Variable declaration statement,  Up: Primitive statements

7.1.2 Assignment statement
--------------------------

There are two main forms of the assignment statement in `April'; the
first takes the form:

     VARIABLE := EXPRESSION

where VARIABLE is a previously declared read-write variable, and
EXPRESSION is a type-compatible expression.

   The second form of assignment is the _pattern assignment_. In this
form several variables can be assigned simultaneously. This allows, for
example, a tuple-valued function's results to be unpacked into separate
variables.  

   The form of pattern assignment is:

     `Ptn' := K-TUPLE EXPRESSION

Pattern assignment is used in two common situations, where the
right-hand-side of the assignment is a tuple-valued function call, and
where the right-hand side is an explicit tuple.  In the latter case the
order of evaluation is defined to be such that the order of variables
VI is not relevant. More precisely, a pattern assignment where the
right-hand side is a literal value, such as in:

     (V1,...,VK) := (E1,...,EK)

where EI may mention one or more variables from VI, is equivalent to:

     R : (E1,...,EK);
     (V1,...,VK) := R

where `R' is a variable that does does appear anywhere else in the
program text.

   Note that on occasion, especially with pattern assignment, not all
of the returned values are of interest. In this situation, the `_'
throw away variable is useful.

   When `_' is used as the target of an assignment it means to ignore
the result - just as when `_' is used in a pattern.  

   Suppose that a function returns a structure with three elements, as
in the case:

     foo(S) => (strlen(S),S, S++"More")

and we wish just the first component and third components; ignoring the
middle component. Using `_' we can achieve the desired result by using
a pattern assignment with the middle argument being ignored:

     (X,_,Z) := foo("Some string");

Note that we can also use `_' in the case where the _whole_ of the
returned value of a function is to be ignored:

     _ := foo("Some other data");

but, in the opinion of the author, frequent occurrences of statements
like this suggests a poor compromise in the design of the program.


File: april.info,  Node: Null statement,  Next: Procedure Call statement,  Prev: Assignment statement,  Up: Primitive statements

7.1.3 `Null' statement
----------------------

The `{}' statement is a 'no operation' statement. It does nothing,
binds no variables and returns no values. Its main use is in message
`receive' statements where a message is to be discarded.


File: april.info,  Node: Procedure Call statement,  Prev: Null statement,  Up: Primitive statements

7.1.4 Procedure Call statement
------------------------------

A procedure call statement takes the form:

     PROC(E1,...,EK)

where PROC is a procedure-valued expression, and EI are expressions
corresponding to the arguments of the procedure.

   Note that using `April' operators, a procedure call may be written
using operator syntax.

   Procedure call statements are discussed more fully in *Note
Procedure application::.


File: april.info,  Node: Compound statements,  Next: Sending messages,  Prev: Primitive statements,  Up: Statements

7.2 Compound statements
=======================

Compound statements are statement operators - they take other
statements as `arguments' to derive new forms of statement.

* Menu:

* Statement sequence::
* while statement::
* for statement::
* Conditional statement::
* case statement::
* dot statement::
* onerror statement::
* exception statement::
* Labelled statement::
* leave statement::


File: april.info,  Node: Statement sequence,  Next: while statement,  Up: Compound statements

7.2.1 Statement sequence
------------------------

Two statements which are to executed in sequence are separated by the
`;' operator. The execution of S1`;'S2 involves the execution of S1
followed by the execution of S2 - provided that S1 does not raise a
run-time exception.

   Note that in `April', the statement sequence operator `;' is a
statement _separator_ not a statement terminator. This can cause some
initial confusion, especially in the situation where S1 is itself a
compound statement.

   For example, in the case of:

     {
       S1;
       S2
     };
     S3

the trailing `;' after the `}' which terminates the S1 and S2 pair of
statements is necessary.

   Note that - strictly for convenience - the statement separator is
also a postfix operator. In this situation it has no effect.

   Where the first statement in a statement sequence is itself a
statement sequence - as in the example above - then variables declared
in S1`;'S2 are _not_ in scope in S3.


File: april.info,  Node: while statement,  Next: for statement,  Prev: Statement sequence,  Up: Compound statements

7.2.2 `while' statement
-----------------------

The `while' statement specifies a loop iteration. The form of a `while'
statement is:

     while TEST do
       STATEMENT

For each potential iteration of the `while' statement the TEST is
evaluated; if it evaluates to `true' then the STATEMENT is also
executed.

   Note that variables declared in TEST - in the case of a matching
test - extend their scope to the STATEMENT body of the `while' loop,
but not beyond. For example, in:

     while X .= foo(bar()) do
       S

the variable `X' is declared in the test of the `while', and its scope
extends to S but not to any statements following this `while' statement.  


File: april.info,  Node: for statement,  Next: Conditional statement,  Prev: while statement,  Up: Compound statements

7.2.3 `for' statement
---------------------

A `for' statement is a generator loop. The form of a `for' statement is:

     for PTN in LIST do
       S

where PTN is a pattern, and LIST is a list-valued expression.
Typically, `ptn' declares variables which may be accessed in S - but
not outside the `for' statement.

   For example, the `for' statement:

     for E in [1,3,5,-9] do
       E >> who

executes the statement

     E >> who

with `E' instantiated to 1, 3, 5, and -9. A common form of the `for'
statement corresponds to `for' statements in other programming
languages:

     for I in 1..10 do
       S

this will execute S 10 times, with `I' instantiated to 1,2,...,10.(1)

   ---------- Footnotes ----------

   (1) The compiler recognizes this form of `for' statement and is able
to generate `normal' loop iteration code for it.


File: april.info,  Node: Conditional statement,  Next: case statement,  Prev: for statement,  Up: Compound statements

7.2.4 Conditional statement
---------------------------

The `if'-`then'-`else' statement is either of the form:

     if TEST then
       S1
     else
       S2

or, if there is no `else' case, then it may be of the form:

     if TEST then
       S1

which is equivalent to:

     if TEST then
       S1
     else
       {}

If TEST evaluates to `true', then S1 is executed; otherwise S2 is
executed (or no statement is executed in the case that there is no
`else' branch).

   Variables declared in TEST extend to S1 (but _not_ to S2). Variables
declared in TEST, S1 or S2 do not extend outside the conditional
statement.


File: april.info,  Node: case statement,  Next: dot statement,  Prev: Conditional statement,  Up: Compound statements

7.2.5 `case' statement
----------------------

The `case' statement allows an expression to govern one of several
statements to execute. The form of the `case' statement is:

     case EXP in {
       PTN1 -> S1
     | PTN2 -> S2
     ...
     | PTNK -> SK
     }

where EXP is the so-called governing expression and PTNI are patterns
that are applied to the value returned by `exp'. The first of these
patterns that succeeds causes the corresponding statement to be
executed.

   If none of the patterns apply to EXP then a `failed' exception is
raised (*note onerror statement::).

   `case' statements are discussed further in *Note Case statement as a
procedure call::.


File: april.info,  Node: dot statement,  Next: onerror statement,  Prev: case statement,  Up: Compound statements

7.2.6 Dot statement
-------------------

The dot statement is analogous to the dot expression - it allows a
statement to be executed `in the context' of the value of a record. The
form of the dot statement is:

     R . STATEMENT

where R is a record and STATEMENT is any statement. For STATEMENT, the
set of variables in scope is extended by the fields of R; however, R's
variables are extended as read-only variables only.  

   The restriction that R's variables are read-only is to enforce
`April''s restrictions on assignment - structures and lists in `April'
may not be side-effected as result of assignment. This permits
efficient implementation at the same time as protection from unintended
side-effects between processes and programs.

   _Note:_

     There is a subtle difference between a statement such as:

          R.p(A)

     and the statement:
          (R.p)(A)

     They both apply the procedure `p' found in `R' to argument `A'.
     However, the former may `find' `A' in `R' whereas the latter will
     not look in `R' for any definition of `A'.

     This can lead to mysterious problems where both `R' and the current
     scope has a definition for `A'.


File: april.info,  Node: onerror statement,  Next: exception statement,  Prev: dot statement,  Up: Compound statements

7.2.7 `onerror' statement
-------------------------

Errors in a program generally come from three distinct sources -
machine resource restrictions (such as not enough space or non-existent
file), run-time type errors (such as invalid type conversion implied by
a typecast expression, or invalid string in some file operations) and
explicitly generated exceptions raised by the programmer using
`exception' statements (*note exception statement::).

   The first two are called _automatic_ run-time exceptions and the
latter is a programmer raised exception.  

   The `onerror' statement is used to allow programmers to control the
handling and recovery from most types of run-time exceptions.(1) The
format of the `onerror' statement is:

     try
       S1
     onerror
       PROC

where S1 can be any statement and PROC is a unary procedure (*note
Procedure::), commonly an explicit one given directly in terms of
clauses similar to those in the body of a `case' statement.

   If S1 executes without causing any run-time exceptions, then the
`onerror' statement completes also. However, if a run-time exception is
caused during the execution of S1 then S1 is terminated and PROC is
executed instead.

   Note that there is no `undo' implied by this - any actions taken by
S1 immediately prior to the run-time exception are _not_ undone.

   The argument to `Proc' is the error value associated with the
run-time error that caused the exception.  This error value encodes the
cause of the exception; and - for automatically raised errors - is of
the `error' type (*note error type::).  For example, the following
program reads a file one line at a time and `protects' itself against a
run-time error caused by reading past the end of file:

     read_file(fin) => collect{
       loop::
        {
          while not eof(fin) do {
            elemis inline(fin)
          onerror{
            error(_,'eof) -> leave loop
          };
        }
     };

`onerror' statements may be nested, in which case the inner `onerror'
statement takes precedence.

   If a program has no `onerror' clause in effect, then the process
itself will be terminated, and the exception message will be sent to a
process'es parent process instead.

   ---------- Footnotes ----------

   (1) Some run-time exceptions cannot be recovered from and will cause
the entire `April' machine to terminate. However, this situation is not
very helpful in situations requiring reliable service; the
non-recoverable errors are either due to an internal problem (a.k.a.
bug) or because some vital system resource (such as memory) has been
exhausted.


File: april.info,  Node: exception statement,  Next: Labelled statement,  Prev: onerror statement,  Up: Compound statements

7.2.8 `exception' statement
---------------------------

The `exception' statement is used to generate a run-time exception.
The form of an `exception' statement is:

     exception ERROR

which will have the same effect as an automatically induced run-time
exception. This statement has the effect of terminating the current
execution and switching to the error handling clause of the inner-most
enclosing `onerror' statement. The value of ERROR is passed to the
error handling procedure.

   Normally, the `exception' ERROR will be an expression such as:

     error("SOME STRING",ERROR CODE)

in order to maximize the chance that a programmer-raised exception will
be handled with the same error handling mechanism that automatic
run-time errors are handled.


File: april.info,  Node: Labelled statement,  Next: leave statement,  Prev: exception statement,  Up: Compound statements

7.2.9 Labelled statement
------------------------

A labelled statement is a statement which has a label associated with
it.  The form of a labelled statement is:

     LABEL::STATEMENT

where LABEL is a symbolic label and STATEMENT is any statement.

   Labels in `April' have a somewhat different interpretation compared
to other procedural languages - the scope of a label extends only to the
labelled statement itself. The only statement that can effectively use a
label is the `leave' statement.  


File: april.info,  Node: leave statement,  Prev: Labelled statement,  Up: Compound statements

7.2.10 `leave' statement
------------------------

The `leave' statement is used to force the early termination of a group
of statements. The form of the `leave' statement is:

     leave LABEL

where LABEL is the label of a labelled statement that this `leave'
statement occurs in.

   The effect of the `leave' statement is to force early termination of
the labelled statement whose label is LABEL. For example, in the
example:

     foo::{
       while TEST do {
         if OTHER-TEST then
           leave foo
         ...
       }
     }

if OTHER-TEST succeeds then the whole `while' loop is terminated. The
effect is similar to a break statement in C - except that the
interpretation of `leave' is clearer than break.

   `leave' is a little analogous to the `goto'-style statement in many
procedural languages; however, `leave' does not cause a jump _to_
another statement but instead jumps _out_ from a statement. To
appreciate the difference between `leave' and C's `goto' statement,
consider that the following - legal - C fragment is not possible using
labelled `April' statements:

     if(X < Y)
       foo: fprintf(stderr,"how did we get here\n");
     else
       goto foo

Such uses of `goto' are opaque at best, and completely incomprehensible
and error-prone at worst.

   _Hint:_

     We can use labelled statements in combination with the `leave'
     statement to implement the `break' and `continue' statements found
     in languages like C.

     A `break' statement - in the context of a loop such as a `for' or
     `while' loop - means that the loop should be terminated
     immediately. We can model this by making the entire loop statement
     a labelled statement, and replacing the `break' with a `leave'
     from the loop:

          label :: {
            while PREDICATE do {
              STATEMENT
              ...
              leave label;                -- replacing a break
            }
          }

     Similarly, a `continue' statement does not leave the whole loop,
     but only the body of the loop:

          for PTN in SET do {
            label:: {
              BODY STATEMENT
              ...
              leave label;                -- replacing a continue
            }
          }

     Of course, in some situations we may need to combine both in a
     single loop.

     `April' automatically replaces loops containing `break' and
     `continue' statements into the equivalent labelled forms.


File: april.info,  Node: Sending messages,  Next: Receiving messages,  Prev: Compound statements,  Up: Statements

7.3 Sending messages between processes
======================================

In `April', sending a message is technically a `primitive' statement,
whereas the message receive statement is a `compound' statement.  This
is because the message receive statement selects which statement to
execute based on the messages received.

* Menu:

* >>::                          Send a message
* >>>::                         Forward a message
* self post::                   Post a message on own message queue
* _front_msg::
* >>*::                         Send a message
* Message attributes::          Modifying the attributes of a message
* Remote communication::        Sending messages out of an invocation


File: april.info,  Node: >>,  Next: >>>,  Up: Sending messages

7.3.1 `MSG >> TO'
-----------------

where TO is a `handle' and MSG is any expression.  The message MSG is
sent to the TO process.

   The `April' communications system will attempt to send the message
wherever the destination is - potentially anywhere in the world that has
an active `April' site.

   If a message is sent to a process in the same `April' invocation,
then it is posted on the receiver process'es message queue.  If the
receiver is not a local process, then the message is diverted to the
process'es `mail handler'.  This is an `April' process which is in
direct communication with the `April' communications server (*note
April communications::).  The communications server is able to store
and forward the message so that the receiver process can acquire the
message.

   The sender process is not blocked by sending a message - execution
of the sender can continue even if the receiver process is not yet
ready to receive the message. This is known as _asynchronous_ message
passing.

   There is an implicit conversion of the type of the MSG to type `any'
- *note any type::. This encapsulation allows messages of any type to
be sent between processes - the `receive' statements make a similar
implicit type test to verify the type of the incoming message.

   Note that it is possible to send messages to explicitly named
agents, as in:

     hello >> hdl('tuck,'bib)
   which sends the `hello' message to the process identified by the
handle
     hdl('tuck,'bib)

* Menu:

* Modifying message attributes::


File: april.info,  Node: Modifying message attributes,  Up: >>

7.3.1.1 Modifying message attributes
....................................

At times it can be convenient to send a message to another process while
requiring that any reply to the message should go to a third process. In
`April', this can be done using the `~~' modifier:

     MSG ~~ [replyTo(FROM)] >> TO

This has the effect of modifying the `replyTo' attribute of the MSG so
that replies will go to FROM. Other attributes of the message can also
be specified; *note Message attributes::.

   Note, however, that this _does not_ affect the `sender' attribute.
This cannot be modified and is always a reliable guide to the true
sender of a given message.


File: april.info,  Node: >>>,  Next: self post,  Prev: >>,  Up: Sending messages

7.3.2 `MSG >>> TO'
------------------

This statement is only permitted on the right hand side of a message
receive - `->>' - operator.  The message MSG is forwarded to the new
receiver. Any reply which the new recipient sends to this message will
go directly to the process which sent the message in the first place.

   Technically, the value of the `replyTo' attribute will be the same
for the new recipient of MSG as it is for the message that was received
by this process - i.e., the message described on the left hand side of
the `->' operator. It is, of course, possible that the forwarded
message is not identical to the original message.

   However the `sender' field of the new message will still be this
process, so the new recipient can - if necessary - verify that the
originator of the message is a trusted process.


File: april.info,  Node: self post,  Next: _front_msg,  Prev: >>>,  Up: Sending messages

7.3.3 Post a message on own message queue
-----------------------------------------

A message may be placed by a process in its own message queue simply by
sending a message to iteself:

     hello >> self()

However, as with other message sending, this will place the message
`hello' at the end of the process'es message queue. There are occasions
where it is necessary to place a message at the front of the process'es
own message queue. This can be done using the `!>>' statement:

     MSG !>>;

The effect of this is that the new message will be processed before any
other messages are received.

   _Hint:_

     Self posting can be used to implement _atomic transactions_. An
     atomic transaction can be implemented by sending a block of
     messages in a list:
          atomic([MSG1,...,MSGN])
     and the receiving process handles this block by posting the
     messages to the front of its own queue in reverse order:

          atomic(msgs) ->> {
            for m in reverse(msgs) do
              m !>>
          }

     It must be done in reverse order because each `self-posting' of a
     message puts the message on the front of the queue; and we wish to
     ensure that the first message in the list is also the first
     message to be processed after the sequence of self posts.


File: april.info,  Node: _front_msg,  Next: >>*,  Prev: self post,  Up: Sending messages

7.3.4 `_front_msg(MSG,REPLY,SENDER)'
------------------------------------

The `self post' message send statement is short hand for the built-in
procedure `_front_msg'. This built-in procedure allows the programmer
to post a message on the front of the message queue; and it also allows
the apparent SENDER of that message to be set explicitly - unlike the
normal message send where the SENDER cannot be set by the programmer.

   It is safe for `_front_msg' to be able to set the SENDER field since
the message is going to the same process that generated the message -
there is no possibility of a `name spoof' attempt.


File: april.info,  Node: >>*,  Next: Message attributes,  Prev: _front_msg,  Up: Sending messages

7.3.5 `MSG >>* RECIP-LIST'
--------------------------

The `>>*' statement sends a message to a list of processes. It is a
form of multi-cast - although no efficiency gain is implied by the use
of this operator.


File: april.info,  Node: Message attributes,  Next: Remote communication,  Prev: >>*,  Up: Sending messages

7.3.6 Message attributes
------------------------

When a message is sent between processes, a number of attributes may be
associated with the message. These attributes allow the sending process
to control some _policy_ aspects of the message delivery. Message
attributes are expressed as a list of attribute records, the standard
type of which is listed in *Note Message attribute type::.

* Menu:

* Message attribute type::
* replyTo message attribute::
* leaseTime message attribute::
* receiptRequest message attribute::
* auditTrail message attribute::


File: april.info,  Node: Message attribute type,  Next: replyTo message attribute,  Up: Message attributes

7.3.6.1 Message attribute type
..............................

The message attribute type is defined as:

     msgAttr ::= replyTo(handle)
       | leaseTime(number)
       | receiptRequest(any)
       | auditTrail(handle[]);

When a message is sent - for example using the message send statement
(*note >>::) - then a default value is associated with each of these
message attributes.


File: april.info,  Node: replyTo message attribute,  Next: leaseTime message attribute,  Prev: Message attribute type,  Up: Message attributes

7.3.6.2 `replyTo' message attribute
...................................

The `replyTo' message attribute is used in sitatuations where the
sender of the message would prefer that any replies be sent to another
process.

   The form of the `replyTo' message attribute is:

     replyTo(handle)

By default, the value of the `replyTo' is `self()'; i.e., if there is
no `replyTo' attribute then it is as though the message attribute were:

     replyTo(self())


File: april.info,  Node: leaseTime message attribute,  Next: receiptRequest message attribute,  Prev: replyTo message attribute,  Up: Message attributes

7.3.6.3 `leaseTime' message attribute
.....................................

The `leaseTime' message attribute is used to indicate a valid life-time
of the message. The form of the `leaseTime' attribute is:

     leaseTime(number)

The value of the `number' field is an `April' EPOCH time value - i.e.,
the number of seconds since Jan 1st 1970.

   If a message is sent with a `leaseTime' of 0, or if there is no
`leaseTime' message attribute, then it is assumed to be infinite -
i.e., the sender requests that the message is delivered no matter how
long it takes.

   If a message is sent with a non-zero `leaseTime', then the message
_may_ be discarded before it reaches the destination process. The
programmer should note however, that the receiving process may still
receive messages that are out of date in which case the `receive'
statement should check that the message is still valid:

     receive{
       ...
     | PTN :: (leaseTime(w)::w>=now()) in options ->> ...
     } ...


File: april.info,  Node: receiptRequest message attribute,  Next: auditTrail message attribute,  Prev: leaseTime message attribute,  Up: Message attributes

7.3.6.4 `receiptRequest' message attribute
..........................................

The `receiptRequest' message attribute is used to request that the
receiving process has received the message.  The form of the
`receiptRequest' attribute is:

     receiptRequest(CODE)

When the message is received, a reply message of the form:

     receiptRequest(CODE)

is sent to the sending process.(1)

   Alternatively, if a message `leaseTime' has been associated with the
message, and the message sending infrastructure determines that the
message may be discarded, then the sending process will receive a
message of the form:

     timedOut(CODE)

instead of the normal `receiptRequest' message.

   ---------- Footnotes ----------

   (1) Not currently implemented due to a serious problem with
determining when a process has received a message.


File: april.info,  Node: auditTrail message attribute,  Prev: receiptRequest message attribute,  Up: Message attributes

7.3.6.5 `auditTrail' message attribute
......................................

The `auditTrail' message attribute is used to request an audit trail
indicating the route that a message goes through from the sending
process to the process that receives the message.  The form of the
`auditTrail' attribute is:

     auditTrail(handle[]);

When a message is received, the `auditTrail' will have in its argument
a list of the `handle's of the intermediate communications servers that
were involved in delivering the message.

   The initial value of the `auditTrail' message attribute - when it is
initially sent by an `April' process - should be the empty list:

     auditTrail([])

Normally it is the message handling system that modifies this attribute
to indicate the path that the message has taken.


File: april.info,  Node: Remote communication,  Prev: Message attributes,  Up: Sending messages

7.3.7 Sending messages between `April' systems
----------------------------------------------

By default the `April' system does not permit processes to communicate
across different invocations of the system.(1)

   ---------- Footnotes ----------

   (1) This is new in version~5.0.


File: april.info,  Node: Receiving messages,  Prev: Sending messages,  Up: Statements

7.4 Receiving messages
======================

All messages are received by means of special _message receive_
statements. This can be one message at a time, however, normally
messages are not consumed one at a time, but rather are consumed as a
_stream_ of messages. In `April', we can consume a stream of messages
using the `repeat' statements. These statements are not `primitive' in
`April', but are in fact processed into simpler statements.  

* Menu:

* receive::                     Message receive statement
* timeout::                     Handling timeouts in message receive
* repeat until::                Message terminated message stream
* repeat alarm::                Timed message stream


File: april.info,  Node: receive,  Next: timeout,  Up: Receiving messages

7.4.1 The message receive statement
-----------------------------------

A process receives a message by executing a `receive' statement. A basic
message receive statement takes the form:

     receive PROCEDURE

where PROCEDURE is a message handling procedure. The standard way of
writing a message handling procedure is as a sequence of message
handling clauses:

     receive {
       PTN1 ->> S1
     | PTN2 ->> S2
     | ...
     | PTNK ->> SK
     }

This statement will filter incoming messages until one that matches one
of the patterns PTNI. If there are no matching messages then the
process will suspend and wait for more messages to arrive.

   More accurately, the `April' engine will examine each message in the
process'es message queue in turn - in the order that they were
received. For each message, each of the patterns PI are tried, in turn
from first to last, to see if it matches.  If it does then the
corresponding statement SI is executed.

   Messages which do not match any of the PTNI patterns are not lost -
they are simply kept in an internal process message queue until the
process executes another message receive statement which can accept
them.

   As soon as a matching message is found, then the SI on the right
hand side of the `->>' operator is executed. Note that the PTNI may
declare additional local variables - the scope of these local variables
extends to the SI; but not outside the message receive statement itself.  

   Each message receive clause has additional `components' which are
automatically attached to the message:

   * the `handle' of the `sender' of the message. This is made
     available as the value of the `sender' variable whose scope extends
     to the action part of the message receive clause.

   * the `replyto' `handle' of the process that any replies should go
     to. This is made available as the value of the `replyto' variable
     whose scope extends to the action part of the message receive
     clause.

   * the list of message attributes associated with the message; as
     requested by the sender of the message. This is made available as
     the value of the `options' variable whose scope extends to the
     action part of the message receive clause. The type of `options'
     is `msgAttr[]' - which is described in *Note Message attributes::.

   For example, to verify that the `sender' and `replyto' handle of a
message matches some pattern, we can use a receive clause like:

     PTN :: SNDR .= sender && REPLY .= replyto ->> S

where SNDR is a pattern that is applied to the message's sender process
and REPLY is a pattern that is applied to the intended recipient of any
replies to the message.(1)

   The `sender' and `replyto' variables offer a convenient means for
verifying that a particular message is from an expected party:

       hello >> h
       receive {
         hi_there :: sender == h ->> "We got a reply\n" >> stdout
       }

_Hint:_

     There are occasions when it is important for a process to handle
     _all_ the messages that arrive, even if they are the `wrong' kind
     of message; this is particularly true when building robust
     applications.

     A method for achieving this is to use a `catchall' pattern.  This
     pattern should be the last pattern in the message choice:
          receive{
            P1 ->> S1
          | ...
          | PN ->> SN
          | M ->> "Funny message " ++ M^0 ++ "\n" >> stdout
          }

* Menu:

* Underlying semantics of message receive::

   ---------- Footnotes ----------

   (1) Normally the REPLY process is identical to the SNDR process;
however, it can be convenient to route replies to messages to different
processes.


File: april.info,  Node: Underlying semantics of message receive,  Up: receive

7.4.1.1 Underlying semantics of message receive
...............................................

Although we have given a special syntax for the message receive clause,
in fact the message receive clause is syntactic sugar for a simpler
underlying structure. The `normal form' of a message receive clause:

       PTN ->> S

is syntactic sugar for the regular procedure clause:

     (handle?sender,handle?replyto,msgAttr[]?options,any(PTN))->S

Earlier we stated that the syntax of a message receive statement is:

     receive PROC

The type of PROC required for a message receive is

     (handle,handle,msgAttr[],any){}

I.e., the message handling procedure has four arguments: the message
itself, the identity of the sender of the message, the identity of the
reply-to process and the list of message attributes.

   This is important because it allows us to _extend_ a message
`receive' statement dynamically. If we assume that `dynamic' is a
procedure variable of the correct type, then we can construct a message
`receive' statement that will handle a dynamic range of messages:

     receive{
       PTN ->> ACTION
     | ...
     | dynamic
     }

   We can even handle messages that allow DYNAMIC to be extended
dynamically:

     augment ::= augment((handle,handle,msgAttr[],any){}?aug);

     ...

     receive{
       PTN ->> ACTION
     | augment(P) -> dynamic := {P|dynamic}
     | ...
     | dynamic
     }

   The type of any such `message handling procedure' should match the
expected type of the PROC; i.e., it should also be of type:

     (handle,handle,msgAttr[],any){}

More precisely, it is possible to show the `true' colours of a message
`receive' statement, expressed in terms of simpler primitives -
including the `case' statement. The `April' compiler transforms message
`receive' into this simpler (although much longer) statement:

     M : -10000;		/* Message number */
     outer::{
       while (Msg,Sender,ReplyTo,Opts,NM) .= __nextmsg(M) do {
         M := NM;
         inner :: {
           {
             (sender,replyto,options,PTN1)->{A1}
           | (sender,replyto,options,PTN2)->{A2}
           | ...
           | (_,_,_,_){
               __replacemsg(Msg,Sender,Opts,M);
               leave inner;
             }
           }(Sender,ReplyTo,Opts,Msg);  -- Procedure with an explicit body
           leave outer;
         };
       }
     }

Note that the actual cases of the message receive are transformed into a
procedure call where the procedure is an explicit set of procedure
clauses.

   Briefly, a message `receive' statement is transformed into a loop
which removes a message from the process's message queue (using
`__nextmsg'); attempts to match it with one of the message clauses, and
if none matches the message is replaced in the message queue and the
next message is tried. `__nextmsg' finds the first message whose
sequence number is greater than the sequence number supplied to it.


File: april.info,  Node: timeout,  Next: repeat until,  Prev: receive,  Up: Receiving messages

7.4.2 The `timeout' message receive clause
------------------------------------------

If one of the message clauses in a message receive has the form:

     timeout EXP ->> ACTION

where EXP is a relative time expression - i.e., a numeric value
indicating a `number' of seconds, then the process will only wait an
EXP amount time for a matching message to arrive.

   If no matching message arrives at the process (or is already there)
before the timeout interval expires, then the statement associated with
this message receive statement is executed.

   For example, if a process only wishes to wait for an `accept'
message for 3 seconds then we could use:

     receive{
       'accept ->> ACCEPT STATEMENT
     | timeout 3 secs ->> TIMEOUT STATEMENT
     }

   The timeout interval starts at the initial entry point to the message
`receive' choice statement.

   Message `receive' statements with `timeout' clauses are transformed
in a similar way to regular message `receive' statements. However,
their translation is more complex since the timeout must be managed:

     M : -10000;		/* Message number */
     outer::{
       try {
         End : now()+E;

         while (Msg,Sender,ReplyTo,Opts,NM) .= __waitmsg(M,End) do {
           M := NM;
           inner :: {
             {
               (sender,replyto,options,PTN1)->{A1}
             | ...
             | (_,_,_,_)->{
                 __replacemsg(Msg,Sender,Opts,M);
                 leave inner;
               }
             }(Sender,ReplyTo,Opts,Msg);  -- Procedure with an explicit body
             leave outer;
           };
         }
       }
       onerror{
         'timedout -> TIME OUT ACTION
       | EE -> exception EE
       }
     }

The `__waitmsg' primitive is similar to the `__nextmsg' primitive used
for normal message recveive statements except that it includes a
timeout END. If no message is received before END then `__waitmsg'
generates a run-time exception - `timedout' - which is caught by a
handler built from the `timeout' clause in the message `receive'.


File: april.info,  Node: repeat until,  Next: repeat alarm,  Prev: timeout,  Up: Receiving messages

7.4.3 `repeat'...`until'
------------------------

The `repeat...until' statement is a _message terminated_ message stream
statement. It consumes a stream of messages until a terminating message
is received.

   The form of the `repeat...until' statement is:

     repeat {
       PTN1 ->> S1
     | PTN2 ->> S2
     ...
     | PTNK ->> SK
     } until PTNQ

where PTNI are message receive patterns as in the normal message
receive statement (*note receive::), and PTNQ is also pattern.

   This statement continues to consume any messages of the form PTNI
(and executing the corresponding statements SI) until a message that
matches PTNQ is received.

   Note that the messages received by a process are handled in order of
arrival, thus any termination message is handled _after_ other messages
which arrived earlier at the process.

   Note also that any messages which arrive at the process which match
none of PTNI or PTNQ are `held' in the process'es message buffer
without otherwise affecting the execution of this statement.

   The `repeat BODY until QUITPTN' statement is equivalent to a `while'
iteration of the form:

     exit::{
       while true do
         receive{
           QUITPTN ->> leave exit
         | BODY
         }
     }


File: april.info,  Node: repeat alarm,  Prev: repeat until,  Up: Receiving messages

7.4.4 `repeat'...`until alarm'
------------------------------

The `repeat...until alarm' statement is a _timed_ message stream
statement. It consumes a stream of messages for a period of real-time.

   The form of the `repeat...until alarm' statement is:

     repeat {
       PTN1 ->> S1
     | PTN2 ->> S2
     ...
     | PTNK ->> SK
     } until alarm PERIOD

where PTNI are message receive patterns as in the normal message
receive statement (*note receive::), and PERIOD is an expression
representing a period of time.

   This statement continues to consume any messages of the form PTNI
(and executing the corresponding statements SI) for PERIOD seconds. For
example, to consume a series of `tick' messages for 10 seconds, use:

     repeat {
       'tick ->> "tick\n" >> stdout
     } until alarm 10 secs

   As with the `repeat...until' statement, See *Note repeat until::.
messages which are not matched by PTNI patterns are not consumed by the
statement but otherwise do not affect the execution of the statement.

   The `repeat BODY until alarm' statement is equivalent to the
statement:

     {
       A = spawn {
         delay(P); 'wakeup >> creator()
       };

       exit:: {
         while true do {
           'wakeup :: A==sender ->> leave exit
         | BODY
         }
       }
     }


File: april.info,  Node: Tests and conditions,  Next: Arithmetic functions,  Prev: Functions and procedures,  Up: Top

8 Tests and Conditions
**********************

These functions return values of type `logical' (i.e., values are
either `true' or `false') and are typically used in the condition for
loops or `if...then' statements.

   Note that certain of these predicates may have a `side-effect' of
declaring a variable - for example the `.=' match predicate may declare
variables in the pattern on the left hand side. Variables that are
declared in a predicate may extend their scope outside the predicate -
in particular `conjunctive' predicates allow this but disjunctive or
negative predicates do not: for example, `.=' allows it but `not ... ='
does not.

* Menu:

* Term matching::               Matching data against a pattern
* Comparisons::                 Comparing data values
* Logical connectives::         Boolean combinations


File: april.info,  Node: Term matching,  Next: Comparisons,  Up: Tests and conditions

8.1 Term Matching
=================

These predicates apply a pattern to a value - for a description of the
possible kinds of pattern, *note Patterns::.

* Menu:

* .=::                          Term match
* in::                          List membership


File: april.info,  Node: .=,  Next: in,  Up: Term matching

8.1.1 Match condition
---------------------

Template:
     PATTERN .= TERM => logical

Term matching is a test for the _compatibility_ of a data value with a
_structure prototype_.  This is more powerful and general than equality
tests as it permits simple type checking and implicit iteration as well
as comparison. In addition, it is possible to assign variables as a
result of a successful match.


File: april.info,  Node: in,  Prev: .=,  Up: Term matching

8.1.2 List membership condition
-------------------------------

Template:
     %A?E in %A[]?T => logical

This predicate is `true' if there is an element described by the
pattern E in the list T, and `false' otherwise.

   Note that in some circumstances, the `in' operator can also
introduce variable declarations - via the pattern E. If the `in'
expression occurs as the top-level expression in a `for' statement,
such as in:

     for X in S do
       elemis X

then the variables introduced in the pattern have as their scope the
dependent statement(s) of the `for' statement. I.e., the variables's
scope includes the body of the `for' statement.


File: april.info,  Node: Comparisons,  Next: Logical connectives,  Prev: Term matching,  Up: Tests and conditions

8.2 Comparisons
===============

Not all values in `April' are strictly comparable - for example
procedures and functions are not comparable. In addition, elements of a
user-defined type are not comparable. However, `ordinary' values such
as strings, numbers and even lists of these are comparable.

   The type-checker will insist that when comparing two elements, they
have the same type.

   If two values are of the same type, then the relative ordering is as
follows:

   * One number is less than another if it is numerically less.  Note
     that we can transparently compare integer values and floating
     point numbers; e.g.
          1 < 1.5 < 2

   * Symbols and strings can be ordered by comparing the characters in
     their name using the underlying character encoding scheme(1).  One
     symbol or string is less than another if:
        - its first character is less than the first character of the
          second symbol using the underlying character ordering - or,

        - if the first characters are the same then the next character
          in each symbol is compared in the same way.  This is repeated
          until two different characters are found and a result is
          decided - or,

        - if one symbol runs out of characters before a result is
          decided, the shorter symbol is deemed to be smaller.

   * One tuple is less than another if either:
        - its arity is smaller (i.e. there are fewer elements in the
          smaller tuple) - or,

        - if the arities are the same, the element in one tuple (in a
          left-to-right sequence) is less than the corresponding element
          in the other tuple.

   * One record is less than another if either:
        - its arity is smaller (i.e. there are fewer elements in the
          smaller record) - or,

        - its label is smaller - in the symbol encoding described above
          - or,

        - if the arities are the same, an element in one record (in a
          left-to-right sequence) is less than the corresponding element
          in the other record.

   Using this ordering, we can define the following comparison
functions:

* Menu:

* ==::                          Equality test
* !=::                          Inequality test
* <::                           Less than test
* >::                           Greater than test
* <=::
* >=::                          Greater than or equal test

   ---------- Footnotes ----------

   (1) Usually based on ASCII


File: april.info,  Node: ==,  Next: !=,  Up: Comparisons

8.2.1 Term equality
-------------------

Condition template:
     %A?A == %A?B => logical

This predicate is `true' if A is equal to B. Note that A and B should
have the same type; if this is type `any' then the universal ordering
on terms will be used.


File: april.info,  Node: !=,  Next: <,  Prev: ==,  Up: Comparisons

8.2.2 Term inequality
---------------------

Condition template:
     %A?A != %A?B => logical

This predicate is `true' if A is not equal to B. Note that A and B
should have the same type; if this is type `any' then the universal
ordering on terms will be used.


File: april.info,  Node: <,  Next: >,  Prev: !=,  Up: Comparisons

8.2.3 Less than condition
-------------------------

Condition template:
     %A?A < %A?B => logical

This predicate is `true' if A is less than B. Note that A and B should
have the same type; if this is type `any' then the universal ordering
on terms will be used.


File: april.info,  Node: >,  Next: <=,  Prev: <,  Up: Comparisons

8.2.4 Greater than test
-----------------------

Condition template:
     %A?A > %A?B => logical

This predicate is `true' if A is greater than B. Note that A and B
should have the same type; if this is type `any' then the universal
ordering on terms will be used.


File: april.info,  Node: <=,  Next: >=,  Prev: >,  Up: Comparisons

8.2.5 Less than or equal condition
----------------------------------

Condition template:
     `%a?A <= %a?B => logical'

This predicate is `true' if A is less than or equal to B. Note that A
and B should have the same type; if this is type `any' then the
universal ordering on terms will be used.


File: april.info,  Node: >=,  Prev: <=,  Up: Comparisons

8.2.6 Greater than or equal test
--------------------------------

Condition template:
     %A?A >= %A?B => logical

This predicate is `true' if A is greater than or equal to B. Note that
A and B should have the same type; if this is type `any' then the
universal ordering on terms will be used.


File: april.info,  Node: Logical connectives,  Prev: Comparisons,  Up: Tests and conditions

8.3 Logical Connectives
=======================

The logical connectives allow boolean combinations to be formed. Note
that `&&' and `||'  are _conditional_ combinations: if the first
element evaluates to `false' or `true' respectively then the second
argument is not evaluated. While this is not strict in the mathematical
sense, it makes perfect sense for a programming language, since it
allows optimizations to be made by the compiler.

* Menu:

* &&::                          Conjunction
* ||::                          Disjunction
* !::                           Logical negation


File: april.info,  Node: &&,  Next: ||,  Up: Logical connectives

8.3.1 Logical conjunction
-------------------------

Condition template:
     logical?A && logical?B => logical

This predicate is `true' if A and B both evaluate to `true'.
Otherwise, this returns `false'. More accurately, if A evaluates to
`true' then the value is the value of B. I.e., B is only evaluated if A
is `true', otherwise it is skipped.

   Variables which are declared within A or B may extend their scope
outside the conjuction.


File: april.info,  Node: ||,  Next: !,  Prev: &&,  Up: Logical connectives

8.3.2 Logical disjunction
-------------------------

Condition template:
     logical?A || logical?B => logical

This predicate is `true' if either A or B evaluate to `true'.
Otherwise, this predicate is `false'. More accurately, if A evaluates
to `false' then the value is the value of B. I.e., B is only evaluated
if A is `false', otherwise it is skipped.

   Note that any variables declared within A or B do _not_ extend their
scope outside the disjunction.


File: april.info,  Node: !,  Prev: ||,  Up: Logical connectives

8.3.3 Logical negation
----------------------

Condition template:
     ! logical?A => logical

This predicate is `true' if A evaluates to `false'.  Otherwise, This
predicate is `false'.

   Note that any variables declared within A do _not_ extend their
scope outside the negation.


File: april.info,  Node: Functions and procedures,  Next: Tests and conditions,  Prev: Statements,  Up: Top

9 Functions and procedures
**************************

In `April', functions and procedures are `first class values'. That
means that a function or procedure can not only be used - as in applied
to arguments - but it can also be stored as the value of the variable
or even sent in a message to another process. This last capability gives
rise to many powerful applications - including mobile agents, automatic
configuration over a network and so on.

   Functions and procedures can be defined in one of two fundamental
contexts: within a theta expression and as a normal value-related
expression. Functions and procedures defined as fields in a theta
expression may be mutually recursive, whereas other functions or
procedures are not.

* Menu:

* Function::                    The form and semantics of functions
* Procedure::                   The form and semantics of procedures
* programs and theta expressions::


File: april.info,  Node: Function,  Next: Procedure,  Up: Functions and procedures

9.1 Functions
=============

`April' uses equations to define functions, where equations are
expressed as a pattern/expression pair. Unlike most programming
languages, functions in `April' are properly considered to be _partial_
functions rather than _total_: that is, it is possible for a function
not to apply to a given set of arguments.(1)  This property of
functions is important because it allows us to _combine_ them using a
function union operator.

   In general, a function is either an equation or a union of functions.

* Menu:

* Equations::
* Function union::
* Function application::        How functions are applied to arguments
* Case expression as a function call::
* Function expressions::        Functions as values
* The voidfun function::        The do-nothing function

   ---------- Footnotes ----------

   (1) Technically all `April' functions and procedures have one
argument - which is normally a tuple of values. However, the `April'
compiler places an additional restriction on functions and procedures:
that their single argument is always a tuple.


File: april.info,  Node: Equations,  Next: Function union,  Up: Function

9.1.1 Function equations
------------------------

An equation is a rewrite rule for reducing function application
expressions to simpler expressions:

     PTN => EXP

   where PTN is a pattern (*note Patterns::) and EXP is an expression
(*note Expressions::).

   When a function is applied, the PTN is matched against the actual
argument of the function(1), and if the match is successful, then the
function application expression is reduced to EXP.

   Note that the PTN may have the full form of `April' patterns -
including semantic guards (*note Guarded pattern::) on the form and
values of the actual parameters. In addition, since the PTN can declare
variables - whose scope extends to EXP - the body of the function can
access the actual values as bindings of variables.

   The equation body EXP may refer to other variables than those
declared in PTN - these variables are _free_ in the function. All free
variables are ultimately bound by some outer scope that the function is
embedded within. The most common free variables in function bodies are
actually references to other functions.

   Note that although a function may contain references to free
variables, it may not modify their values.(2) The compiler detects such
violations and reports an error.

   Note also that the variables that are declared in the equation
pattern - which are effectively the formal parameters of the function -
are single assignment or read-only variables. This implies that such
variables may not be re-assigned to in the body of the equation.

   ---------- Footnotes ----------

   (1) A function that has several arguments really only has one - the
arguments are all encoded as a tuple which forms the single argument of
the function.

   (2) With the major exception of so-called `theta variables' (*note
theta variables::).


File: april.info,  Node: Function union,  Next: Function application,  Prev: Equations,  Up: Function

9.1.2 Function union
--------------------

A function union is the union of two functions, written with a `|'
operator:

     F | G

where F and G are functions - of compatible type. The meaning of such a
function is analogous to the mathematical union of the two partial
functions F and G.(1) Pragmatically, this means that when a function
union `{F|G}' is applied, if the function F fails to apply then the
function G is attempted. If G also fails to apply then the function
union fails - which may lead to the application itself failing.

   ---------- Footnotes ----------

   (1) Where the patterns for the two component functions overlap, the
first function takes precedence over the second. A mathematical
function union would require that where the patterns overlap, the
values of the component functions must be the same.


File: april.info,  Node: Function application,  Next: Case expression as a function call,  Prev: Function union,  Up: Function

9.1.3 Function application
--------------------------

A function application expression is of the form:

     FUN ARGUMENT

where FUN is a function valued expression of compatible type with
ARGUMENT. Typically the argument of a function is a tuple of the form
`(A1,...,AK)'; but where the function is single-arity then

     FUN ARG

is entirely equivalent to:

     FUN(ARG)

`April' is a strict call-by-value programming language - arguments to
functions are evaluated before entering the function body.

   All of FUN, A1,...,AK are evaluated prior to the FUN body itself.
However, the precise order of evaluation of FUN, A1,...,AK is not
defined and programmers should not rely on a particular order of
evaluation of function parameters.

   All the parameters to a function are _input_ - a function only
returns a single value.  If it is desired that a function returns more
than one value then arrange to return a tuple or record of values:

     fun = { (P1,...,PK) => (EXP1,...,EXPJ)}

`April' allows multiple variables to be assigned simultaneously as a
tuple; so the results of such a function could be `unpacked' using an
assignment of the form:

     (V1,...,VJ) := fun(E1,...,EK)

Since `April' functions are defined to be partial, there remains the
possibility that none of the equations that define a function apply to
a given set of arguments. If that happens, then the expression _fails_,
which is not permissable in `April'. If an expression fails in this
way, then an error exception is raised - the `fail' exception. Such
failures can be trapped and handled using the `onerror' statement
(*note onerror statement::):

     try{
       ... foo(A1,...,Ak) ...
     } onerror {
       failed -> ...               /* Handle failure of `foo' */
     }


File: april.info,  Node: Case expression as a function call,  Next: Function expressions,  Prev: Function application,  Up: Function

9.1.4 `case' expression as a function call
------------------------------------------

The `case' expression allows the value of an expression to be
determined by cases in the value of a governing expression.

   Although `case' expressions are normally expressed in terms of a
disjunction of alternative cases, the underlying form of the `case'
expression is better expressed in terms of functions:

     case EXP where FUNCTION

where FUNCTION is a function whose argument type is compatible with
EXP. The conventional `case' expression amounts to the FUNCTION being
given explicitly as a series of equations:

     case (A,B) where {
       ([],?X) => X
     | ([?E,..?R],?X) => [E,..append(R,X)]
     }

The `case' expression can really be understood as a form of syntactic
sugar for function application. The form:

     case (A1,...,AK) where FUN

is equivalent to:

     FUN(A1,...,AK)

This implies, that instead of the `case' expression above, we could
have written:

     {
       ([],?X) => X
     | ([?E,..?R],?X) => [E,..append(R,X)]
     }(A,B)

This conversion is performed automatically by the `April' compiler.
However, given the probable intention of the `case' expression compared
to a function application expression, this way of writing a `case'
expression would be obscure in practice.


File: april.info,  Node: Function expressions,  Next: The voidfun function,  Prev: Case expression as a function call,  Up: Function

9.1.5 Function expressions
--------------------------

As noted above, a function is a first class value in `April'. This
implies that a function - defined using a combination of equations and
function union operators - can used as a value in an expression.

   The compiler determines by context the situation where a function is
being used as a value - for example, in the expression:

     X : 1..N // {I=>I*I}

the sub-expression `{I=>I*I}' is a function value.(1)

   The type of a function:

     PTN => EXP

is an expression of the form:

     TP => TE

where TP is the type of PTN and TE is the type of EXP. Where a function
is defined using the union operator, the type is found by unifying the
types associated with the two arms of the function union.

   It is worth noting again that functions and procedures may be sent in
messages to other processes, including to processes on different
computers. In this case, the `April' message system will ensure that
both the function itself _and_ the values of any free variables
referred to in the function will also be sent.

   ---------- Footnotes ----------

   (1) The variable `X' here is bound to a list of numbers of the form
`[1,2,...]'.


File: april.info,  Node: The voidfun function,  Prev: Function expressions,  Up: Function

9.1.6 The `voidfun' function
----------------------------

The `voidfun' function is a special built-in function that is defined
not to have any applying clauses. The type of `voidfun' is:

     %A => %B

i.e., it makes no assumptions about its arguments; which means that it
can be used as the `fail' case of a function value. If `void' is ever
evaluated, it will cause the `failed' exception to be raised.


File: april.info,  Node: Procedure,  Next: programs and theta expressions,  Prev: Function,  Up: Functions and procedures

9.2 Procedure
=============

`April' uses _clauses_ to define procedures, where a clause is a
pattern/action pair - analogous to the pattern/expression pair for
equations. Like functions, `April' procedures have a semantics based on
the success or failure of the application of a pattern to a set of
arguments: this means that `April' procedures also have a form of
partial semantics.

   In general, a procedure is either a clause or a union of procedures.

* Menu:

* Procedure clause::
* Procedure union::
* Procedure application::       How procedures are applied to arguments
* Case statement as a procedure call::
* Procedure expressions::       Procedures as values
* Procedures and free variables::
* The fail procedure::          The always failing procedure


File: april.info,  Node: Procedure clause,  Next: Procedure union,  Up: Procedure

9.2.1 Procedure clause
----------------------

A clause is a rewrite rule for reducing procedure application
statements to simpler statements:

     PTN-> STMT

where PTN is a pattern (*note Patterns::) and STMT is a statement
(*note Statements::).

   When a procedure is applied, the PTN is matched against the actual
arguments of the procedure, and if the match is successful, then the
procedure application statement is reduced to STMT.

   Note that the PTN may have the full form of `April' patterns -
including semantic guards (*note Guarded pattern::) on the form and
values of the actual parameters. In addition, since the PTN can declare
variables - whose scope extend to STMT - the body of the procedure can
access the actual values as bindings of variables.

   The procedure body STMT may refer to other variables than those
declared in PTN - these variables are _free_ in the procedure. All free
variables are ultimately bound by some outer scope that the procedure
is embedded within.

   Although a procedure may contain references to free variables, it
may not modify their values - apart from so-called theta-variables that
are in the same scope. This has the effect of preventing procedures
from side-effecting their environment in other than strictly controlled
ways - one common way is by sending messages between processes.

   The variables that are declared in the equation pattern - which are
effectively the formal parameters of the procedure - are single
assignment or read-only variables. This implies that such variables may
not be re-assigned to in the body of the procedure clause.


File: april.info,  Node: Procedure union,  Next: Procedure application,  Prev: Procedure clause,  Up: Procedure

9.2.2 Procedure union
---------------------

A procedure union is the union of two procedures, written with a `|'
operator:

     P | Q

where P and Q are procedures - of compatible type.  The union of two
procedures is defined in terms of the success or failure of the
procedures to apply. Pragmatically, this means that when this procedure
is applied, if the procedure P fails to apply then the procedure Q is
attempted. If Q also fails to apply then the procedure union fails,
which may cause the procedure call statement itself to fail.

   Note that the component procedures P and Q need not be explicitly
written as clauses. We can use the `|' operator to compose existing
procedures together, and we can use procedure values directly in the
definition of a procedure.

   One example of the latter may be within a message `receive'
statement, where a default case is to be handled by a procedure:

     receive {
       PTN1 ->> A1
     | PTN2 ->> A2
     | ...
     | defaultProc
     }

where `defaultProc' is a procedure - of type
     `(handle,handle,msgAttr[],any){}'
   that will be applied to the message if all of PTNI fail to apply.


File: april.info,  Node: Procedure application,  Next: Case statement as a procedure call,  Prev: Procedure union,  Up: Procedure

9.2.3 Procedure application
---------------------------

A procedure application statement is of the form:

     PROC ARGUMENT

where PROC is a procedure valued expression of compatible type to the
type of ARGUMENT. Of course, the procedure will typically have several
arguments, in which case these are encoded in a tuple as `(A1,...,AK)'.

   As with function applications, arguments to procedures are evaluated
before entering the procedure body.  All of PROC, A1,...,AK are
evaluated prior to the PROC body itself. However, the precise order of
evaluation of PROC, A1,...,AK is not defined and programmers should not
rely on a particular order of evaluation of procedure parameters.

   All the parameters to a procedure are _input_ - procedures do not
return any values.  If it is desired that a procedure return a value
then use a function.  On the other hand, procedures can and often do
send messages to other processes.

   As with functions, `April' procedures are partial; in which case
there is the possibility that none of the clauses that define a
procedure apply to a given set of arguments. If a call fails in this
way, then an error exception is raised - the `fail' exception. Such
failures can be trapped and handled using the `onerror' statement
(*note onerror statement::):

     try{
       ... bar(A1,...,Ak); ...
     } onerror {
       failed -> ...               /* Handle failure of `bar' */
     }


File: april.info,  Node: Case statement as a procedure call,  Next: Procedure expressions,  Prev: Procedure application,  Up: Procedure

9.2.4 `case' statement as a procedure call
------------------------------------------

The `case' statement allows the choice of which statement to execute to
be determined by cases in the value of a governing expression.

   Although `case' statements are normally expressed in terms of a
disjunction of alternative cases, the underlying form of the `case'
statement is better expressed as:

     case EXP where PROCEDURE

where PROCEDURE is a procedure whose argument type is compatible with
EXP. In most cases, the PROCEDURE is given explicitly as a series of
clauses:

     case (A,B) where {
       ([],?X) -> valis X
     | ([?E,..?R],?X) -> valis [E,..append(R,X)]
     }

   Note that a `case' statement is a form of syntactic sugar for
procedure application. The form:

     case (EXP) where PROC

is equivalent to:

     PROC(EXP)

This implies, that instead of the `case' statement above, we could have
written:

     {
       ([],?X)-> valis X
     | ([?E,..?R],?X)-> valis [E,..append(R,X)]
     }(A,B)

Normally, this way of writing a `case' statement would be obscure in
practice; however it is regularly used by the `April' compiler when
translating higher-level language features such as message receive.


File: april.info,  Node: Procedure expressions,  Next: Procedures and free variables,  Prev: Case statement as a procedure call,  Up: Procedure

9.2.5 Procedure expressions
---------------------------

Like functions, a procedure is a first class value in `April'. This
implies that a procedure - defined using a combination of clauses and
procedure union operators - can used as a value in an expression.

   The compiler determines by context the situation where a procedure is
being used as a value - for example, in the statement:

     ('doMe, {()->"Hello world\n">>stdout}) >> execServer

the expression `{()->"Hello world\n">>stdout}' is a procedure value.(1)

   The type of a procedure value

     PTN -> STMT

is an expression of the form:

     TP{}

where TP is the type of PTN. Where a procedure is defined using the
union operator, the type is found by unifying the types associated with
the two arms of the procedure union.

   ---------- Footnotes ----------

   (1) If executed, the message `Hello world' should appear on the
_sender_'s console rather than the console associated with
`execServer'. This is because `stdout' is a free variable which is
bound to the sender's standard output file process.


File: april.info,  Node: Procedures and free variables,  Next: The fail procedure,  Prev: Procedure expressions,  Up: Procedure

9.2.6 Procedures and free variables
-----------------------------------

As noted above, a free variable is a variable that occurs in a procedure
or function that is not bound by that procedure or function. While
`normal' variables in `April' procedures and functions are read-write -
i.e., they can be re-assigned a different value - free variables are
read-only (except for theta variables).

   The reason for this can be seen in the following example; suppose
that we have the function `foo' which returns a procedure value:

     foo(A) => {(X) -> { A:=X }}

The `foo' function returns a unary procedure which attempts to
re-assign the variable `A' to a new value. This variable is free in the
procedure, and is bound by the `foo' function itself - its a parameter
of `foo'.

   If we allowed this re-assignment, and the value of the `foo'
function were executed, then the compiler would have the difficult task
of assigning a new value to a variable that no longer exists!  For this
reason `April' does not permit free variables to be re-assigned.
However, this restriction introduces its own complications. For example,
consider the statement:

     PROC(E1,...,EK)

where PROC is defined as:

     PROC(P1,...,PK)
     {
       S1
     }

We would like to be able to state that,  since we know the definition of
PROC, the procedure call is entirely equivalent to:

     {(P1,...,PK) -> {
       S1
     }}(E1,...,EK)

which in turn should be equivalent to:

     {
       (P1,...,PK) = (E1,...,EK);
       S1
     }

I.e., we can replace the procedure call of a known procedure by a pair
of statements - one to bind the formal parameters of the procedure to
its actual arguments and one which represents the body of the procedure.

   However, this final replacement is not quite legal since it ignores
the issue of free variables. If PROC contains free variables then, as a
result of this transformation, their status switches from being
read-only to full read-write variables.

   This is an important issue since this kind of transformation is
implied by the equivalence of a `case' statement with a procedure call
statement. They _are_ equivalent _except_ with respect to free
variables. A `case' statement of the form:

     case E where {
       P1 -> { XX:=E }
     | ...
     }

is _not_ exactly equivalent to

     {
       (P1) -> { XX:=E }
     | ...
     }(E)

precisely because in the latter the applied procedure contains a free
variable which is illegally re-assigned by the procedure, whereas
assignment of variables is an essential aspect of the power of a `case'
statement. This can be seen more clearly if we `unpack' the procedure
call using an intermediate procedure variable:

     PP : {
       (P1) -> { XX:=E }
     | ...
     };
     ...
     PP(E)

Here, `PP' is a procedure variable bound to a procedure value, which
now clearly attempts to re-assign a free variable.

   `April' `resolves' this matter by _ipso facto_ declaring that where a
procedure is explicitly given in a procedure call - whether a normal
procedure call or a `case' statement - then the above transformation is
permitted. The justification being that the restriction on free
variables is not necessary where the procedure is defined and applied
in a single statement.


File: april.info,  Node: The fail procedure,  Prev: Procedures and free variables,  Up: Procedure

9.2.7 The `fail' procedure
--------------------------

The `fail' procedure is a special built-in procedure that is defined
not to have any applying clauses. The type of `fail' is:

     %U{}

which means that it can be used as the `fail' case of a procedure
value. If `fail' is executed, it will cause the `failed' exception to
be raised.


File: april.info,  Node: programs and theta expressions,  Prev: Procedure,  Up: Functions and procedures

9.3 Programs and theta expressions
==================================

As noted in *note theta expression::, a theta expression is a special
form of record expression that provides a syntactic `environment' for
declaring programs. The form of an theta record expression is:

     {
       EL1;
       ...
       ELK
     }

where ELI are one of a user type declaration - *note Type definitions::
- a function declaration, procedure declaration or a variable
declaration.

   Note that a theta record should have at least one semi-colon
character in it. If the theta record has two or more definitions in it
then this will not be a problem: the `;' is used to separate the
definitions. However, if a theta only has a single definition within it,
the programmer should use a `;' as a terminator or postfix operator.

   Semantically a theta record has two `views': internally it is a
binding environment in which recursive programs may be declared; and
externally it is equivalent to a record - a record of all the program
elements declared in it.

* Menu:

* Function declaration::        Function definition in an theta record
* Procedure declaration::       Procedure definition in an theta record
* theta variables::
* theta record expression type::
* Semantics of modules::        The meaning of modules


File: april.info,  Node: Function declaration,  Next: Procedure declaration,  Up: programs and theta expressions

9.3.1 Function declaration
--------------------------

A function declaration in an theta record takes the form of a `labelled'
set of equations:

     {
       ...
       FOO = FUNCTION
       ...
     }

For example, the list append function may be defined using:

     append = {
       ([],?X) => X
     | ([?E,..?R],?X) => [E,..append(R,X)]
     }

The type of this `append' function is determined by the compiler to be:

     (%A[],%A[])=>%A[]

where `%A' is a type variable.

   As syntactic sugar - for the case where a function has a single
defining equation - `April' allows a more convenient form of function
definition within a theta expression:

     FUN(V1,...,VK) => EXP

where VI are all identifiers denoting fresh variables instead of the
slightly more clumsy:

     FUN = {
       (V1,...,VK) => EXP
     }


File: april.info,  Node: Procedure declaration,  Next: theta variables,  Prev: Function declaration,  Up: programs and theta expressions

9.3.2 Procedure declaration
---------------------------

Within an theta record a procedure can be defined as a labelled
mutually recursive set of clauses or, where there is only one clause,
with a notation that is more reminiscent of "C".

   The clausal form of procedure takes the form:

     {
       ...
       P = {
         CLAUSE1
       | CLAUSE2
       | ...
       }
       ...
     }

For example, an `exec' server process procedure may be defined using:

     exec = {
       () -> { repeat{
         ('doMe, P) ->> P()
       } until quit
     }

   `April' allows, as syntactic sugar, a procedure where there is only
one applying clause to be written more concisely:

     exec()
     {
       repeat{
         ('doMe, P) ->> P()
       } until quit
     }

As with functions, the `April' compiler can automatically compute the
type of a procedure. In this case, the type assigned would be:

     (){}

   In `April' procedures are not allowed to directly side-effect any
variables apart from those declared within the procedure itself and any
theta variables (*note theta variables::) that are in its scope.
Although a procedure may refer to other free variables (variables in
scope in the context of the enclosing theta record expression) it is
not permitted to modify them. This restriction is enforced by the
compiler.


File: april.info,  Node: theta variables,  Next: theta record expression type,  Prev: Procedure declaration,  Up: programs and theta expressions

9.3.3 Theta variables
---------------------

An environment variable is a variable declaration that takes place at
the level of other procedures and functions within an theta record
expression. The simplest such expression might be:

     {
       val:23;
       upDate(X){
         val := X;
       }
     }

The variable `val' above is a theta variable. It may be modified by any
top-level procedure or function within the same theta record
expression. An important restriction on theta variables is that they
may not be modified by any functions or procedures which are defined
`outside' the same theta record that the variable is declared in.

   The initial value of a theta variable is determined by the
right-hand side of its declaration. However, while the initializing
expression of a theta variable can be any expression - possibly
involving references to functions also defined within the same theta
record expession - the programmer should be careful to avoid circular
execution problems. The order of evaluation of variable initializations
is not defined; therefore the programmer should _not_ make any
assumptions about the values of other theta variables - including the
variable itself - when determining the initial value of a given theta
variable.

   A theta expression containing one or more theta variables may be
sent in a message to other processes - either on the same host computer
or on other host computers. However, the precise semantics of this
differs in the two cases.

   In the case that a theta expression is shared by two or more
processes within a single `April' invocation; each of these processes
can potentially invoke procedures within the theta record that will
side-affect embedded variables. This can lead to severe complications
with respect to simultaneous access to environment variables by the
different processes.

   In the case that a theta expression is sent to a process on a
_different_ host computer - or a different `April' invocation on the
same computer - then the values of theta variables are duplicated and
become, in effect, separate variables; although they are still
internally linked as a unified theta record on the remote host.


File: april.info,  Node: theta record expression type,  Next: Semantics of modules,  Prev: theta variables,  Up: programs and theta expressions

9.3.4 theta record expression type
----------------------------------

The type of a theta record expression is a record type of all the types
of functions, procedures and variables defined within it. The rules for
the types of individual components of the record are as essentially
those for function and procedure expressions etc. except that the
generalization rules are more complex. Note that any types that are
defined within the theta record are _not_ visible in the type of the
expression as a whole: their scope is strictly within the decorated
braces of the theta record.


File: april.info,  Node: Semantics of modules,  Prev: theta record expression type,  Up: programs and theta expressions

9.3.5 Semantics of modules
--------------------------

`April''s module system (*note April modules::) does not rely on
_names_ of functions and procedures to link together exported and
imported procedures. Instead we regard a module as a _theta expression_
which is effectively a record of procedures, functions and types;
accessing an imported procedure is achieved by accessing the correct
member of the record. The principal benefit of not using names to link
procedures and functions together is that it is very straightforward to
embed programs in messages and data structures that are communicated
between `April' applications.

   In the program:
     program
     import {{()=>string}?hello} from "hello.aam" in
     {
       main(){
         hello() ++ "\n" >> stdout;
       }
     } execute main;

the `hello' program is imported from another code file - `"hello.aam"'.
Within this program the `hello' variable behaves as a _function
variable_ which is then accessed like any other variable value when a
call to `hello' is made.

   We can see this a little more clearly if we look at the underlying
meaning of the `program' structure. Program expressions such as this
are transformed by the compiler into a more primitive form using theta
expressions:

       valof{
         any({()=>string}?hello) = _load_code("hello.aam");
         valis hello
       }.
       {
         main(){
           hello()++"\n" >> stdout
         };
       }.main

This, with some simplification, is how the `April' compiler interprets
the `world' program above.

   This expression has two main components to it: the import component
and the theta component.  The import component is used to provide an
enriched environment for constructing the programs in the theta
component: importing a module is achieve by means of a dot expression
with the imported module forming a record on the left hand side and the
main program on the right:

     IMPORT-COMPONENT.THETA-COMPONENT

The IMPORT-COMPONENT takes the form of a call to a special built-in
function - called `_load_code_' here - the value of which is
dynamically verified to be an appropriate record of imported functions
and procedures.(1)

   The theta component is itself a dot expression:

     {
       PROGRAMS;
     }.ENTRY-POINT

where the theta record expression contains the definitions of the
procedures and functions defined at the top-level of the program and the
ENTRY-POINT - which defines the ultimate value of the whole program
expression - is typically defined as a reference to a procedure which
is defined within the main theta record expression.

   A module is very similar in structure to a regular main program; the
principal difference being that a complete record of procedures and
functions is exported instead of a single procedure entry-point. The
module:

     module import {{()=>string}?world} from "world_name.aam" in
     {
       hello() => "Hello "++ world()
     } export hello;

becomes the rather complex expression:

       valof{
         any({()=>string}?world) = _load_code("world_name.aam");
         valis world
       }.{
         hello() => "Hello "++ world()
       }.(hello=hello)

The rather odd construct:

     (hello=hello)

bears some explanation. Clearly it is a record literal - *note record
type:: - and that is appropriate since modules are records of procedures
and functions. This record has a single field in it - called `hello'.
The _value_ associated with this field is also `hello': the same
`hello' that is defined on the left hand side of the dot expression
within the theta expression. In short an expression of the form:

     R.(f1=f1,f2=f2)

is a way of exporting or projecting a sub-record from a record
expression.

   Since `April' modules are based on theta expressions, they are
actually `first class' values and as such can be assigned to variables
and returned as values of functions. This would allow a module to be
sent in a message for example.

   Notice that we do not refer to any original name of the `hello'
function from within `hello.aam'; we have declared a local variable
called `hello' and bound the imported function to it - the original
name of the function is neither important nor accessible. This feature
of `April' modules is crucial especially in the context of mobile
programming: the fact that programs can be sent in messages, and
invoked, without needing their original name enables us to guarantee
that there can never be a `name clash' between programs - there are no
names to clash!

   This, in turn, helps us to ensure the integrity of large systems - no
program that is imported in a message can affect the programs that are
already there. A program that has been loaded from a message can be
bound to a variable and executed but it cannot `side-affect' the modules
that already make up the executing program.

   ---------- Footnotes ----------

   (1) This must be verified at execution time since the imported
module code is generally compiled separately from the main program.


File: april.info,  Node: Arithmetic functions,  Next: Input and output,  Prev: Tests and conditions,  Up: Top

10 Arithmetic and mathematical functions
****************************************

These functions take numerical arguments.  Giving non-numeric arguments
will result in errors. All arithmetic functions will accept either
integral or fractional arguments. Internally, results of arithmetic
expressions are stored as integers where possible.

* Menu:

* Standard arithmetic functions::
* Mathematical functions::
* Miscellaneous arithmetic functions::


File: april.info,  Node: Standard arithmetic functions,  Next: Mathematical functions,  Up: Arithmetic functions

10.1 Standard arithmetic functions
==================================

These functions implement standard arithmetic operations such as
addition and multiplication. Some of these functions are actually
_polymorphic_ - i.e., they can take different kinds of arguments.

* Menu:

* Addition::                    Addition
* Integer Addition::
* Subtraction::                 Subtraction
* Integer Subtraction::
* Negation::                    Arithmetic negation
* Multiplication::              Multiplication
* Integer Multiplication::
* Division::                    Division
* Integer quotient::            Integer quotient
* Remainder::                   Remainder
* Integer Division::
* Bitwise and::                 Bitwise and
* Bitwsie or::
* Bitwise xor::                 Bitwise exclusive or
* Ones complement::             Bitwise negation
* Logical left shift::
* Logical right shift::
* Absolute value::              Absolute value
* Truncate to Integer::         Truncate to integer nearest 0
* Integer ceiling::             Integer ceiling
* Integer floor::               Integer floor
* Integral test::


File: april.info,  Node: Addition,  Next: Integer Addition,  Up: Standard arithmetic functions

10.1.1 Addition
---------------

Function template:
     number?A + number?B => number

The `+' function returns the result of adding A to B.

   _Hint:_

     The `April' compiler can optimise certain common cases of this
     function, in particular when one of the arguments is an integer
     known at compile time.


File: april.info,  Node: Integer Addition,  Next: Subtraction,  Prev: Addition,  Up: Standard arithmetic functions

10.1.2 Integer Addition
-----------------------

Function template:
     number?A +. number?B => number

The `+.' function returns the result of adding A to B.  However, `.+'
is only defined for 64 bit integers; and it returns a number that is
also a 64 bit integer.


File: april.info,  Node: Subtraction,  Next: Integer Subtraction,  Prev: Integer Addition,  Up: Standard arithmetic functions

10.1.3 Subtraction
------------------

Function template:
     number?A - number?B => number

The `-' function returns the result of subtracting B from A.


File: april.info,  Node: Integer Subtraction,  Next: Negation,  Prev: Subtraction,  Up: Standard arithmetic functions

10.1.4 Integer Subtraction
--------------------------

Function template:
     number?A -. number?B => number

The `-.' function returns the result of subtracting B from A. However,
`-.' is only defined for 64 bit integers; and it returns a number that
is also a 64 bit integer.


File: april.info,  Node: Negation,  Next: Multiplication,  Prev: Integer Subtraction,  Up: Standard arithmetic functions

10.1.5 Negation
---------------

Function template:
     - number?A => number

Unary negation is equivalent to subtracting from 0.


File: april.info,  Node: Multiplication,  Next: Integer Multiplication,  Prev: Negation,  Up: Standard arithmetic functions

10.1.6 Multiplication
---------------------

Function template:
     number?A * number?B => number

The `*' function returns the result of multiplying A and B.


File: april.info,  Node: Integer Multiplication,  Next: Division,  Prev: Multiplication,  Up: Standard arithmetic functions

10.1.7 Integer Multiplication
-----------------------------

Function template:
     number?A *. number?B => number

The `*.' function returns the result of multiplying B and A. However,
`*.' is only defined for 64 bit integers; and it returns a number that
is also a 64 bit integer.


File: april.info,  Node: Division,  Next: Integer quotient,  Prev: Integer Multiplication,  Up: Standard arithmetic functions

10.1.8 Division
---------------

Function template:
     number?A / number?B => number

The `/' function returns the result of dividing A by B.

   Note that division always returns an accurate result - as far as is
possible within the limits of the floating point representation. So, the
expression:

     2/3

will return `0.66...7' even though both arguments are integral. Use
integer quotient (*note Integer quotient::) for obtaining the integer
values of a quotient; similarly, the `rem' function (*note Remainder::)
can determine the remainder after a division.

   Possible error:
   * `"division by zero"'


File: april.info,  Node: Integer quotient,  Next: Remainder,  Prev: Division,  Up: Standard arithmetic functions

10.1.9 Integer quotient
-----------------------

Function template:
     number?A quot number?B => number

The `quot' function returns the integer quotient obtained by dividing A
by B. Note that `quot' can return an integral quotient even if A and/or
B are not themselves integral.

   Possible error:
   * `"division by zero"'


File: april.info,  Node: Remainder,  Next: Integer Division,  Prev: Integer quotient,  Up: Standard arithmetic functions

10.1.10 Remainder function
--------------------------

Function template:
     number?A rem number?B => number

This function returns the remainder obtained by dividing A by B. `rem'
follows POSIX conventions for the result: the magnitude of `rem''s
result is always less than B, and its sign agrees with the sign of A.

   Possible error:
   * `"division by zero"'


File: april.info,  Node: Integer Division,  Next: Bitwise and,  Prev: Remainder,  Up: Standard arithmetic functions

10.1.11 Integer Division
------------------------

Function template:
     number?A /. number?B => number

The `/.' function returns the result of dividing A by B. However, `/.'
is only defined for 64 bit integers; and it returns a number that is
also a 64 bit integer.


File: april.info,  Node: Bitwise and,  Next: Bitwsie or,  Prev: Integer Division,  Up: Standard arithmetic functions

10.1.12 Bitwise and function
----------------------------

Function template:
     band(number?A,number?B) => number

This function returns the `bitwise and' of the two integers A and B.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.(1)

   Possible errors:
   * `"argument should be integer"'

   ---------- Footnotes ----------

   (1) On Intel Linux sysems, integer precision is 64bit.


File: april.info,  Node: Bitwsie or,  Next: Bitwise xor,  Prev: Bitwise and,  Up: Standard arithmetic functions

10.1.13 Bitwise or
------------------

Function template:
     bor(number?A,number?B) => number

This function returns the `bitwise or' of the two integers A and B.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.

   Possible errors:
   * `"argument should be integer"'


File: april.info,  Node: Bitwise xor,  Next: Ones complement,  Prev: Bitwsie or,  Up: Standard arithmetic functions

10.1.14 Bitwise exclusive or
----------------------------

Function template:
     bxor(number?A,number?B) => number

This function returns the `bitwise exclusive or' of the two integers A
and B.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.

   Possible errors:
   * `"argument should be integer"'


File: april.info,  Node: Ones complement,  Next: Logical left shift,  Prev: Bitwise xor,  Up: Standard arithmetic functions

10.1.15 Ones complement
-----------------------

Function template:
     bnot(number?A) => number

This function returns the `bitwise negation' or one's complement of the
integer A.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.

   Possible errors:
   * `"argument should be integer"'


File: april.info,  Node: Logical left shift,  Next: Logical right shift,  Prev: Ones complement,  Up: Standard arithmetic functions

10.1.16 Logical left shift
--------------------------

Function template:
     bleft(number?A,number?B) => number

This function returns the `logical left shift' of the integer A by the
number of bits given in B. Each left shift by 1 bit amounts to a
multiplication by 2. Excess bits will be dropped off the left.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.

   Possible errors:
   * `"argument should be integer"'


File: april.info,  Node: Logical right shift,  Next: Absolute value,  Prev: Logical left shift,  Up: Standard arithmetic functions

10.1.17 Logical right shift
---------------------------

Function template:
     bright(number?A,number?B) => number

This function returns the `bitwise right shift' or logical right shift
of the integer A by the number of bits given in B. Each right shift by
1 bit amounts to a division by 2. Excess bits will be dropped off the
right.

   Note that `April''s integer precision is not defined, however it is
at least 16 bits.

   Possible errors:
   * `"argument should be integer"'


File: april.info,  Node: Absolute value,  Next: Truncate to Integer,  Prev: Logical right shift,  Up: Standard arithmetic functions

10.1.18 Absolute value
----------------------

Function template:
     abs(number?A) => number

This function returns the absolute value of A.


File: april.info,  Node: Truncate to Integer,  Next: Integer ceiling,  Prev: Absolute value,  Up: Standard arithmetic functions

10.1.19 Truncate to Integer
---------------------------

Function template:
     trunc(number?A) => number

This function returns the integer rounded value of A.  This is
equivalent to the nearest integer - in the direction of 0 - to A. Where
the absolute value of A is greater than the range of representable
integers(1) the returned value is the remainder after dividing by
2**K-1 where integers are represented in K bits. Put more plainly, not
only is the number coerced to an integral value, but an integral value
that can be represented in K bits.

   ---------- Footnotes ----------

   (1) Typically 64 bits are used to represent integer `number' values.


File: april.info,  Node: Integer ceiling,  Next: Integer floor,  Prev: Truncate to Integer,  Up: Standard arithmetic functions

10.1.20 Integer ceiling
-----------------------

Function template:
     ceil(number?A) => number

This function returns the integer ceiling of A.  This is equivalent to
truncating towards positive infinity.


File: april.info,  Node: Integer floor,  Next: Integral test,  Prev: Integer ceiling,  Up: Standard arithmetic functions

10.1.21 Integer floor
---------------------

Function template:
     floor(number?A) => number

This function returns the floor of A.  This is equivalent to truncating
towards negative infinity.


File: april.info,  Node: Integral test,  Prev: Integer floor,  Up: Standard arithmetic functions

10.1.22 Integral test
---------------------

Function template:
     integral(number?A) => logical

This function returns `true' if A an integral number.


File: april.info,  Node: Mathematical functions,  Next: Miscellaneous arithmetic functions,  Prev: Standard arithmetic functions,  Up: Arithmetic functions

10.2 Mathematical Functions
===========================

These functions give support for complex mathematical computations such
as trigonometry.

* Menu:

* sqrt::                        Square root
* cbrt::                        Cube root
* pow::                         Power
* exp::                         Exponentation
* log::                         Natural logarithm
* log10::                       Deciaml logarithm
* sin::                         Trigonometric sin
* cos::                         Trigonometric cos
* tan::
* asin::                        Trigonometric arc sin
* acos::                        Trigonometric arc cos
* atan::                        Trigonometric arc tan
* sinh::                        Hyperbolic sinh
* cosh::                        Hyperbolic cosh
* tanh::                        Hyperbolic tanh
* asinh::                       Hyperbolic inverse sinh
* acosh::                       Hyperbolic inverse cosh
* atanh::                       Trigonometric inverse tanh


File: april.info,  Node: sqrt,  Next: cbrt,  Up: Mathematical functions

10.2.1 Square root
------------------

Function template:
     sqrt(number?A) => number

This function returns the square root of A.

   Possible error:
   * `"argument should be positive number"'


File: april.info,  Node: cbrt,  Next: pow,  Prev: sqrt,  Up: Mathematical functions

10.2.2 Cubic root
-----------------

Function template:
     cbrt(number?A) => number

This function returns the cube root of A.


File: april.info,  Node: pow,  Next: exp,  Prev: cbrt,  Up: Mathematical functions

10.2.3 Power function
---------------------

Function template:
     pow(number?A,number?B) => number

This function returns A raised to the power of B.


File: april.info,  Node: exp,  Next: log,  Prev: pow,  Up: Mathematical functions

10.2.4 Natural exponent function
--------------------------------

Function template:
     exp(number?A) => number

This function returns E (approximately 2.7182818) raised to the power A.


File: april.info,  Node: log,  Next: log10,  Prev: exp,  Up: Mathematical functions

10.2.5 Natural logarithm function
---------------------------------

Function template:
     log(number?A) => number

This function returns the natural logarithm of A.

   _Hint:_

     It is possible to generate the logarithm of a number to any base
     by using the formula: logx(A) = log(A)/log(x)



File: april.info,  Node: log10,  Next: sin,  Prev: log,  Up: Mathematical functions

10.2.6 Logarithm base 10
------------------------

Function template:
     log10(number?A) => number

This function returns the logarithm to base 10 of A.


File: april.info,  Node: sin,  Next: cos,  Prev: log10,  Up: Mathematical functions

10.2.7 Trigonometric sine
-------------------------

Function template:
     sin(number?A) => number

This function returns the sine of the angle A - A is expressed in
radians.

   _Hint:_

     It is possible to convert degrees into radians by dividing by
     180/pi which is approximately 57.29578.



File: april.info,  Node: cos,  Next: tan,  Prev: sin,  Up: Mathematical functions

10.2.8 Trigonometric cosine
---------------------------

Function template:
     cos(number?A) => number

This function returns the cosine of the angle A where A is expressed in
radians.


File: april.info,  Node: tan,  Next: asin,  Prev: cos,  Up: Mathematical functions

10.2.9 Trigonometric tangent
----------------------------

Function template:
     tan(number?A) => number

This function returns the tangent of the angle A, where A is expressed
in radians.


File: april.info,  Node: asin,  Next: acos,  Prev: tan,  Up: Mathematical functions

10.2.10 Arc sine
----------------

Function template:
     asin(number?A) => number

This function returns the arc sine, in radians, of A.  The value of the
function will be in the range [-pi/2,pi/2].

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: acos,  Next: atan,  Prev: asin,  Up: Mathematical functions

10.2.11 Arc cosine
------------------

Function template:
     acos(number?A) => number

The `acos' function returns the arc cosine, in radians, of A.  The
value of the function will be in the range [0,pi].

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: atan,  Next: sinh,  Prev: acos,  Up: Mathematical functions

10.2.12 Arc tangent
-------------------

Function template:
     atan(number?A) => number

The `atan' function returns the arc tangent, in radians, of A.  The
function's value will be in the range [-pi/2,pi/2].

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: sinh,  Next: cosh,  Prev: atan,  Up: Mathematical functions

10.2.13 Hyperbolic sine
-----------------------

Function template:
     sinh(number?A) => number

The `sinh' function returns the hyperbolic sine of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: cosh,  Next: tanh,  Prev: sinh,  Up: Mathematical functions

10.2.14 Hyperbolic cosine
-------------------------

Function template:
     cosh(number?A) => number

The `cosh' function returns the hyperbolic cosine of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: tanh,  Next: asinh,  Prev: cosh,  Up: Mathematical functions

10.2.15 Hyperbolic tangent
--------------------------

Function template:
     tanh(number?A) => number

The `tanh' function returns the hyperbolic tangent of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: asinh,  Next: acosh,  Prev: tanh,  Up: Mathematical functions

10.2.16 Inverse hyperbolic sine
-------------------------------

Function template:
     asinh(number?A) => number

The `asinh' function returns the inverse hyperbolic sine of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: acosh,  Next: atanh,  Prev: asinh,  Up: Mathematical functions

10.2.17 Inverse hyperbolic cosine
---------------------------------

Function template:
     acosh(number?A) => number

This returns the inverse hyperbolic cosine of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: atanh,  Prev: acosh,  Up: Mathematical functions

10.2.18 Inverse hyperbolic tangent
----------------------------------

Function template:
     atanh(number?A) => number

This returns the inverse hyperbolic tangent of A.

   Possible errors:
   * `"domain error or singularity"'

   * `"floating point overflow or underflow"'


File: april.info,  Node: Miscellaneous arithmetic functions,  Prev: Mathematical functions,  Up: Arithmetic functions

10.3 Miscellaneous arithmetic functions
=======================================

* Menu:

* ldexp::                       Raise a number by a power of 2
* frexp::                       Compute mantissa and exponent
* modf::                        Compute integer and fractional part of number
* rand::                        random number generation
* irand::                       random integer generation
* seed::                        seeding the random number generator


File: april.info,  Node: ldexp,  Next: frexp,  Up: Miscellaneous arithmetic functions

10.3.1 Raise by power of 2
--------------------------

Function template:
     ldexp(number?X,number?N)=>number

The `ldexp' function computes the expression: X*2**N

This function is useful for manipulating floating point numbers
directly.


File: april.info,  Node: frexp,  Next: modf,  Prev: ldexp,  Up: Miscellaneous arithmetic functions

10.3.2 Compute mantissae and exponent of f.p. number
----------------------------------------------------

Function template:
     frexp(number?X)=>(mantissae,exponent)

This function computes the mantissae and exponent of the number X. The
mantissae is a number in the range: [0.5,1) and the exponent is the
power to raise 2 to to recover the original number. `frexp' obeys the
equations:
     (mant, exp) .= frexp(X)
     mant*2**exp = X


File: april.info,  Node: modf,  Next: rand,  Prev: frexp,  Up: Miscellaneous arithmetic functions

10.3.3 Compute integer and fraction part
----------------------------------------

Function template:
     modf(number?X)=>(integer,fraction)

The `modf' function extracts the integer part of a number and the
fractional part of the number as a pair. The integer part of `12.34' is
`12', whereas the fractional part is `0.34'.


File: april.info,  Node: rand,  Next: irand,  Prev: modf,  Up: Miscellaneous arithmetic functions

10.3.4 Generate random number
-----------------------------

Function template:
     rand(number?A) => number

This function returns a random positive number. The number generated is
a floating point number in the range [0;A)

   The internal algorithm uses a non-linear additive feedback random
number generator employing a table of 31 long integers to return
sucessive pseudo-random numbers in the range $[0;2**31-1).  The value
is then scaled appropriately according to A.

   Possible errors:
   * `"argument should be positive number"'

   _Hint:_

     The random number generation can be _seeded_ using the `seed'
     procedure (*note seed::): this can be used to generate a `random'
     but repeatable sequence of numbers.


File: april.info,  Node: irand,  Next: seed,  Prev: rand,  Up: Miscellaneous arithmetic functions

10.3.5 Generate random integer
------------------------------

Function template:
     irand(number?A) => number

This function returns a random positive integer in the range [0;A-1].

   Possible errors:
   * `"argument should be positive integer"'


File: april.info,  Node: seed,  Prev: irand,  Up: Miscellaneous arithmetic functions

10.3.6 Set random number seed
-----------------------------

Procedure template:
     seed(integer?N){}

Initialize the seed for the random number generator with N. This
procedure sets the seed for both the `rand' and the `irand' functions.

   Possible errors:
   * `"argument should be positive number"'

   _Hint:_

     By seeding the generator with a value such as `ticks()' (*note
     ticks::) a more effective and truly random sequence can be
     generated.


File: april.info,  Node: Input and output,  Next: String handling,  Prev: Arithmetic functions,  Up: Top

11 Input and Output
*******************

In `April', file oriented input and output is based on special file
handling processes. Application `April' processes do not directly
access the file system of the operating system - instead, a process
performs I/O by sending an appropriate message to a special
file-handling process.

   Two benefits of this architecture are protection and uniformity of
access. By encapsulating file access in this way it is easier to protect
the file system against unwarranted access; this is especially important
in the case of systems executing code from `external sources' - recall
that `April' programs may be sent in messages and may be executed
remotely. Having a uniform method of access to the file system allows
references to open files - which are simply process `handle's - to be
sent in messages, stored in structures, without requiring special
techniques.

   In order to manage access to the file system, each `April' process
references a particular process - the `file_manager()' process (*note
file_manager::).  When an application wishes to open a file, then it
sends a message to the `file_manager' which verifies that the file is
available and returns the handle of another process which is actually
responsible for handling the specific file.

   In order to make access to the file system relatively transparent,
`April' provides a number of standard functions and procedures which
encapsulate the message passing protocol.

   In addition to regular files, with straightforward file accessing
primitives, such as `inline' and `feof', `April' has a simple streaming
style of file. Where appropriate, streaming I/O (*note Stream input &
output::), can be considerably easier to use than the regular file I/O
primitives. However, streaming I/O is not as flexible as regular file
I/O when dealing with files as data sets (such as databases).

* Menu:

* Files and file descriptors::  `April''s standard files
* Opening and closing files::   Primitives to open, close and monitor files
* File positioning::            Moving inside files
* Files and Directories::       Creating directories etc.
* String oriented input/output::
* Encoded Input/Output::        I/O using `April''s internal format
* Socket library::              Remote communications using TCP
* Stream input & output::


File: april.info,  Node: Files and file descriptors,  Next: Opening and closing files,  Up: Input and output

11.1 Files and file descriptors
===============================

* Menu:

* File names::                  Format and conventions for file names
* File open mode::
* File system access modes::
* File permission::
* file_manager::                Identify file manager process
* Standard files::              The three standard files


File: april.info,  Node: File names,  Next: File open mode,  Up: Files and file descriptors

11.1.1 File names and conventions for file names
------------------------------------------------

When a process attempts to open a file, it sends the name of the file as
a `string' to the `file_manager' process (*note file_manager::). The
`file_manager' interprets the file name according to normal file name
conventions: if the file name contains embedded "`/'" characters then
it assumes that a file within a sub-directory of the `home' directory
is being accessed.

   The home directory is normally the directory which is current at the
time that `April' is invoked.  


File: april.info,  Node: File open mode,  Next: File system access modes,  Prev: File names,  Up: Files and file descriptors

11.1.2 File opening mode
------------------------

The `_file_open_mode' type is used by `fopen' to determine how to open
a file:

     _file_open_mode ::= _open_read | _open_write | _open_read_write
             | _open_append | _create_write | _create_append;

`_open_read'
     Attempt to open a file for reading. The `fopen' function will raise
     an exception if the file is not present.

`_open_write'
     Attempt to open a file for writing to.

`_open_read_write'
     Attempt to open a file for both reading and writing.

`_open_append'
     Attempt to open a file for writing to, and position file marker at
     the end of the file.

`_create_write'
     Attempt to open a file for writing to. If the file is not there,
     create a new one.

`_create_append'
     Attempt to open a file for writing to, and position file marker at
     the end of the file.  If the file is not there, create a new one.


File: april.info,  Node: File system access modes,  Next: File permission,  Prev: File open mode,  Up: Files and file descriptors

11.1.3 File system access modes
-------------------------------

The `April' file manager uses the concept of a _file mode_ to determine
the legal actions on a file. The legal file modes are defined in the
standard type definition:

     _access_right ::= allow_read | allow_write | allow_pipe |
             allow_connect | allow_server;

`allow_read'
     This permission gives a process the right to read files from the
     file and/or file system.

`allow_write'
     This permission gives a process the right to write to files and to
     create files in the file system.

`allow_pipe'
     This permission gives a process the right to fork an operating
     system sub-process as a pipe; and to read or write (depending on
     other permissions) to that pipe.

`allow_connect'
     This permission gives a process the right to use `tcp_connect' to
     services on other host computers.

`allow_server'
     This permission gives a process the right to act as a `tcp_server'.

These permissions can and are often used in combination - the file
manager maintains a set of permissions which client processes may have.


File: april.info,  Node: File permission,  Next: file_manager,  Prev: File system access modes,  Up: Files and file descriptors

11.1.4 File permission
----------------------

The file permission is the set of attributes associated with the file
_by the operating system_ - it does not necessarily reflect the rights
of the `April' process on the file. In general, those are formed from
the intersection of the file permissions and the file modes - *note
File system access modes::.

     _file_permission ::= _setuid | _setgid | _sticky
             | _rusr | _wusr | _xusr
             | _rgrp | _wgrp | _xgrp
             | _roth | _woth | _xoth;

`_setuid'
     This is present if the file has the `SETUID' flag set. This flag
     is typically set on directories or executable files.

`_setgid'
     This is present if the file has the `SETGID' flag set. This flag
     is typically set on directories or executable files.

`_sticky'
     This is present if the file has the `STICKY' flag set.

`_rusr'
     This is present if the owner of the file has `READ' permission for
     the file.

`_wusr'
     This is present if the owner of the file has `WRITE' permission for
     the file.

`_xusr'
     This is present if the owner of the file has `EXECUTE' permission
     for the file.

`_rgrp'
     This is present if the owner's group of the file has `READ'
     permission for the file.

`_wgrp'
     This is present if the owner's group of the file has `WRITE'
     permission for the file.

`_xgrp'
     This is present if the owner's group of the file has `EXECUTE'
     permission for the file.

`_roth'
     This is present if all users have `READ' permission for the file.

`_woth'
     This is present if all users have `WRITE' permission for the file.

`_xoth'
     This is present if all users have `EXECUTE' permission for the
     file.


File: april.info,  Node: file_manager,  Next: Standard files,  Prev: File permission,  Up: Files and file descriptors

11.1.5 File manager process
---------------------------

Function template:

     file_manager() => handle

This function returns the `handle' of the process'es file manager
process (*note File manager::). This process is assigned by the `April'
system when the process is forked and governs the rights of the process
to access files and to perform input and output.

   It is possible to `spawn' processes with specific file manager
processes - usually one based on restricted access to the file system.


File: april.info,  Node: Standard files,  Prev: file_manager,  Up: Files and file descriptors

11.1.6 Standard files
---------------------

As noted in *Note Input and output:: file processing is handled via
special _file processes_. In addition to files opened especially, the
`April' system provides three special file processes automatically -
`stdin', `stdout' and `stderr':

`stdout'
     which corresponds to the standard output channel of a Unix
     process. By default, this is identified with the window in which
     the `April' command is invoked.

`stdin'
     which corresponds to the standard input channel of a Unix process.
     Normally this is connected to the keyboard.

`stderr'
     which is the standard error reporting channel. This channel should
     be used for reporting errors or making comments about the program
     input.

     Normally, this is connected to the same channel as `stdout', but
     it can be redirected separately from this channel.


File: april.info,  Node: Opening and closing files,  Next: File positioning,  Prev: Files and file descriptors,  Up: Input and output

11.2 Opening and closing files
==============================

* Menu:

* fopen::                       Open a file
* fclose::                      Close an open file
* eof::                         Test for end-of-file
* fready::                      Test for file ready for I/O
* fflush::                      Flush file buffer
* popen::                       Open a Unix pipe
* sub_manager::                 Open a new file manager


File: april.info,  Node: fopen,  Next: fclose,  Up: Opening and closing files

11.2.1 Open a file
------------------

Function template:
     fopen(string?FILENAME,_file_open_mode?MODE) => handle

A file is opened using the `fopen' standard function - which in turns
asks the `file_manager' to open the file.

     F = fopen(FILENAME,_open_read)

The file manager responds with the identity of a process which is given
the appropriate access rights to the file; or an error exception is
raised. The specific way the file is opend (read-only, read-write) is
governed by MODE which is a `_file_open_mode'; *note File open mode::.

   The process `handle' that is returned can be used in subsequent file
access operations.

   The file name argument to `fopen' is subject to file name
interpretation (*note File names::).

   Possible errors:
   * `"problem in opening file"'

   * `"file not found"'

   * `"permission denied"'


File: april.info,  Node: fclose,  Next: eof,  Prev: fopen,  Up: Opening and closing files

11.2.2 Close file process
-------------------------

Procedure template:
     fclose(handle?FILE){}

The standard `fclose' procedure is used to close a file. This standard
procedure sends a `_close_' message to the file's process. Any messages
sent to the FILE process after closing it will be ignored; and any
functions or procedures which access the file will not return.


File: april.info,  Node: eof,  Next: fready,  Prev: fclose,  Up: Opening and closing files

11.2.3 Test for end of file
---------------------------

Function template:
     eof(handle?FILE)=>logical

The end-of-file status of a file can be checked using the `eof'
standard function.  It returns either `true' or `false' depending on
whether the file is at the end or not.

   Note that if the FILE is not `ready' - for example if it is the
keyboard or a file connected to a TCP/IP socket and no data is present
for the file - then the call to `eof' will _suspend_. This results in
the process suspending; although other processes may continue
executing. When data becomes available (even if that means the end of
the file) then the `eof' test will continue and a result will be
returned.


File: april.info,  Node: fready,  Next: fflush,  Prev: eof,  Up: Opening and closing files

11.2.4 Test if file is ready for I/O
------------------------------------

Function template:
     fready(handle?FILE)=>logical

The `fready' test is used to check if a file is ready for input or
output (depending on the type of file). It useful in cases where the
file is actually connected to the keyboard to another process (such as a
pipe or socket connection).

   If FILE is an input file, then if `fready' returns `true', an `eof'
test (*note eof::) on FILE is guaranteed not to block. Generally, it
also means that it is safe to read at least one character from FILE
(unless it is at end of file).

   If FILE is an output file, then if `fready' returns `true', then a
write of a single character to the FILE is also guaranteed not to
block. However, if `fready' returns `false' then a file operation on
FILE may still not block due to timing considerations.


File: april.info,  Node: fflush,  Next: popen,  Prev: fready,  Up: Opening and closing files

11.2.5 Flush output
-------------------

Procedure template:
     fflush(handle?FILE){}

Normally, output is block buffered.  This can result in a delay before
output appears, especially on the screen.

   Invoking the `fflush' procedure causes all pending output to be
flushed immediately.  A typical use for this is to display a prompt on
the screen and leave the cursor on the same line ready for input.

   Note that `fflush' is automatically invoked whenever the entire
`April' engine must pause waiting for input; i.e., if all the processes
inside a given `April' invocation pause - whether they are waiting for
input from a file or simply waiting for a message - then, just before
the `April' engine itself pauses, it forces all output buffers to be
flushed.


File: april.info,  Node: popen,  Next: sub_manager,  Prev: fflush,  Up: Opening and closing files

11.2.6 Open a pipe
------------------

Function template:
     popen(string?CMD,string[]?ARGS,string[]?ENV)
       => (handle, handle, handle)

This function forks a child process and returns a tuple triple of three
file handles that can be used to communicate with the child - the first
represents the standard output from the child and the second represents
the standard input to the child process and the third represents the
standard error from the child.

   The CMD `string' gives the path of the command to run in the
background; the list ARGS are the arguments to the program, and the ENV
list gives the values of additional environment variables to set for
the command. The form of the ENV list is the same as for `exec' (*note
exec::): a list of strings of the form `variable=value'.

   The returned file handles can be used in subsequent input/output
operations in the same way that a regular file handles can be used -
except that certain operations are not available for pipes, especially
file positioning operations.

   _Note:_ the calling process that creates a pipe should ensure that
it _reads_ from the child's standard output and that it _writes_ to the
child's standard input. Similarly, the error output from the child
process should be _read_ by the calling process.

   Possible errors are:
   * `"cant open pipe"'

   * `"permission denied"'

Note that `fclose()' can and should be used to close the two pipe
handles returned by `popen'.

   _Hint_

     Pipes can be used to `import' data from other Unix applications.
     For example, to find out the current working directory the
     expression:
          valof {
            (i,o,e) .= popen("pwd",[],[]);
            cwd = inline(i);
            fclose(i);
            fclose(o);
            fclose(e);
            valis cwd;
          };
     could be used; although this particular information is available
     via the standard function `fpwd' - *note fpwd::.


File: april.info,  Node: sub_manager,  Prev: popen,  Up: Opening and closing files

11.2.7 Create sub file-manager
------------------------------

Function template:
     sub_manager(string?DIR,_access_right[]?MODES)=>handle

This function `asks' for a new file manager to be created. The
directory DIR must be a sub-directory of the process's home directory,
and the list of MODES should be a subset of the process'es access
permissions.

   If successful, a new file manager process is created, with DIR as
its home directory and access permissions being the intersection of
MODES and the file manager's access permissions.

   This function is typically used with the `spawn'...`using' operator
to fork a process with restricted access to the file system (*note
spawn::).


File: april.info,  Node: File positioning,  Next: Files and Directories,  Prev: Opening and closing files,  Up: Input and output

11.3 File Positioning
=====================

* Menu:

* ftell::                       Report file position
* fseek::                       Set new file position


File: april.info,  Node: ftell,  Next: fseek,  Up: File positioning

11.3.1 Report current file position
-----------------------------------

Function template:
     ftell(handle?FILE)=>number

The `ftell' function returns the current position of the read/write
pointer in the currently open FILE - expressed as the number of bytes
from the beginning of the file.

   Possible errors:
   * `"argument not a file descriptor"'

   * `"file not open"'


File: april.info,  Node: fseek,  Prev: ftell,  Up: File positioning

11.3.2 Set file position
------------------------

Procedure template:
     fseek(handle?FILE,number?POS,number?M){}

This procedure requests that the file pointer of the open FILE is set
to POS. The new position is at the signed distance POS bytes from the
beginning, the current position, or the end of the file, depending on
whether M has the value 0, 1, or 2 respectively. Any subsequent file
input/output operation on the file will be relative to the new position.

   Note that the end of a text file is _after_ the last element, so that
     fseek(F,-1,2)
   will position the file pointer on the last real character (usually
the CR at the end of the last line) of the file controlled by F.

   Possible errors:
   * `"invalid fseek mode"'

   * `"cant fseek to position in file"'

   * `"permission denied"'


File: april.info,  Node: Files and Directories,  Next: String oriented input/output,  Prev: File positioning,  Up: Input and output

11.4 Files and Directories
==========================

These operations permit the manipulation of files and directories
without necessarily inspecting their contents. They all involve sending
messages to the `file_manager()' process, which will verify that the
requested operations are permitted to the requesting process.

* Menu:

* ffilename::                   Compute full file name
* ffile::                       Test for file presence
* fmode::                       Get file permissions
* fchmod::                      Set file permissions
* ffiletype::                   Get file type
* fstat::                       Full file status
* frm::                         Delete a file
* fmv::                         Rename a file
* fcd::                         Change current directory
* fpwd::                        Report current directory
* fhome::                       Report home directory
* fmkdir::                      Create a new directory
* frmdir::                      Delete a directory
* fls::                         List contents of directory


File: april.info,  Node: ffilename,  Next: ffile,  Up: Files and Directories

11.4.1 Compute full name of file
--------------------------------

Function template:
     ffilename(string?F)=>string

This is used to compute the complete path of a partially specified file
name. Essentially, the file manager applies `April''s file name
interpretation to F and returns the result.

   Note that a successfull computation of a file's full path name does
not imply that the file exists.

   _Hint:_

     This function can be used to help with distributed applications
     involving files.  Typically, with several machines involved in a
     single collaborative application, it is difficult to determine the
     proper location of files.  When a file name has to be transmitted
     to an `April' program on another machine, computing its full path
     name may make it more likely that the `April' program on the other
     machine will be able to locate the file.

   Possible error:
   * `"argument should be a string"'

   * `"file not found"'

   * `"permission denied"'


File: april.info,  Node: ffile,  Next: fmode,  Prev: ffilename,  Up: Files and Directories

11.4.2 Test for presence of file
--------------------------------

Function template:
     ffile(string?FILE)=>logical

The `file_manager' function returns `true' if the file FILE exists and
is readable, otherwise `false'.

   The FILE argument is subject to `April''s file name interpretation.

   Possible error:
   * `"permission denied"' This may happen if the requesting process
     does not have permission to read the file system.


File: april.info,  Node: fmode,  Next: fchmod,  Prev: ffile,  Up: Files and Directories

11.4.3 Get file permissions
---------------------------

Function template:
     fmode(string?FILE)=>_file_permission_[]

`fmode' returns the permissions associated with a particular file - as
a list of `_file_permission_' symbols; `_file_permission_' is a
standard predefined type. For each `enabled' permission, a particular
`_file_permission' symbol is returned in the list - *note File
permission::.

   Possible errors:
   * `"permission denied"'

   * `"cant stat file"' which occurs when the file doesnt exist.


File: april.info,  Node: fchmod,  Next: ffiletype,  Prev: fmode,  Up: Files and Directories

11.4.4 Set file permissions
---------------------------

Procedure template:
     fchmod(string?FILE,_file_permission_[]?perms){}

`fchmod' sets the permissions on a particular file. The required
permissions are passed as a list of `_file_permission_' symbols - the
same symbols as in `fmode' - *note fmode::.


File: april.info,  Node: ffiletype,  Next: fstat,  Prev: fchmod,  Up: Files and Directories

11.4.5 Get type of file
-----------------------

Function template:
     ffiletype(string?FILE)=>_file_type

This function returns a `_file_type' symbol describing the type of the
file:

`_not_found'
     This is returned if the `File' could not be found.

`_fifo_special'
     The file is a special FIFO file.

`_char_special'
     The file is a character special file - i.e., a character device.

`_block_special'
     The file is a block special file - i.e., a block device such as a
     disk.

`_directory'
     The file is a directory.

`_plain_file'
     A regular file.

`_sym_link'
     The file is a symbolic link to another file


File: april.info,  Node: fstat,  Next: frm,  Prev: ffiletype,  Up: Files and Directories

11.4.6 Get file status
----------------------

Function template:
     fstat(string?FILE)=>_file_status

This function returns a record of 13 integers corresponding to the file
status of the specified file.  The file name FILE is interpreted
according to `April''s file name interpretations.

   The returned record has the type:
     _file_status ::= _file_stat(
          number?device,        -- device file resides on
           number?serial,       -- file serial number
           number?mode,         -- file permissions
           number?links,        -- number of hard links to the file
           number?usr,          -- user ID of owner
           number?grp,          -- group ID of owner
           number?dev,          -- the device identifier (special files only)
           number?size,         -- total size of file, in bytes
           number?access,       -- file last access time (in `April' time)
           number?modify,       -- file last modify time (in `April' time)
           number?change,       -- file last status change time
           number?bksize,       -- preferred blocksize for file system input/output
           number?noblks        -- actual number of blocks allocated
         )

   Possible errors:
   * `"argument should be a file or name"'

   * `"cant stat file"'

   * `"permission denied"'

   Note that the specifications of `fstat' may vary on different
implementations of `April' - due to differing operating system
conventions about the infomation available about files.


File: april.info,  Node: frm,  Next: fmv,  Prev: fstat,  Up: Files and Directories

11.4.7 Delete a file
--------------------

Procedure template:
     frm(string?FILE){}

Delete the named file FILE from the file system.  The file name is
subject to `April''s file name interpretation (*note File names::).

   Possible errors:
   * `"argument should be a string"'

   * `"cant remove file"'

   * `"permission denied"'


File: april.info,  Node: fmv,  Next: fcd,  Prev: frm,  Up: Files and Directories

11.4.8 Rename a file
--------------------

Procedure template:
     fmv(string?FILE1,string?FILE2){}

Ask the file manager to rename FILE1 to be FILE2.

   The file names FILE1 and FILE2 are subject to `April''s file name
interpretation (*note File names::).

   * `"cant move file"'

   * `"permission denied"'


File: april.info,  Node: fcd,  Next: fpwd,  Prev: fmv,  Up: Files and Directories

11.4.9 Change current directory
-------------------------------

Procedure template:
     fcd(string?DIRECTORY){}

This procedure request the file manager to change its current working
directory to DIRECTORY.  This argument is the name of the new directory
which is subject to `April''s file name interpretation *note File
names::).

   The file manager will not necessarily permit this operation -
depending on the particular permissions set up for the requesting
process. In particular, if the new directory lies outside the file
manager's root then it will deny the command.

   Note also that this does not necessarily change the current working
directory of the whole `April' invocation. There may be several file
manager processes active in a given invocation - each with a different
working directory. This issue is most important when using the `exec'
or `shell' procedures to execute Unix commands - `fcd' should _not_ be
used to change the current directory for the purposes of those
procedures.

   Possible errors:
   * `"argument should be a string"'

   * `"cant change to directory"'

   * `"permission denied"'


File: april.info,  Node: fpwd,  Next: fhome,  Prev: fcd,  Up: Files and Directories

11.4.10 Report current directory
--------------------------------

Function template:
     fpwd()=>string

This function returns the current working directory of the process'es
working directory as a string.

   Note that since different processes may have different file managers
associated with them, they may well report different current
directories.


File: april.info,  Node: fhome,  Next: fmkdir,  Prev: fpwd,  Up: Files and Directories

11.4.11 Report home directory
-----------------------------

Function template:
     fhome()=>string

This function returns the file manager's home directory as a string.

   Note that since different processes may have different file managers
associated with them, they may well report different home directories.


File: april.info,  Node: fmkdir,  Next: frmdir,  Prev: fhome,  Up: Files and Directories

11.4.12 Create a new directory
------------------------------

Procedure template:
     fmkdir(string?DIR,_file_permission[]?MODES){}

Create a new directory - called DIR - with the specified modes.  MODES
is a list of `_file_permission_' symbols which define the legal access
modes for the directory.

   Possible errors:
   * `"1st argument should be a string"'

   * `"cant create directory"'

   * `"invalid mode"'

   * `"permission denied"'


File: april.info,  Node: frmdir,  Next: fls,  Prev: fmkdir,  Up: Files and Directories

11.4.13 Remove a directory
--------------------------

Procedure template:
     frmdir(string?DIRECTORY){}

Remove the directory DIRECTORY, if it exists, is empty and the
requesting process has the relevant permissions.

   Possible errors:
   * `"cant remove directory"'

   * `"permission denied"'


File: april.info,  Node: fls,  Prev: frmdir,  Up: Files and Directories

11.4.14 List files in directory
-------------------------------

Function template:
     fls(string?DIRECTORY)=>string[]

Returns a list of all the filenames in the specified DIRECTORY -
providing that the requesting process has access to the directory.

   Possible errors:
   * `"cant access directory"'

   * `"permission denied"'


File: april.info,  Node: String oriented input/output,  Next: Encoded Input/Output,  Prev: Files and Directories,  Up: Input and output

11.5 Reading and writing to files
=================================

The `classic' way of writing to a file is to send the file process a
message. File processes consume `string' messages and append the string
value to the current position of the file.  For example, to write the
`"hello world"' string to the `stdout' use:

       "hello world\n" >> stdout

`April' has a number of string formatting functions and operators
(*note String formatting::) that make it straightforward to format
values into `string's in order to output them. For example, to display
a `number' value in a fixed field of 4 characters use:

       "Fixed field ["++Val~4++"]\n" >> stdout

In addition to the `tilda-hat' notation (*note String formatting::) , a
second major way of displaying results is the use of type coercion
(*note type coercion::). We can display an arbitrary value by coercing
the value into a `string':

       "Some value "++string%%Val++"\n" >> stdout

It is fairly common to combine the use of the `tilda-hat' notation with
type coercion and string concatenation (*note concatenate strings::) to
construct text file output.

   Other than writing strings, `April' supports the `fencode' (*note
fencode::) primitive for writing encoded values to files.

* Menu:

* inchar::                      Read a single character
* inbytes::                     Read a block of binary data
* inchars::                     Read a block string
* inascii::                     Read a single byte from a file
* inline::                      Read a line
* outchar::                     Write a string


File: april.info,  Node: inchar,  Next: inbytes,  Up: String oriented input/output

11.5.1 Read a single character
------------------------------

Function template:
     inchar(handle?FILE)=>string

Reads a single character from a file controlled by a file process. The
returned character is returned as a single character string.

   The process will suspend if there is no data available - in
particular if the file is the keyboard (`stdin') or a `popen'ed file.

   Reading at the end of file will cause the `"end of file"' run-time
error. This error can be prevented by using the `eof' test (*note
eof::) or it can be `caught' using the `onerror' block:

       try
         X := inchar(FILE)
       onerror {
         _ -> ...
       };

This will normally result in the variable X being assigned the next
character from the file. But if `eof' is true before (or in the middle
of) reading the item, then a run-time error will result - this error is
caught by the `onerror' statement.

   Possible errors:
   * `"file not open for reading"'

   * `"end of file"'

   * `"permission denied"'


File: april.info,  Node: inchars,  Next: inascii,  Prev: inbytes,  Up: String oriented input/output

11.5.2 Read a block string
--------------------------

Function template:
     inchars(handle?FILE,number?COUNT)=>string

Reads a block of characters from a file process and returns them in the
form of a string. If the file is already at end-of-file, then an `end of
file' error will be reported; otherwise if there are less than COUNT
bytes left in the file, then the remaining bytes will be returned.

   This implies that the length of the returned string should be
checked if it is likely that it may be shorter that the amount
originally requested.

   The process will suspend if there is no data available - in
particular if the file is the keyboard (`stdin') or a `popen'ed file.

   As with other input functions, reading at the end of file will cause
the run-time error `"end of file"'. This error can be prevented by
using the `eof' test (*note eof::) or it can be `caught' using the
`onerror' block (*note inchar::).

   Possible errors:
   * `"argument is not a valid file descriptor"'

   * `"file not open for reading"'

   * `"end of file"'

   * `"permission denied"'


File: april.info,  Node: inbytes,  Next: inchars,  Prev: inchar,  Up: String oriented input/output

11.5.3 Read a block of bytes
----------------------------

Function template:
     inbytes(handle?FILE,number?COUNT)=>number[]

Reads a block of bytes from a file process and returns them in the form
of a list of numbers. If the file is already at end-of-file, then an
`end of file' error will be reported; otherwise if there are less than
COUNT bytes left in the file, then the remaining bytes will be returned.

   This implies that the length of the returned list should be checked
if it is likely that it may be shorter that the amount originally
requested.

   The process will suspend if there is no data available - in
particular if the file is the keyboard (`stdin') or a `popen'ed file.

   As with other input functions, reading at the end of file will cause
the run-time error `"end of file"'. This error can be prevented by
using the `eof' test (*note eof::) or it can be `caught' using the
`onerror' block (*note inchar::).

   Possible errors:
   * `"argument is not a valid file descriptor"'

   * `"file not open for reading"'

   * `"end of file"'

   * `"permission denied"'


File: april.info,  Node: inascii,  Next: inline,  Prev: inchars,  Up: String oriented input/output

11.5.4 Read a byte as ASCII byte
--------------------------------

Function template:
     inascii(handle?FILE)=>number

Reads a byte from a file process and return it in the form of an integer
ASCII code. If the file is already at end-of-file, then an `end of
file' error will be reported.

   The process will suspend if there is no data available - in
particular if the file is the keyboard (`stdin') or a `popen'ed file.

   As with other input functions, reading at the end of file will cause
the run-time error `"end of file"'. This error can be prevented by
using the `eof' test (*note eof::) or it can be `caught' using the
`onerror' block (*note inchar::).

   Possible errors:
   * `"argument is not a valid file descriptor"'

   * `"file not open for reading"'

   * `"end of file"'

   * `"permission denied"'


File: april.info,  Node: inline,  Next: outchar,  Prev: inascii,  Up: String oriented input/output

11.5.5 Read a line of text
--------------------------

Function template:
     inline(handle?FILE)=>string

Reads characters from the file process until either end of file is
reached or a new-line character is read. The line that was read is
returned as a string - not including the new-line character itself.

   The process will suspend if there is no data available - in
particular if the file is the keyboard (`stdin') or a `popen'ed file.

   As with other input functions, reading at the end of file will cause
the run-time error `"end of file"'. This error can be prevented by
using the `eof' test (*note eof::) or it can be `caught' using the
`onerror' block (*note inchar::).

   Possible errors:
   * `"argument is not a valid file descriptor"'

   * `"file not open for reading"'

   * `"heap exhausted"'

   * `"end of file"'

   * `"permission denied"'


File: april.info,  Node: outchar,  Prev: inline,  Up: String oriented input/output

11.5.6 Write character string
-----------------------------

Procedure template:
     outchar(handle?FILE,string?TEXT){}

The contents of the `string' TEXT is written out to the file controlled
by the file process. Note that special character sequences embedded in
the string - such as ``\n'' - will be interpreted as the appropriate
control codes;(1) and that if the TEXT contains NULL characters they
will also be written to the file.

   A version of this message protocol consists simply of the TEXT
string itself. I.e., the message:

     "hello\n" >> file_process

is approximately equivalent to:

     outchar(file_process,"hello\n")

except, that when a simple `string' is sent to a file process, it does
not normally reply. This simplifies the handling of normal output;
processes which perform output can avoid waiting for redundant replies
from the file process.

   Possible errors:
   * `"file not open for writing"'

   * `"problem in writing to file"'

   * `"permission denied"'

   ---------- Footnotes ----------

   (1) Actually, this interpretation is performed by the `April'
compiler not the `outchar' procedure.


File: april.info,  Node: Encoded Input/Output,  Next: Socket library,  Prev: String oriented input/output,  Up: Input and output

11.6 Encoded Input/Output
=========================

For compactness, efficiency of interpretation and portability, `April'
communicates data using a term encoding scheme. The exact layout of
data using this notation is described in *note Encoded term format::
The following primitives allow `April' applications to read and write
to files and streams using this notation.

   Reading and writing `April' data with this notation is more
efficient that normal `source level' reading and writing; furthermore
using encoded term I/O allows program code to be saved in files - which
is not possible using the normal `character' syntax of `April' data.

* Menu:

* fencode::                     Write an `April' value in encoded form
* fdecode::                     Decode an encoded form


File: april.info,  Node: fencode,  Next: fdecode,  Up: Encoded Input/Output

11.6.1 Write `April' value in encoded form
------------------------------------------

Procedure template:
     fencode(handle?FILE,any?TERM){}

The data TERM is written out to the file in an encoded format (*note
Encoded term format::). This format preserves the integrity of the data
- including any embedded functions and procedures - so that it may be
reliably read back.


File: april.info,  Node: fdecode,  Prev: fencode,  Up: Encoded Input/Output

11.6.2 Read encoded data value from file
----------------------------------------

Function template:
     fdecode(handle?FILE)=>any

Data is read from the file in encoded format.  The process will suspend
if there is no data available.

   If end of file is reached while reading the encoded value, then an
`"end of file"' error will be raised.

   Note that the return type of `fdecode' is type `any' - which implies
that this value must be typecast before it can be used in a sensible
way.


File: april.info,  Node: Socket library,  Next: Stream input & output,  Prev: Encoded Input/Output,  Up: Input and output

11.7 The Socket library
=======================

`April' provides a high-level way of establishing TCP connections with
the outside world, and also of enabling an `April' program to act as a
TCP server.(1)

* Menu:

* tcp_connect::                 Establish a TCP connection
* tcp_server::                  Establish a TCP service

   ---------- Footnotes ----------

   (1) A client of an `April' server does not need to be aware of the
fact that it is connected to a program written in `April'. Similarly,
`April' programs can connect to non-`April' based services.


File: april.info,  Node: tcp_connect,  Next: tcp_server,  Up: Socket library

11.7.1 Establish a TCP connection
---------------------------------

Function template:
     tcp_connect(string?HOST,integer?PORT) => (handle?INPUT,handle?OUTPUT)

This function is used to establish a TCP connection to another host
computer. The returned value is a pair of file processing handles - for
handling the INPUT and OUTPUT of the connection.

   Once a connection is established, the INPUT process represents the
input connection from the remote connection and OUTPUT represents the
output connection. For example, a call to `inline' from INPUT will read
the next line from the connection and a `outchar' can be used to write
to OUTPUT.  Most of the standard file I/O functions will operate on
these file processes - most notably except for `fseek' or `ftell'.

   If the remote service closes down, then the INPUT file process will
report an `end of file' condition. Using `fclose' on the INPUT and
OUTPUT channels will cause the remote connection to be closed from the
client's side.

   _Note: _ the `sio_connect' function can also be used to connect to a
remote TCP server; except that the input and output files are streaming
files.


File: april.info,  Node: tcp_server,  Prev: tcp_connect,  Up: Socket library

11.7.2 Establish a TCP server
-----------------------------

Function template:
     tcp_server(integer?PORT,HANDLER?P)=>handle

This function is used to establish a TCP server on the current host on
PORT. Whenever a remote client attempts to connect to this service,
(either using the `tcp_connect' function or through a  client program),
then a new `April' process is forked to handle the new connection.

   The HANDLER is a procedure whose type must match:

     (string?HOST-IP,integer?PORT,handle?INPUT,handle?OUTPUT){}

where HOST-IP is a string denoting the IP address of the remote
computer - expressed using standard quartet notation, PORT is a port
number allocated for this session, INPUT and OUTPUT are two file
handles that manage the incoming traffic and outgoing traffic on the
connection.

   In effect, when the remote client establishes contact, `April' will
execute a `spawn' call similar to:

     spawn P(HOST-IP,`port',INPUT,OUTPUT)

except that the `creator' of this process (*note creator::) will be the
current process that created the listening channel - i.e., the process
which executed the `tcp_server' function.

   In addition, a message of the form:

     ('new_connection,CL)

will be sent to the process which created the `tcp_server'; where CL is
the `handle' of the process `spawn'ed to handle the connection.

   The intention is that the procedure P implements the server
functionality itself. Each new connection will acquire a new copy of the
P process which is specifically targetted to the new client connection.
The identity of each new client handling process is returned to allow a
centralized server manager process to manage several cients
simultaneously.

   The `tcp_server' function itself terminates immediately - it returns
the file process handle which is responsible for managing new
connections. This `handle' can be used to verify that `new_connection'
messages that are received are valid.

   _Hint:_

     For security reasons, the meaning of the string passed into the
     `server' procedure when a new connection is just the IP address of
     the remote connection - expressed as a standard IP quartet.  The
     programmer can use the *note iptohost:: function to find out the
     host name of the remote machine.

   _Note:_ the `sio_server' function can also be used to implement a
TCP server; except that the input and output files are streaming files.


File: april.info,  Node: Stream input & output,  Prev: Socket library,  Up: Input and output

11.8 Stream Input and Output
============================

The stream input/output package provides a more stream oriented
asynchronous model for file I/O.(1) Essentially, a stream input file is
a process that generates a stream of messages for its client containing
the contents of the file; similarly, a stream output file is a client
that accepts a stream of messages and appends the content of those
messages to the file that it controls.

   There are streaming models for regular files - as opened with the
`sio_open' function (*note sio_open::) - and for TCP clients and
servers (*note sio_connect:: and *note sio_server::).

   When a stream is opened, the _style_ of the stream is set to one of:

`char_stream'
     A `char_stream' generates a stream of single-character symbol
     messages.(2)

     Each element of the stream is presented in a message of the form:

          sio_char(number?NO,symbol?CH)

     where NO represents the index of the character in the stream and
     CH is the character itself - as a `symbol'

`line_stream'
     A `line_stream' generates a stream of lines.

     Each line of text in the stream is presented in a message of the
     form:

          sio_text(number?NO,string?TXT)

     where NO represents the index of the line in the stream and TXT is
     the line itself - as a `string'.

`text_stream'
     A `text_stream' generates a stream of blocks of text. The size of
     the text block is not determined - it may vary from the entire
     file in the case of a regular file to small chunks of text in the
     case of a TCP stream or keyboard stream.

     Each block of text in the stream is presented in a message of the
     form:

          sio_text(number?NO,string?TXT)

     where NO represents the index of the line in the stream and TXT is
     the text block itself - as a `string'.

     Note that the precise division of the file into blocks is not
     mandated by this form of stream. However, in general, `April' will
     always attempt to `deliver' as much of the file as is currently
     available. That means that when reading regular files, a
     `text_stream' will usually consist of a single message -
     consisting of a block containing the entire file contents. For
     more asynchronous file streams - such as keyboard input or TCP
     streams - the message stream will consist of smaller blocks of
     text that are made available as quickly as possible.

`coded_stream'
     A `coded_stream' generates a stream of `April' values - which have
     been encoded using `April''s term encoding system.

     Each element of the stream is presented in a message of the form:

          sio_term(number?NO,%T?VALUE)

     where NO is the index of the element in the stream, and VALUE is
     the element itself.

     Note that the type of the element is not determined by this type
     template.

The message stream type is codified in the `April' type declaration:

     _stream_mode ::= char_stream
        | line_stream
        | text_stream
        | term_stream
        | coded_stream
        ;

and the message type is codified in the `April' type declaration:

     _stream_protocol(%a) ::=
          sio_char(number,symbol)
        | sio_text(number,string)
        | sio_term(number,%a)
        | sio_end;

* Menu:

* sio_open::
* sio_connect::
* sio_server::

   ---------- Footnotes ----------

   (1) These facilities were introduced in Version 4.3.1e, and are
experimental.

   (2) For future reference: each single-character item will refer to a
single `glyph' rather than a single byte.


File: april.info,  Node: sio_open,  Next: sio_connect,  Up: Stream input & output

11.8.1 Open a stream
--------------------

The `sio_open' function can be used to open a file as a stream. The
template of the `sio_open' function is:

Function template:
     sio_open(string?FILENAME,_file_open_mode?MODE,_stream_mode?STYLE,handle?CLIENT) => handle

The `sio_open' functions requests that the process's file manager open
the file FILENAME as a stream. The supported _FILE_OPEN_MODEs are:

`_open_read'
     Where the file already exists and is to be read.

`_open_write'

`_create_write'

`_open_append'
     Where the file exists and new data is written to the end of the
     file.

`_create_append'

The STYLE indicates one of the legal stream styles.

   In the case of an input stream, the messages comprising the file's
contents are sent to the CLIENT process. For output streams this
argument is ignored.

   The form of the messages generated and consumed by a stream is
defined by the type:

     _stream_protocol(%a) ::=
          sio_char(number,symbol)
        | sio_text(number,string)
        | sio_term(number,%a)
        | sio_end;

Each message has a number associated with it; this is in an index
number: an input stream generates messages in order and an output
message expects messages in strictly ascending order.

   `sio_text' messages are used for `string' oriented streams and
`sio_term' messages are used for others.

   An input message stream would typically be processed using a
`repeat'...`until' loop:

       S = sio_open("FILE",line_stream,self());

       repeat
         sio_text(No,T) ->>
           "Line "++No^0++" "++T++"\n">>stdout
       until sio_end

   An output stream consumes messages, also in the same form. When the
output stream receives an `sio_end' message the stream closes:

       sio_text(1,"First line") >> out;
       sio_text(2,"Second line") >> out;
     ...
       sio_text(100,"Last line") >> out;
       sio_end >> out


File: april.info,  Node: sio_connect,  Next: sio_server,  Prev: sio_open,  Up: Stream input & output

11.8.2 Open a stream-oriented TCP connection
--------------------------------------------

The `sio_connect' is similar to the `tcp_connect' function, except the
generating and consuming file processes are streams rather than regular
file processes.

Function template:
     sio_connect(string?HOST,string?PORT,_stream_mode?STYLE,handle?CLIENT) => (InP,OutP)

The `sio_connect' function attempts to connect to the HOST computer at
port PORT. The returned processes are STYLE stream processes. The input
messages are delivered to the CLIENT process in an analogous manner to
the `sio_open'.


File: april.info,  Node: sio_server,  Prev: sio_connect,  Up: Stream input & output

11.8.3 Open a stream-oriented TCP server
----------------------------------------

Function template
     sio_server(integer?PORT,HANDLER?P,_stream_mode?STYLE)=>handle

This creates a TCP server listening to port PORT. When a new connection
is established, a new `April' process is forked to handle it. The
forked process executes the P process with a call of the form:

     P(HOST-IP,PORT,IN-STREAM,OUT-STREAM)

The streams will be STYLE streams; the output of the in-STREAM will go
to the newly-forked process.

   As with `tcp_server' (*note tcp_server::), whenever a connection is
established, a message of the form:

     ('new_connection,CL)

is sent to the establishing process. This message can be used to collate
the connections and their managing processes.


File: april.info,  Node: String handling,  Next: Lists and sets,  Prev: Input and output,  Up: Top

12 String and Character Handling
********************************

A `string' is a list of `char' values.

   `April' supports strings in two main ways - by providing a suite of
string manipulation functions such as substring and string append - and
by a set of string patterns (*note String patterns::) which allow
strings to be parsed as part of a match statement or expression.

* Menu:

* Basic string functions::
* Character handling::
* String formatting::           Make strings from numbers and other values
* Accessing elements of strings::
* Basic symbol processing::


File: april.info,  Node: Basic string functions,  Next: Character handling,  Up: String handling

12.1 Basic string functions
===========================

The following functions are basic operations on strings. They form a
simple `spanning set' of operations on strings, allowing them to be
dismantled as well as being constructed from smaller pieces.

* Menu:

* strlen::                      The length of a string
* string character prepend::
* concatenate strings::         Join strings together
* expand::                      Analyse a string into components
* collapse::                    Collapse a list of strings into one string


File: april.info,  Node: strlen,  Next: string character prepend,  Up: Basic string functions

12.1.1 Length of a string
-------------------------

Function template:
     strlen(string?S) => number

This function returns the length of the string S.


File: april.info,  Node: string character prepend,  Next: concatenate strings,  Prev: strlen,  Up: Basic string functions

12.1.2 String character prepend
-------------------------------

Function template:
     symbol?SYM,+string?STR => string

The `,+' function returns a `string' formed by prepending the character
- which is a `symbol' - onto the front of `str'.(1) Note that `,+' also
may act as a matching operator in patterns - *Note Character matching::.

   ---------- Footnotes ----------

   (1) This feature is not yet finalized.


File: april.info,  Node: concatenate strings,  Next: expand,  Prev: string character prepend,  Up: Basic string functions

12.1.3 Concatenate strings
--------------------------

Function template:
     string?STR1 ++ string?STR2 => string

The `++' function returns the string formed by concatenating STR1 and
STR2 together. Note that `++' also acts as a special string matching
operator in patterns - *Note String partitioning::.


File: april.info,  Node: expand,  Next: collapse,  Prev: concatenate strings,  Up: Basic string functions

12.1.4 Split a string into segments
-----------------------------------

Function template:
     expand(string?STR,string?KEY) => string[]

This function is used to analyse a string into components. The STR is
searched for occurrences of characters from KEY. The returned value is
a list of strings, each element consisting of a segment from the STR
between points where a character from KEY occurs.

   For example, the value of:

     expand("peter@lg.doc.ic.ac",".@")

is the list:

     ["peter","lg","doc","ic","ac"]

   _Hint:_

     This function can be used to construct a simple tokenizer. For
     example, if a token consists of words separated by spaces then the
     expression:

          expand("This is a string of words"," \t\n")

     would parse the string into the list of words:

          ["This", "is", "a", "string", "of", "words"]


File: april.info,  Node: collapse,  Prev: expand,  Up: Basic string functions

12.1.5 Collapse list of `string's together
------------------------------------------

Function template:
     collapse(string[]?WORDS,string?GLUE) => string

This function takes a list of strings, and a `glue' string, and
concatenates them all together into a single string. A copy of the
string GLUE is inserted between each word in WORDS as it is copied into
the returned string.


File: april.info,  Node: Character handling,  Next: String formatting,  Prev: Basic string functions,  Up: String handling

12.2 Character handling
=======================

* Menu:

* charOf::                      Compute character associated with code
* charCode::                    Compute code associated with a character


File: april.info,  Node: charOf,  Next: charCode,  Up: Character handling

12.2.1 `charOf' - compute character associated with code
--------------------------------------------------------

Function template:
     charOf(number?CODE) => char

The `charOf' function returns the character value associated with a
given Unicode value.

   Possible errors:
   * `"argument should be an integer"'


File: april.info,  Node: charCode,  Prev: charOf,  Up: Character handling

12.2.2 `charCode' - compute Unicode code associated with character
------------------------------------------------------------------

Function template:
     charCode(char?CH) => number

The `charCode' function returns the Unicode code associated with a
character.


File: april.info,  Node: String formatting,  Next: Accessing elements of strings,  Prev: Character handling,  Up: String handling

12.3 String formatting
======================

The string formatting functions allow the construction of strings from
other values.  The most important - but not only - use for these
functions is for formatted output.

* Menu:

* Formatting values::           String formatting notation
* strof::                       Convert a value into a string
* int2str::                     Convert an integer into a string
* strpad::                      Reformat a string into another string
* sencode::                     Encode an any value into a string
* sdecode::                     Decode a string containing an encoded term


File: april.info,  Node: Formatting values,  Next: strof,  Up: String formatting

12.3.1 Higher-level notation for formatting values
--------------------------------------------------

Function template:

There is a more compact notation which can be used for formatting
individual values in a `string' expression. This is the `~^' notation.

`~'
     An expression of the form:

          EXP ~ W

     means `format the value EXP as a `string' in W characters'. EXP
     can be a `number' value, a `handle' value or a `string' value.

     If the result of formatting EXP would result in a `string' that is
     shorter than W then the result is padded. If `W' is positive then
     the result is left formatted, otehrwise the result is right
     formatted.

`^'
     An expression of the form:

          EXP ^ P

     means format EXP to precision P. If EXP is a number then this
     refers to the number of decimal places after the decimal point; if
     EXP is a `string' then it refers to the number of characters from
     EXP that are displayed; and if EXP is a `handle' then it refers to
     the form of the handle (*note strof:: for more precise details of
     the interpretation of the precision).

     Note that an expression such as `EXP^0' has some similarities to
     the expression `string%%EXP'. However, there is a subtle
     difference: the former expression is used to `prepare' the
     expression EXP for display, whereas the type coercion expression
     `converts' the value into a string. One instance where makes a
     difference is where the type of EXP is already a `string'. For
     example: 

          "foo"^0

     compared to:

          string%%"foo"

     The values returned by these expressions is different. The value
     of the first is:

          "\"foo\""

     whereas the second expression returns simply `"foo"'.

     Another classic example of the difference is with lists of single
     character symbols (including the empty list). The value of the
     expression:

          [''a]^0

     is the string: `"[''a]"', whereas the value of `string%%[''a]' is:
     `"a"' - this is because the `%%' operator coerces a list of single
     character symbols into a string. Similarly, the value of `[]^0' is
     `"[]"', whereas the value of `string%%[]' is simply `""'.

`^~'
     The `~' and `^' operators can be combined, as in:

          EXP ~10 ^3

     which means display EXP to precision `3' in a field of `10'
     characters.

     It is also permissable to use these operators as a `^~' pair:

          EXP ^3 ~10

     which has the same meaning as above.


File: april.info,  Node: strof,  Next: int2str,  Prev: Formatting values,  Up: String formatting

12.3.2 Format value into `string'
---------------------------------

Function template:
     strof(%t?X,number?PRECISION,number?WIDTH)=>string

The `strof' function formats any `April' value into a `string'.

   It is intended to be used with the higher-level `~^' string
formatting notation.

   The various cases are:

`number'
     In the case of an integer value, the precision field is ignored.
     The `integer' is displayed as a decimal string. If the number is
     negative then a `-' character is prepended to the string.

     In the case of a fractional value, the precision field denotes the
     number of significant digits to the right of the decimal place
     that are displayed. A precision of 0 means that all the
     significant digits will be displayed.

`string'
     In the case of a `string' value, the PRECISION denotes the number
     of characters from the X value that will be displayed. If the
     PRECISION is negative then it refers to the _end_ of the string;
     i.e., the last PRECISION characters will be used. Otherwise the
     first PRECISION characters from the `string' value X will be used.

     A precision of 0 means that all characters in X will be used.

`handle'
     In the case of a `handle' value, the PRECISION refers to how much
     of the `handle' is displayed.

     A precision of 0 means that all of the `handle' - including the
     location address list - will be displayed. This is the full form
     of the `handle'.

     A precision of 1 means that only the target and name will be
     displayed.

     A precision of 2 means that the location address field will _not_
     be displayed, but the target, name and home will be displayed.

`any'
     All other cases are displayed using a minimal default form. The
     PRECISION controls the `depth' that values are formatted. For
     example, if a precision of 2 is selected, then the value:

          (foo,[bar(10),jar([xx])])

     is displayed as:

          "(foo,[bar(...),jar(...)])"

     I.e., the top two levels of the structure are displayed, and other
     values are omitted, shown with ellipsis.


File: april.info,  Node: int2str,  Next: strpad,  Prev: strof,  Up: String formatting

12.3.3 Format an integer into a `string'
----------------------------------------

Function template:
     int2str(number?N,number?BASE,number?WIDTH,char?PAD,logical?LEFT)=>string

The `int2str' function formats an integer value; displaying it in
`base' arithmetic (a base of 16 gives a hexadecimal number, and 10
formats a regular decimal number).

   If LEFT is true, then the number will left formatted, otherwise it
will be right formatted. For a right formatted number, the PAD will be
used to pad characters `out to the left' if the number of characters
needed to represent N is less than WIDTH. If the number is left
formatted, then a space character will be used to pad to the right.

   Note that if the width parameter is zero, then only exactly enough
characters to represent the integer on a string will be used, and both
PAD and LEFT will be ignored.


File: april.info,  Node: strpad,  Next: sencode,  Prev: int2str,  Up: String formatting

12.3.4 Re-format a `string'
---------------------------

Function template:
     strpad(string?X,number?WIDTH,string?PAD) => string

The `strpad' function reformats a `string' value into another string.
The length of the output string is given by WIDTH - if WIDTH is 0 then
the output is the same as the input, otherwise it specifies the length
of the output string.

   If the WIDTH is negative, then the output is `right formatted' -
i.e., if the input is smaller than `abs(WIDTH)' then the input is
placed at the right hand end of the output string, otherwise if the
WIDTH is positive, then the output is left-formatted.

   If the input is smaller than the output, then additional characters
must be generated. These additional characters are obtained from the
first character of PAD - generally this will be a space character but
may be anything.

   For example, to right-format a hexadecimal integer K in 10 places,
with leading zeroes, use:

     strpad(int2str(K,16),-10,"0")


File: april.info,  Node: sencode,  Next: sdecode,  Prev: strpad,  Up: String formatting

12.3.5 Encode a value as a `string'
-----------------------------------

Function template:
     sencode(any?X) => string

The `sencode' function reformats an `any' value into a string in the
`encoded term' format. This is the smae format as used by `fencode' and
`April' for representing compiled programs. Encoded term format can
represent any legal `April' value - including programs and closures.

   The term encoded form of a term is suitable for storing values in
persistent storage and for sending between `April' applications.

   For example, to encode a list of numbers use:

     sencode(any([1,4,2,6]))


File: april.info,  Node: sdecode,  Prev: sencode,  Up: String formatting

12.3.6 Decode an encoded term string
------------------------------------

Function template:
     sdecode(string?X) => any

The `sdecode' function decodes a string containing an encoded term and
returns the decoded value as an `any' value.

   For example, to decode an encoded term containing a list of numbers
use:

     sdecode(sencode(any([1,4,2,6]))) = any([1,4,2,6])


File: april.info,  Node: Accessing elements of strings,  Next: Basic symbol processing,  Prev: String formatting,  Up: String handling

12.4 Accessing elements of `string's
====================================

These functions provide a mechanism for accessing characters and bytes
from `string' values

* Menu:

* ascii::                       Convert a string into a list of ASCII codes
* nthascii::                    Extract the nth char from a string


File: april.info,  Node: ascii,  Next: nthascii,  Up: Accessing elements of strings

12.4.1 Convert a `string' into list of ASCII bytes
--------------------------------------------------

Function template:
     ascii(string?SYM) => number[]

This function returns a list of integers corresponding to the ASCII
value of the characters in the string.


File: april.info,  Node: nthascii,  Prev: ascii,  Up: Accessing elements of strings

12.4.2 Extract ASCII byte from `string'
---------------------------------------

Function template:
     nthascii(string?STR,number?NTH) => number

This function returns an integer corresponding to the ASCII value of
the NTH character in the string.


File: april.info,  Node: Basic symbol processing,  Prev: Accessing elements of strings,  Up: String handling

12.5 Basic symbol processing
============================

`April' offers some string matching patterns - *note String patterns::
- however, for many applications this is not powerful enough. For
example, `April''s string patterns are not powerful enough to construct
parsers.(1)

   For this reason, `April' offers some facilities to convert between
strings and lists of numbers or lists of symbols. In addition, there are
also some functions for converting between numbers and single character
symbols.

* Menu:

* explode::                     Convert a symbol into a string
* implode::                     Convert a string into a symbol
* Converting from a string to a list of symbols::
* Converting from a list of symbols to a string::
* Converting a single character symbol to a number::
* Converting a number to a single character symbol::

   ---------- Footnotes ----------

   (1) That is, not powerful enough without a lot of effort.


File: april.info,  Node: explode,  Next: implode,  Up: Basic symbol processing

12.5.1 `explode' a symbol into a `string'
-----------------------------------------

Function template:
     explode(symbol?SYM) => char[]

The `explode' function takes a symbol and returns a `string' whose
characters consist of the letters that make up the symbol's print name.


File: april.info,  Node: implode,  Next: Converting from a string to a list of symbols,  Prev: explode,  Up: Basic symbol processing

12.5.2 `implode' a string into a `symbol'
-----------------------------------------

Function template:
     implode(string?SYM) => symbol

The `implode' function is the inverse of the `explode' function; it
takes a string and returns a `symbol' whose print name is composed of
the characters of the string.


File: april.info,  Node: Converting from a string to a list of symbols,  Next: Converting from a list of symbols to a string,  Prev: implode,  Up: Basic symbol processing

12.5.3 Converting from a string to a list of symbols
----------------------------------------------------

The type coercion facility of `April' - *note type coercion:: - can be
used to convert a `string' into a list of single character symbol:

     SS = symbol[]%%"foo";

   The list generated in this situation is a list of single glyph
symbols.(1)

   Such a list can be processed using `April''s list processing
facilities which can easily be used to contruct recursive parser
programs.

   Note that the memory requirements of a list of symbols is
significantly greater than for a `string'. For that reason, this
approach is not used universally within `April'.

   ---------- Footnotes ----------

   (1) Normally for ASCII and for Latin character sets a glyph is
represented by a single byte; but some languages use multi-byte
sequences to represent a single character or glyph.


File: april.info,  Node: Converting from a list of symbols to a string,  Next: Converting a single character symbol to a number,  Prev: Converting from a string to a list of symbols,  Up: Basic symbol processing

12.5.4 Converting from a list of symbols to a string
----------------------------------------------------




File: april.info,  Node: Converting a single character symbol to a number,  Next: Converting a number to a single character symbol,  Prev: Converting from a list of symbols to a string,  Up: Basic symbol processing

12.5.5 Converting a single character symbol to a number
-------------------------------------------------------

Function template:
     sym2ascii(symbol) => number

The `sym2ascii' function converts the first glyph in a symbol to its
ascii equivalent. Where a glyph is a multi-byte sequence the number
returned is the product of all the bytes in the sequence.


File: april.info,  Node: Converting a number to a single character symbol,  Prev: Converting a single character symbol to a number,  Up: Basic symbol processing

12.5.6 Converting a number to a single character symbol
-------------------------------------------------------

Function template:
     ascii2sym(number) => symbol

The `ascii2sym' function converts a number into a single glyph symbol.
The numeric argument may represent a multi-byte sequence, in which case
the resulting symbol may be multi-byte - although still represent a
single character.


File: april.info,  Node: Lists and sets,  Next: Processes,  Prev: String handling,  Up: Top

13 Lists and Sets
*****************

One particular `form' of `April' list is the set. An `April' set is
simply a list like other lists; however, `April' supports a number of
set-style operations which allow programmers to use lists as sets. We
refer to this as the _set interpretation_ on lists - to distinguish
`April''s collect of set-style operators from a true (and expensive)
set type.

* Menu:

* List operations::             Standard list operators
* Pattern based operations on lists::
* Lists and set abstractions::


File: april.info,  Node: List operations,  Next: Pattern based operations on lists,  Up: Lists and sets

13.1 List Operations
====================

These functions operate over all kinds of lists. They provide standard
functions that manipulate lists. Most of these functions are _generic_
- they accept as an arguments lists of any type. Where an argument of a
function is generic in this way, we will use the type - %A - to denote
this.

   The type checker enforces type strictness of generic arguments: for
example, the `<>' function (*note <>::) will append any kinds of lists
together: it only requires that both of its arguments are the _same_
kind of list.

* Menu:

* #::                           List indexing
* listlen::                     List length
* front::                       Front portion of a list
* back::                        Back portion of a list
* head::                        Extract first element of list
* tail::                        Extract remainder of list
* <>::                          List append
* List cons::                   Construct new list
* ..::                          Generate a list of integers
* iota::                        Generate a list of integers
* List map::
* List reduction::
* sort::                        Sort list


File: april.info,  Node: #,  Next: listlen,  Up: List operations

13.1.1 Index element of a list
------------------------------

Function template:
     %A[]?A#number?I => %A

The list-indexing function accesses individual elements of a list. The
index I should evaluate to an integer between 1 and the length of the
list; and it returns the Ith element of the list A.  An error occurs if
I is less than 1 or greater than the list length.

   Note that the base `April' language does not allow the `list update'
operation suggested by a statement such as:
     A#i:=23;


File: april.info,  Node: listlen,  Next: front,  Prev: #,  Up: List operations

13.1.2 Length of a list
-----------------------

Function template:
     listlen(%A[]?A) => number

This function returns the length of the list A. If the list is not
null-terminated, then the length is returned as a negative number.


File: april.info,  Node: front,  Next: back,  Prev: listlen,  Up: List operations

13.1.3 Extract front elements from list
---------------------------------------

Function template:
     front(%A[]?T,number?N) => %A[]

This function returns a list consisting of the first N elements of T.
If N is too big, the whole list is returned.  If N is negative, it
raises an exception.

   Possible errors:
   * `"2nd argument should a positive integer"'


File: april.info,  Node: back,  Next: head,  Prev: front,  Up: List operations

13.1.4 Extract end elements from list
-------------------------------------

Function template:
     back(%A[]?T,numberN) => %A[]

This function returns a list consisting of the last N elements of T.
If N is too big, the whole list is returned.  If N is negative, it
raises an exception.

   Possible errors:
   * `"2nd argument should a positive integer"'


File: april.info,  Node: head,  Next: tail,  Prev: back,  Up: List operations

13.1.5 Extract head of list
---------------------------

Function template:
     head(%A[]?T) => %A

This function returns the first element of the list T. Note that this
function can be defined in terms of a `valis/valof' expression which
uses list patterns:

     valof {
       [H,.._] .= T;
       valis H
     }


File: april.info,  Node: tail,  Next: <>,  Prev: head,  Up: List operations

13.1.6 Tail of list
-------------------

Function template:
     tail(%A[]T,numberN) => %A[]

This function returns a list consisting of the remainder of the list
after counting N elements from the front of T.  If N is too big, the
empty list is returned.  If N is negative, it raises an exception.

   Possible errors:
   * `"2nd argument should a positive integer"'


File: april.info,  Node: <>,  Next: List cons,  Prev: tail,  Up: List operations

13.1.7 Append lists together
----------------------------

Function template:
     %A[]?T1<>%A[]?T2 => %A[]

This function returns the list made by appending T2 to the end of T1.


File: april.info,  Node: List cons,  Next: ..,  Prev: <>,  Up: List operations

13.1.8 List construction
------------------------

Function template:
     [%A?T1 ,.. %A[]?T2] => %A[]

This operator represents the list made by `consing' the element T1 to
the front of the list T2.

   In general, several elements can be consed onto a list in one step:

     ['fred, 'jim, 'harry ,.. NAMES]

is a list which consists of the symbols `'fred', `'jim' and `'harry'
preprended to the NAMES list.

   _Hint:_

     List cons can also be used in a pattern to extract the first
     element(s) of a list. The pattern in the match statement:

          [first ,.. rest] .= NAMES

     checks that NAMES is a list, and extracts the first element of the
     list into the variable `first', and the remainder of the list into
     the variable `rest'.


File: april.info,  Node: ..,  Next: iota,  Prev: List cons,  Up: List operations

13.1.9 List of numbers
----------------------

Function template:
     number?LOW..number?HIGH => number[]

The `..' function(1) returns the list of integers ranging from LOW to
HIGH.

   If HIGH is smaller than LOW, then the empty list is returned.

   _Hint:_

     This function is used in combination with the `for' generator loop
     to provide a numeric style of `for' loop:

          for X in LOW..HIGH do
            STATEMENT

     In this situation, the function call to `..' is optimized, and the
     value is not actually constructed.

   Possible errors:
   * `"1st argument should be an integer"'

   * `"2nd argument should be an integer"'

   ---------- Footnotes ----------

   (1) Pronounced _iota_ because of the symbol used for a similar
function in APL.

